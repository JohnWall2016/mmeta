import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.InputStream
import java.io.FileInputStream
import java.util.ArrayList
import java.util.List
import java.util.Collections
import jmeta.Ast

parser MirahParser {
    def self.main(args:String[]) {
        returns void
        parser = MirahParser.new
        # parser.tracing = true
        if args.length > 0
          stream = InputStream(FileInputStream.new(args[0]))
        else
          stream = System.in
        end
        reader = BufferedReader.new(InputStreamReader.new(stream))
        buffer = char[8192]
        builder = StringBuilder.new
        while (read = reader.read(buffer, 0, buffer.length)) > 0
          builder.append(buffer, 0, read);
        end
        puts BaseParser.print_r(parser.parse(builder.toString()))
    }

    def oneOf() {
      chars = String(_pop)
      _char(chars)
    }

    def _codepoint() {
      t = _any
      return -1 if t == __ERROR__
      character = Character(t).charValue
      if character >= 0xd800 && character <= 0xdbff
        t = _any
        if t == __ERROR__
          return -1
        end
        return Character.toCodePoint(character, Character(t).charValue)
      else
        return int(character)
      end
    }

    def codepoint {
      start = _pos
      t = _codepoint
      if t == -1
        self._pos = start
        return Object(__ERROR__)
      else
        return Object(String.new(Character.toChars(t)))
      end
    }

    def identifierChar() {
      start = _pos
      c = _codepoint
      if c == 95 || Character.isLetterOrDigit(c)
        Object(String.new(Character.toChars(c)))
      else
        self._pos = start
        __ERROR__
      end
    }

    def upperCase {
      start = _pos
      c = _codepoint
      if Character.isUpperCase(c)
        Object(String.new(Character.toChars(c)))
      else
        self._pos = start
        __ERROR__
      end
    }

    def initialize {
      @HEX = "0123456789abcdefABCDEF"
      @DECIMAL = "0123456789"
      @OCTAL = "01234567"
      @BINARY = "01"
    }

    def parseInt(string:string, radix:int) {
      Integer.valueOf(Integer.parseInt(string, radix))
    }

    def stringConcat(strings:Object) {
      result = nil
      List(strings).each do |s|
        result = stringConcat(result, s)
      end
      return result
    }

    def stringConcat(a:Object, b:Object) {
      return b if a.nil?
      la = List(a)
      lb = List(b)
      if la.get(0).equals("DString") || lb.get(0).equals("DString")
        result = ArrayList.new
        result.add("DString")
        result.addAll(la.subList(1, la.size()))
        result.addAll(lb.subList(1, lb.size()))
        return List(result)
      else
        ["String", String(la.get(1)) + String(lb.get(1))]
      end
    }

    def getCodePoint(c:Object) {
      String(c).codePointAt(0)
    }

    def obj2ast(x:Object) {
      if x.kind_of?(Ast)
        Ast(x)
      elsif x.kind_of?(List)
        l = List(x)
        if l.size == 0
          Ast(nil)
        elsif l.size == 1
          obj2ast(l.get(0))
        else
          ast = Ast.new('Body', l)
          first = obj2ast(l.get(0))
          last = obj2ast(l.get(l.size - 1))
          ast.start_position = first.start_position
          ast.end_position = last.end_position
          ast
        end
      elsif x.nil?
        Ast(nil)
      else
        raise "Expected Ast, got #{x} (#{x.getClass})"
      end
    }

    def addToBlock(a:Object, b:Object) {
      x = obj2ast(a)
      y = obj2ast(b)
      if x.nil?
        return y
      elsif y.nil?
        return x
      end
      x_kids = 'Body'.equals(x.name) ? x.children : [x]
      y_kids = 'Body'.equals(y.name) ? y.children : [y]
      body = Ast.new('Body', x_kids)
      body.addAll(y_kids)
      body.start_position = x.start_position
      body.end_position = y.end_position
      body
    }

    digits x=_ : a = oneOf(x) b=("_" c=oneOf(x) {c})*
                                 d={[a] + b} { join(d) };
    ws: (oneOf(" \t\f\r\v") | "\\\n")*;
    start: ! prog=compstmt . end -> ^(Script prog);
    compstmt: terms* a=(s=statement terms+ {s})*
              b=statement?
              {addToBlock(a, b)};
    terms: . (";" | "\n") (. ";")*;

    statement: e=primary;

    primary: # "begin" bodystmt "end" |
             literal
           | string
           | variable;

    literal: numeric | symbol;

    numeric: floatLiteral | fixnum;

    constant: . ~reswords h=upperCase t=identifierChar* {"#{h}#{join(t)}"};

    variable: . "nil"                                   -> ^(Nil)
            | . "self"                                  -> ^(Self)
            | . "true"                                  -> ^(True)
            | . "false"                                 -> ^(False)
            | . "@@" n=identifierChar+                  -> ^(ClassVar join(n))
            | . "@" n=identifierChar+                   -> ^(InstVar join(n))
            | . t=identifierChar+ p=oneOf("?!") ~"="    -> ^(FCall "#{join(t)}#{p}")
            | c=constant                                -> ^(Constant c)
            | . ~reswords n=identifierChar+             -> ^(Identifier join(n));

    symbol: . ":"! v=("@@" | "@" | {""}) ! n=identifierChar+ -> ^(Symbol join(concat([v], n)));

    string: character
          | strings=string1+ {stringConcat(strings)};

    string1: . "'"! s=squote_contents* "'" -> ^(String join(s))
           | . "\"\"" -> ^(String "")
           | . "\"" s=dquote_contents "\"" {s}
           | . "\"" c=(dquote_contents | str_ev)* "\"" -> ^(DString c+)
           ;

    str_ev: "\#@@" n=identifierChar+ -> ^(EvString ^(ClassVar join(n)))
          | "\#@"! n=identifierChar+ -> ^(EvString ^(InstVar join(n)))
          | "\#{"! c=compstmt "}" -> ^(EvString c);


    squote_contents: "\\\\" { "\\" } | "\\'" { "'" } | ~"'" _;
    dquote_contents: c=(escape | ~("\#{" | "\#@" | "\"")_)+ -> ^(String join(c));

    character: . "?" e=escape -> ^(Character getCodePoint(e))
             | . "?" c=codepoint -> ^(Character getCodePoint(c));

    escape: "\\"! ("n" {"\n"}
                  |"s" {"\s"}
                  |"r" {"\r"}
                  |"t" {"\t"}
                  |"v" {"\v"}
                  |"f" {"\f"}
                  |"b" {"\b"}
                  |"a" {"\a"}
                  |"e" {"\e"}
                  |a=oneOf(@OCTAL) b=oneOf(@OCTAL) c=oneOf(@OCTAL)
                    {String.new(Character.toChars(Integer.parseInt("#{a}#{b}#{c}", 8)))}
                  |"x"! a=oneOf(@HEX) b=oneOf(@HEX)
                    {String.new(Character.toChars(Integer.parseInt("#{a}#{b}", 16)))}
                  |"u"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                    {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}", 16)))}
                  |"U"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                        c5=oneOf(@HEX) c6=oneOf(@HEX) c7=oneOf(@HEX) c8=oneOf(@HEX)
                    {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}#{c5}#{c6}#{c7}#{c8}", 16)))}
                  |codepoint
                  );

    fixnum: . n=( "0"! ( oneOf("xX") d=digits(@HEX)+ { parseInt(join(d), 16) }
                    | oneOf("dD") d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
                    | oneOf("oO") d=digits(@OCTAL)+ { parseInt(join(d), 8) }
                    | oneOf("bB") d=digits(@BINARY)+ { parseInt(join(d), 2) }
                    | d=digits(@OCTAL)* { parseInt("0" + join(d), 8) }
                    )
              | d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
              ) -> ^(Fixnum n);

    floatLiteral: . f=(i=digits(@DECIMAL)+
                       f=("." digits(@DECIMAL)+ | { ArrayList.new })
                       e=(oneOf("eE") digits(@DECIMAL)+ | { ArrayList.new })
                       ?{List(f).size() + List(e).size() > 0}
                       s={i+["."]+f+["E"]+e}
                       { Double.new(join(s)) }
                      ) -> ^(Float f);
    reswords: "__LINE__"|"__FILE__"|"__ENCODING__"|"BEGIN"|"END"|"alias"
              |"and"|"begin"|"break"|"case"|"class"|"def"|"defined"|"do"
              |"else"|"elsif"|"end"|"ensure"|"false"|"for"|"in"|"module"
              |"next"|"nil"|"not"|"or"|"redo"|"rescue"|"retry"|"return"
              |"self"|"super"|"then"|"true"|"undef"|"when"|"yield"|"if"
              |"unless"|"while"|"until";
}