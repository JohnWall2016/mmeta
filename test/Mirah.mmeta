import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.ArrayList
import java.util.List
import java.util.Collections

parser MirahParser {
    def main(args:String[]) {
        parser = MirahParser.new
        # parser.tracing = true
        reader = BufferedReader.new(InputStreamReader.new(System.in))
        buffer = char[8192]
        builder = StringBuilder.new
        while (read = reader.read(buffer, 0, buffer.length)) > 0
          builder.append(buffer, 0, read);
        end
        puts BaseParser.print_r(parser.parse(builder.toString()))
    }

    def oneOf() {
      chars = String(_pop)
      _char(chars)
    }

    def _codepoint() {
      t = _any
      return -1 if t == __ERROR__
      character = Character(t).charValue
      if character >= 0xd800 && character <= 0xdbff
        t = _any
        if t == __ERROR__
          return -1
        end
        return Character.toCodePoint(character, Character(t).charValue)
      else
        return int(character)
      end
    }

    def codepoint {
      start = _pos
      t = _codepoint
      if t == -1
        self._pos = start
        return Object(__ERROR__)
      else
        return Object(String.new(Character.toChars(t)))
      end
    }

    def identifierChar() {
      start = _pos
      c = _codepoint
      if c == 95 || Character.isLetterOrDigit(c)
        Object(String.new(Character.toChars(c)))
      else
        self._pos = start
        __ERROR__
      end
    }

    def upperCase {
      start = _pos
      c = _codepoint
      if Character.isUpperCase(c)
        Object(String.new(Character.toChars(c)))
      else
        self._pos = start
        __ERROR__
      end
    }

    def initialize {
      @HEX = "0123456789abcdefABCDEF"
      @DECIMAL = "0123456789"
      @OCTAL = "01234567"
      @BINARY = "01"
    }

    def parseInt(string:string, radix:int) {
      Integer.valueOf(Integer.parseInt(string, radix))
    }

    def stringConcat(strings:Object) {
      result = nil
      List(strings).each do |s|
        result = stringConcat(result, s)
      end
      return result
    }

    def stringConcat(a:Object, b:Object) {
      return b if a.nil?
      la = List(a)
      lb = List(b)
      if la.get(0).equals("DString") || lb.get(0).equals("DString")
        result = ArrayList.new
        result.add("DString")
        result.addAll(la.subList(1, la.size()))
        result.addAll(lb.subList(1, lb.size()))
        return List(result)
      else
        ["String", String(la.get(1)) + String(lb.get(1))]
      end
    }

    def getCodePoint(c:Object) {
      String(c).codePointAt(0)
    }

    digits x=_ : a = oneOf(x) b=("_" c=oneOf(x) {c})*
                                 d={[a] + b} { join(d) };
    ws: (oneOf(" \t\f\r\u000b") | "\\\n")*;
    start: ! prog=compstmt . end -> ^(Script prog);
    compstmt: terms* a=(s=statement terms+ {s})*
              b=(s=statement {[s]} | { ArrayList.new })
              {a + b};
    terms: . (";" | "\n") (. ";")*;

    statement: e=primary;

    primary: literal | string | variable;

    literal: numeric | symbol;

    numeric: floatLiteral | fixnum;

    variable: . "nil" -> ^(Nil)
            | . "self" -> ^(Self)
            | . "true" -> ^(True)
            | . "false" -> ^(False)
            | "@@" n=identifierChar+ -> ^(ClassVar join(n))
            | "@" n=identifierChar+ -> ^(InstVar join(n))
            | ~reswords h=upperCase t=identifierChar* -> ^(Constant "#{h}#{join(t)}")
            | ~reswords n=identifierChar+ -> ^(Identifier join(n));

    symbol: . ":"! v=("@@" | "@" | {""}) ! n=identifierChar+ -> ^(Symbol join(concat([v], n)));

    string: character
          | strings=string1+ {stringConcat(strings)};

    string1: . "'"! s=squote_contents* "'" -> ^(String join(s));

    squote_contents: "\\\\" { "\\" } | "\\'" { "'" } | ~"'" _;

    character: . "?" e=escape -> ^(Character getCodePoint(e))
             | . "?" c=codepoint -> ^(Character getCodePoint(c));

    escape: "\\"! ("n" {"\u000a"}
                  |"s" {"\u0020"}
                  |"r" {"\u000d"}
                  |"t" {"\u0009"}
                  |"v" {"\u000b"}
                  |"f" {"\u000c"}
                  |"b" {"\u0008"}
                  |"a" {"\u0007"}
                  |"e" {"\u001b"}
                  |a=oneOf(@OCTAL) b=oneOf(@OCTAL) c=oneOf(@OCTAL)
                    {String.new(Character.toChars(Integer.parseInt("#{a}#{b}#{c}", 8)))}
                  |"x"! a=oneOf(@HEX) b=oneOf(@HEX)
                    {String.new(Character.toChars(Integer.parseInt("#{a}#{b}", 16)))}
                  |"u"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                    {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}", 16)))}
                  |"U"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                        c5=oneOf(@HEX) c6=oneOf(@HEX) c7=oneOf(@HEX) c8=oneOf(@HEX)
                    {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}#{c5}#{c6}#{c7}#{c8}", 16)))}
                  |codepoint
                  );

    fixnum: . n=( "0"! ( oneOf("xX") d=digits(@HEX)+ { parseInt(join(d), 16) }
                    | oneOf("dD") d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
                    | oneOf("oO") d=digits(@OCTAL)+ { parseInt(join(d), 8) }
                    | oneOf("bB") d=digits(@BINARY)+ { parseInt(join(d), 2) }
                    | d=digits(@OCTAL)* { parseInt("0" + join(d), 8) }
                    )
              | d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
              ) -> ^(Fixnum n);

    floatLiteral: . f=(i=digits(@DECIMAL)+
                       f=("." digits(@DECIMAL)+ | { ArrayList.new })
                       e=(oneOf("eE") digits(@DECIMAL)+ | { ArrayList.new })
                       ?{List(f).size() + List(e).size() > 0}
                       s={i+["."]+f+["E"]+e}
                       { Double.new(join(s)) }
                      ) -> ^(Float f);
    reswords: "__LINE__"|"__FILE__"|"__ENCODING__"|"BEGIN"|"END"|"alias"
              |"and"|"begin"|"break"|"case"|"class"|"def"|"defined"|"do"
              |"else"|"elsif"|"end"|"ensure"|"false"|"for"|"in"|"module"
              |"next"|"nil"|"not"|"or"|"redo"|"rescue"|"retry"|"return"
              |"self"|"super"|"then"|"true"|"undef"|"when"|"yield"|"if"
              |"unless"|"while"|"until";
}