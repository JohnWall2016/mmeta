import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.InputStream
import java.io.FileInputStream
import java.util.ArrayList
import java.util.List
import java.util.LinkedList
import java.util.Collections
import jmeta.Ast

public class HeredocContext {
  def initialize(node:Object)
    @node = Ast(node)
    @id = String(@node.get(1))
    @type = '"'
    if @id.startsWith("-")
      @id = @id.substring(1)
      @no_indent = false
    else
      @no_indent = true
    end
    if @id.startsWith("'")
      @type = "'"
      @id = @id.substring(1, @id.length - 1)
    elsif @id.startsWith('"')
      @id = @id.substring(1, @id.length - 1)
    end
  end

  def id
    @id
  end

  def node
    @node
  end

  def no_indent
    @no_indent
  end

  def type
    @type
  end
}

parser MirahParser {
  digits x=_ : a = oneOf(x) b=("_" c=oneOf(x) {c})*
                               d={[a] + b} { join(d) };
  ws: (oneOf(" \t\f\r\v") | "\\" nl)*;
  start: ! prog=compstmt . end heredoc -> ^(Script prog);
  compstmt: terms* a=(s=statement terms+ {s})*
            b=statement?
            {addToBlock(a, b)};
  terms: . (";" | nl) (. ";")*;

  nl: "\n" heredoc;

  statement: e=primary;

  primary: # "begin" bodystmt "end" |
           literal
         | string
         | variable;

  literal: numeric | symbol;

  numeric: floatLiteral | fixnum;

  constant: . ~reswords h=upperCase t=identifierChar* {"#{h}#{join(t)}"};

  variable: . "nil"                                   -> ^(Nil)
          | . "self"                                  -> ^(Self)
          | . "true"                                  -> ^(True)
          | . "false"                                 -> ^(False)
          | . "@@" n=identifierChar+                  -> ^(ClassVar join(n))
          | . "@" n=identifierChar+                   -> ^(InstVar join(n))
          | . t=identifierChar+ p=oneOf("?!") ~"="    -> ^(FCall "#{join(t)}#{p}")
          | c=constant                                -> ^(Constant c)
          | . ~reswords n=identifierChar+             -> ^(Identifier join(n));

  symbol: . ":"! v=("@@" | "@" | {""}) ! n=identifierChar+ -> ^(Symbol join(concat([v], n)));

  string: character
        | strings=string1+ {stringConcat(strings)};

  string1: . "'"! s=squote_contents* "'" -> ^(String join(s))
         | . "\"\"" -> ^(String "")
         | . "\"" s=dquote_contents "\"" {s}
         | . "\"" c=(dquote_contents | str_ev)* "\"" -> ^(DString c+)
         | . "<<" x=heredoc_id n= -> ^(Heredoc x) { @heredocs.addLast(HeredocContext.new(n)); n }
         ;

  str_ev: "\#@@" n=identifierChar+ -> ^(EvString ^(ClassVar join(n)))
        | "\#@"! n=identifierChar+ -> ^(EvString ^(InstVar join(n)))
        | "\#{"! c=compstmt "}" -> ^(EvString c);

  heredoc_id: "-"? ( "\""! identifierChar+ "\""
                   | "'"! identifierChar+ "'"
                   | identifierChar+
                   ) {text(_start, _pos)};

  squote_contents: "\\\\" { "\\" } | "\\'" { "'" } | ~"'" _;
  dquote_contents: c=(escape | ~("\#{" | "\#@" | "\"")_)+ -> ^(String join(c));

  squote_heredoc id=_ : s=(~heredoc_marker(id) _)* heredoc_marker(id) {join(s)};
  dquote_heredoc id=_ : n=( str_ev
                          | s=(~(heredoc_marker(id) | "\#{" | "\#@") _)+
                            -> ^(String join(s))
                          )* heredoc_marker(id) {n};

  heredoc_marker c=_ : ?{"\n".equals(text(_pos - 1, _pos))}
                       ( ?{HeredocContext(c).no_indent}
                       | oneOf(" \t\f\r\v")*
                       ) {_str(HeredocContext(c).id)} "\n";

  character: . "?" e=escape -> ^(Character getCodePoint(e))
           | . "?" c=codepoint -> ^(Character getCodePoint(c));

  escape: "\\"! ("n" {"\n"}
                |"s" {"\s"}
                |"r" {"\r"}
                |"t" {"\t"}
                |"v" {"\v"}
                |"f" {"\f"}
                |"b" {"\b"}
                |"a" {"\a"}
                |"e" {"\e"}
                |a=oneOf(@OCTAL) b=oneOf(@OCTAL) c=oneOf(@OCTAL)
                  {String.new(Character.toChars(Integer.parseInt("#{a}#{b}#{c}", 8)))}
                |"x"! a=oneOf(@HEX) b=oneOf(@HEX)
                  {String.new(Character.toChars(Integer.parseInt("#{a}#{b}", 16)))}
                |"u"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                  {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}", 16)))}
                |"U"! c1=oneOf(@HEX) c2=oneOf(@HEX) c3=oneOf(@HEX) c4=oneOf(@HEX)
                      c5=oneOf(@HEX) c6=oneOf(@HEX) c7=oneOf(@HEX) c8=oneOf(@HEX)
                  {String.new(Character.toChars(Integer.parseInt("#{c1}#{c2}#{c3}#{c4}#{c5}#{c6}#{c7}#{c8}", 16)))}
                |codepoint
                );

  fixnum: . n=( "0"! ( oneOf("xX") d=digits(@HEX)+ { parseInt(join(d), 16) }
                  | oneOf("dD") d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
                  | oneOf("oO") d=digits(@OCTAL)+ { parseInt(join(d), 8) }
                  | oneOf("bB") d=digits(@BINARY)+ { parseInt(join(d), 2) }
                  | d=digits(@OCTAL)* { parseInt("0" + join(d), 8) }
                  )
            | d=digits(@DECIMAL)+ { parseInt(join(d), 10) }
            ) -> ^(Fixnum n);

  floatLiteral: . f=(i=digits(@DECIMAL)+
                     f=("." digits(@DECIMAL)+ | { ArrayList.new })
                     e=(oneOf("eE") digits(@DECIMAL)+ | { ArrayList.new })
                     ?{List(f).size() + List(e).size() > 0}
                     s={i+["."]+f+["E"]+e}
                     { Double.new(join(s)) }
                    ) -> ^(Float f);

  reswords: "__LINE__"|"__FILE__"|"__ENCODING__"|"BEGIN"|"END"|"alias"
            |"and"|"begin"|"break"|"case"|"class"|"def"|"defined"|"do"
            |"else"|"elsif"|"end"|"ensure"|"false"|"for"|"in"|"module"
            |"next"|"nil"|"not"|"or"|"redo"|"rescue"|"retry"|"return"
            |"self"|"super"|"then"|"true"|"undef"|"when"|"yield"|"if"
            |"unless"|"while"|"until";

  def self.main(args:String[]) {
      returns void
      parser = MirahParser.new
      # parser.tracing = true
      if args.length > 0
        stream = InputStream(FileInputStream.new(args[0]))
      else
        stream = System.in
      end
      reader = BufferedReader.new(InputStreamReader.new(stream))
      buffer = char[8192]
      builder = StringBuilder.new
      while (read = reader.read(buffer, 0, buffer.length)) > 0
        builder.append(buffer, 0, read);
      end
      puts BaseParser.print_r(parser.parse(builder.toString()))
  }

  def initialize {
    @HEX = "0123456789abcdefABCDEF"
    @DECIMAL = "0123456789"
    @OCTAL = "01234567"
    @BINARY = "01"
    @heredocs = LinkedList.new
  }

  def oneOf() {
    chars = String(_pop)
    _char(chars)
  }

  def _codepoint() {
    t = _any
    return -1 if t == __ERROR__
    character = Character(t).charValue
    if character >= 0xd800 && character <= 0xdbff
      t = _any
      if t == __ERROR__
        return -1
      end
      return Character.toCodePoint(character, Character(t).charValue)
    else
      return int(character)
    end
  }

  def codepoint {
    start = _pos
    t = _codepoint
    if t == -1
      self._pos = start
      return Object(__ERROR__)
    else
      return Object(String.new(Character.toChars(t)))
    end
  }

  def identifierChar() {
    start = _pos
    c = _codepoint
    if c == 95 || Character.isLetterOrDigit(c)
      Object(String.new(Character.toChars(c)))
    else
      self._pos = start
      __ERROR__
    end
  }

  def upperCase {
    start = _pos
    c = _codepoint
    if Character.isUpperCase(c)
      Object(String.new(Character.toChars(c)))
    else
      self._pos = start
      __ERROR__
    end
  }

  def heredoc {
    # Note: This won't parse if we backtrack over the newline and not
    # the heredoc identifier. However the nl rule should be memoized
    # so we should be safe.

    # Set up a new list so nested heredocs match properly.
    heredocs = @heredocs
    @heredocs = LinkedList.new

    while heredocs.size > 0
      context = HeredocContext(heredocs.removeFirst)
      _push(context)
      node = context.node
      node.children.clear
      _t = if context.type == '"'
        dquote_heredoc
      else
        squote_heredoc
      end
      if _t == __ERROR__
        raise SyntaxError.new("Missing heredoc terminator #{context.id}.", _pos, _string, _list)
      elsif _t.kind_of?(String)
        node.name = 'String'
        node.add(_t)
      else
        l = List(_t)
        if l.size == 1 && Ast(l.get(0)).name.equals('String')
          node.name = 'String'
          node.addAll(Ast(l.get(0)).children)
        else
          node.name = 'DString'
          node.addAll(l)
        end
      end
    end
    "\n"
  }

  def parseInt(string:string, radix:int) {
    Integer.valueOf(Integer.parseInt(string, radix))
  }

  def stringConcat(strings:Object) {
    result = nil
    List(strings).each do |s|
      result = stringConcat(result, s)
    end
    return result
  }

  def stringConcat(a:Object, b:Object) {
    la = Ast(a)
    lb = Ast(b)
    return la if lb.nil?
    return lb if la.nil?
    result = Ast.new("DString")
    [la, lb].each do |n|
      node = Ast(n)
      if node.name.equals("DString")
        result.addAll(node.children)
      else
        result.add(node)
      end
    end
    result.start_position = la.start_position
    result.end_position = lb.end_position
    result
  }

  def getCodePoint(c:Object) {
    String(c).codePointAt(0)
  }

  def obj2ast(x:Object) {
    if x.kind_of?(Ast)
      Ast(x)
    elsif x.kind_of?(List)
      l = List(x)
      if l.size == 0
        Ast(nil)
      elsif l.size == 1
        obj2ast(l.get(0))
      else
        ast = Ast.new('Body', l)
        first = obj2ast(l.get(0))
        last = obj2ast(l.get(l.size - 1))
        ast.start_position = first.start_position
        ast.end_position = last.end_position
        ast
      end
    elsif x.nil?
      Ast(nil)
    else
      raise "Expected Ast, got #{x} (#{x.getClass})"
    end
  }

  def addToBlock(a:Object, b:Object) {
    x = obj2ast(a)
    y = obj2ast(b)
    if x.nil?
      return y
    elsif y.nil?
      return x
    end
    x_kids = 'Body'.equals(x.name) ? x.children : [x]
    y_kids = 'Body'.equals(y.name) ? y.children : [y]
    body = Ast.new('Body', x_kids)
    body.addAll(y_kids)
    body.start_position = x.start_position
    body.end_position = y.end_position
    body
  }
}