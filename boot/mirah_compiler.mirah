# generated by mmeta on Fri Apr 22 09:23:42 PDT 2011
# do not modify, instead edit original .mmeta file
import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import mmeta.*;


import java.util.*
import org.stringtemplate.v4.*

 class DoError
  def initialize(m:Object)
    @msg = String(m)
  end

  def message
    @msg
  end
 end

class MMetaCompiler < BaseParser
  def _init

    @chars = _chars
    super()

  end

  def self.main(args:String[])

          returns void
          if args.length < 1
              puts "MMetaCompiler <input> [output]"
              System.exit(2)
          end
          # if args.length > 1 && args[1].equals("--embed")
          #     embed = true
          # end
          options = {recursion: Boolean.valueOf(false), auto_memo: Boolean.valueOf(false)}
          i = 0
          while i < args.length && args[i].startsWith('--')
            arg = args[i].substring(2)
            if options.containsKey(arg)
              options.put(arg, Boolean.valueOf(true))
            else
              puts "Unrecognized option --#{arg}."
              puts "Supported options: #{options.keySet}"
              System.exit(1)
            end
            i += 1
          end
          if args.length > i
            output_file = args[i + 1]
          else
            output_file = args[i] + ".mirah"
          end
          input = Utils.readFile(args[i])

          compiler = MMetaCompiler.new
          compiler.left_recursion = Boolean(options.get(:recursion)).booleanValue
          compiler.auto_memo = Boolean(options.get(:auto_memo)).booleanValue
          # compiler.embedded = embed
          parser = MMetaParser.new
          BaseParser.tracing = false
          ast = parser.parse(input)
          BaseParser.tracing = false
          # puts BaseParser.print_r(ast)

          output = String(compiler.parse(ast))
          Utils.writeFile(output_file, output)
          System.exit(0)
        
  end


  def initialize()

          @jpackage = String(nil)
          @embedded = false
          @locals = ArrayList.new
          @methods = ArrayList.new
          @rules = ArrayList.new
          @ranges = HashMap.new
          @sname = "ERROR-sname-ERROR"
          @name = "ERROR-name-ERROR"
          @_ = "  "
          @__genc = -1
          @left_recursion = Boolean.getBoolean("mmeta.left_recursion")
          @auto_memo = Boolean.getBoolean("mmeta.auto_memo")
          @templates = STGroupFile.new(MMetaCompiler.class.getResource("mmeta_compiler.stg"), "utf-8", '<'.charAt(0), '>'.charAt(0))
        
  end


  def left_recursion_set(value:boolean)

          @left_recursion = value
        
  end


  def auto_memo_set(value:boolean)

          @auto_memo = value
        
  end


  def render(name:String, args:Map)

          st = @templates.getInstanceOf(name)
          args.keySet().each do |k|
            st.add(String(k), args.get(k))
          end
          st.render
        
  end


  def reset()

            @locals = ArrayList.new
            @methods = ArrayList.new
            @rules = ArrayList.new
        
  end


  def addLocal(n:Object)

            s = String(n).intern
            @locals.add(s) unless @locals.contains(s)
        
  end


  def localsAsArgs()

          localsAsCall
        
  end


  def localsAsCall()

            join(@locals, ",")
        
  end


  def localsAsInit()

          return '' if @locals.size == 0
          res = join(@locals, " = ") + " = Object(nil)\n"
          @locals.clear
          res
        
  end


  def embedded_set(embedded:boolean)
    @embeded = embedded
  end


  def genvar()
     "" + (@__genc = @__genc + 1); 
  end


  def destruct:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('destruct')
    t = r = Object(nil)

    begin  # and
      _p0 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        t = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _push(t); _t=self.apply();
        r = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=r;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p0 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "destruct" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def trans:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('trans')
    r = Object(nil)

    begin  # and
      _p1 = _pos; _t=nil
      begin  # and (inner)
        _t = _listBegin()
        if (_t != BaseParser.__ERROR__)
          _t=self.destruct();
          r = _t

          _listEnd()
        end

        break if _t == BaseParser.__ERROR__

        _t=r;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p1 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "trans" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HList:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HList')
    ls = Object(nil)

    begin  # and
      _p3 = _pos; _t=nil
      begin  # and (inner)
        as2 = ArrayList.new
        while true  # star
          _t=self.trans();
          break if (_t == BaseParser.__ERROR__)
          as2.add(_t)
        end
        _t = as2


        ls = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                if List(ls).size == 0
                  "ArrayList.new"
                else
                  "[#{join(ls, ", ")}]"
                end
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p3 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HList" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HConcat:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HConcat')
    l = r = Object(nil)

    begin  # and
      _p4 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        l = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        r = _t

        break if _t == BaseParser.__ERROR__

        _t="concat(#{l}, #{r})";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p4 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HConcat" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HStr:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HStr')
    c = Object(nil)

    begin  # and
      _p5 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="\"#{c}\"";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p5 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HStr" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HLit:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HLit')
    c = Object(nil)

    begin  # and
      _p6 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t=c;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p6 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HLit" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Node:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Node')
    n = c = Object(nil)

    begin  # and
      _p7 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="build_node('#{n}', #{c}, _real_start > 1 ? _real_start : _start, _pos)";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p7 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Node" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Error:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Error')
    msg = Object(nil)

    begin  # and
      _p8 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        msg = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  DoError.new(msg);
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p8 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Error" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Set:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Set')
    n = x = Object(nil)

    begin  # and
      _p9 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  addLocal(n);
                  render('save_to_var', name: n, expr: x)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p9 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Set" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Str:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Str')
    s = Object(nil)

    begin  # and
      _p10 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           compile_literal_string(s) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p10 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Str" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Sym:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Sym')
    s = Object(nil)

    begin  # and
      _p11 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t="_t=_sym(\"#{s}\");";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p11 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Sym" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def App:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('App')
    rule = args = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p13 = _pos; _t=nil
        begin  # and (inner)
          _t=_sym("super");
          break if _t == BaseParser.__ERROR__

          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          as12 = ArrayList.new
          _t=self.trans();
          if (_t!=BaseParser.__ERROR__)  # plus
            as12.add(_t)
            while true  # star
              _t=self.trans();
              break if (_t == BaseParser.__ERROR__)
              as12.add(_t)
            end
            _t = as12

          end

          args = _t

          break if _t == BaseParser.__ERROR__

          _t = begin

                    arg_str = if List(args).size == 1
                      join(args, ", ")
                    else
                      "[#{join(args, ", ")}].toArray"
                    end
                    "_push(#{arg_str}); _t=super();"
                
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p13 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p14 = _pos; _t=nil
        begin  # and (inner)
          _t=_sym("super");
          break if _t == BaseParser.__ERROR__

          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          _t="_t=super();";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p14 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p16 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          as15 = ArrayList.new
          _t=self.trans();
          if (_t!=BaseParser.__ERROR__)  # plus
            as15.add(_t)
            while true  # star
              _t=self.trans();
              break if (_t == BaseParser.__ERROR__)
              as15.add(_t)
            end
            _t = as15

          end

          args = _t

          break if _t == BaseParser.__ERROR__

          _t = begin

                    arg_str = if List(args).size == 1
                      join(args, ", ")
                    else
                      "[#{join(args, ", ")}].toArray"
                    end
                    "_push(#{arg_str}); _t=self.#{rule}();"
                
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p16 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p17 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          _t="_t=self.#{rule}();";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p17 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "App" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Dot:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Dot')
    _t="if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;";
    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Dot" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def SAct:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('SAct')
    expr = Object(nil)

    begin  # and
      _p18 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        expr = _t

        break if _t == BaseParser.__ERROR__

        _t="_t=#{expr};";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p18 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "SAct" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Act:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Act')
    expr = Object(nil)

    begin  # and
      _p19 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        expr = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  render('action', expr: expr)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p19 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Act" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Pred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Pred')
    expr = Object(nil)

    begin  # and
      _p20 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        expr = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  render('predicate', expr: expr)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p20 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Pred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def SynPred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('SynPred')
    pred = t = e = Object(nil)

    begin  # and
      _p21 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        pred = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.trans();
        t = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.trans();
        e = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = begin

                render('syn_pred', pred: pred, t:t, e:e)
              
        end

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p21 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "SynPred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Token:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Token')
    name = Object(nil)

    begin  # and
      _p22 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        name = _t

        break if _t == BaseParser.__ERROR__

        _t="_t = _lex(Tokens.t#{name})\n";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p22 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Token" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def TokenRange:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('TokenRange')
    first = last = Object(nil)

    begin  # and
      _p23 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        first = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        last = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                range = lookup_range(first, last)
                render('token_range', first: first, last: last, range: range)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p23 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "TokenRange" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def TLit:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('TLit')
    name = Object(nil)

    begin  # and
      _p24 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        name = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                token = Integer.valueOf(lookup_token(name))
                render('token_literal', name: name, token: token)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p24 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "TLit" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Or:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Or')
    xs = Object(nil)

    begin  # and
      _p26 = _pos; _t=nil
      begin  # and (inner)
        as25 = ArrayList.new
        while true  # star
          _t=self.trans();
          break if (_t == BaseParser.__ERROR__)
          as25.add(_t)
        end
        _t = as25


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                render('or', exprs: xs)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p26 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Or" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def And:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('And')
    ts = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p28 = _pos; _t=nil
        begin  # and (inner)
          as27 = ArrayList.new
          _t=self.trans();
          if (_t!=BaseParser.__ERROR__)  # plus
            as27.add(_t)
            while true  # star
              _t=self.trans();
              break if (_t == BaseParser.__ERROR__)
              as27.add(_t)
            end
            _t = as27

          end

          ts = _t

          break if _t == BaseParser.__ERROR__

          _t = begin

                    var = genvar
                    err = null
                    xs = List(ts)
                    nodes = ArrayList.new(xs.size)
                    errors = ArrayList.new(xs.size)
                    xs.each do |x|
                      if x.kind_of?(DoError)
                        err = DoError(x).message
                        next
                      end
                      nodes.add(x)
                      errors.add(err)
                    end
                    render('and', var: var, exprs: nodes, errors: errors)
                
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p28 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t="";
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "And" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def makeMany(x:Object, many1:boolean)

            var = genvar
            if many1
              render('build_list_no_empty', x: x, var: var)
            else
              render('build_list', x: x, var: var)
            end
        
  end


  def Many:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many')
    x = Object(nil)

    begin  # and
      _p29 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           makeMany(x, false) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p29 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Many" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Many1:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many1')
    x = Object(nil)

    begin  # and
      _p30 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           makeMany(x, true)  
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p30 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Many1" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Opt:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Opt')
    x = Object(nil)

    begin  # and
      _p31 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           render('opt', x: x) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p31 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Opt" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Not:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Not')
    x = Object(nil)

    begin  # and
      _p32 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           render('not', x: x)
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p32 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Not" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Peek:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Peek')
    x = Object(nil)

    begin  # and
      _p33 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                var = genvar
                render('peek', x: x, var: var)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p33 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Peek" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def List:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('List')
    x = Object(nil)

    begin  # and
      _p34 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  render('list', x: x)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p34 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "List" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def MemoRule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('MemoRule')
    n = b = Object(nil)

    begin  # and
      _p35 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        b = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                rule_body(n, b, true)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p35 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "MemoRule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Rule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Rule')
    n = b = Object(nil)

    begin  # and
      _p36 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        b = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                rule_body(n, b, false)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p36 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Rule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Scope:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Scope')
    names = body = Object(nil)

    begin  # and
      _p37 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        names = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        body = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                simple_names = ArrayList.new
                l = if names.kind_of?(List)
                  List(names)
                else
                  Arrays.asList(Object[].cast(names))
                end
                l.each do |_name|
                  name = String(_name)
                  simple_names.add(name.replace('@', ''))
                end
                render('scope', names: names, simple_names: simple_names, body: body)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p37 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Scope" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Parser:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Parser')
    p = n = s = xs = Object(nil)

    begin  # and
      _p39 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        p = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           @name = String(n); @sname = String(s); nil 
        end

        break if _t == BaseParser.__ERROR__

        as38 = ArrayList.new
        while true  # star
          _t=self.trans();
          break if (_t == BaseParser.__ERROR__)
          as38.add(_t)
        end
        _t = as38


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                init = build_init
                b = render('parser', name: @name, superclass: @sname, init: init, xs:xs, methods:@methods, rules:@rules)
                reset
                b
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p39 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Parser" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Method:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Method')
    name = args = body = c = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p40 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          name = _t

          break if _t == BaseParser.__ERROR__

          _t=self._any();
          args = _t

          break if _t == BaseParser.__ERROR__

          _t=self._any();
          body = _t

          break if _t == BaseParser.__ERROR__

          _t = begin
             render('method', name:name, args:args, body:body) 
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p40 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p41 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          c = _t

          break if _t == BaseParser.__ERROR__

          _t="  #{c}\n";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p41 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Method" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Field:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Field')
    c = Object(nil)

    begin  # and
      _p42 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="  #{c}\n";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p42 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Field" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Package:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Package')
    c = Object(nil)

    begin  # and
      _p43 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           @jpackage = String(c); ""; 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p43 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Package" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Import:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Import')
    c = Object(nil)

    begin  # and
      _p44 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t=c;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p44 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Import" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Class:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Class')
    q = d = c = Object(nil)

    begin  # and
      _p45 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        q = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        d = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="#{d}\n#{c}\n end";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p45 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Class" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Line:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Line')
    ws = x = Object(nil)

    begin  # and
      _p46 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        ws = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           ws.toString + x.toString 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p46 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Line" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def File:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('File')
    xs = Object(nil)

    begin  # and
      _p48 = _pos; _t=nil
      begin  # and (inner)
        as47 = ArrayList.new
        while true  # star
          _t=self.trans();
          break if (_t == BaseParser.__ERROR__)
          as47.add(_t)
        end
        _t = as47


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  "# generated by mmeta on #{Date.new}\n" +
                  "# do not modify, instead edit original .mmeta file\n" +
                  "import java.util.ArrayList\n" +
                  "import java.util.Date\n" +
                  "import java.util.List\n" +
                  "import java.util.EnumSet\n" +
                  (@embedded ? "" : "import mmeta.*;\n") + join(xs)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p48 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "File" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def start:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('start')
    r = Object(nil)

    begin  # and
      _p49 = _pos; _t=nil
      begin  # and (inner)
        _t=self.destruct();
        r = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=r;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p49 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "start" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def unescape(s:String)

          sb = StringBuilder.new
          i = 0
          while i < s.length
            if s.charAt(i) == 92 # ?\\
              i += 1
              c = s.substring(i, i + 1)
              if c.equals("n")
                sb.append("\n")
              elsif c == "s"
                sb.append("\s")
              elsif c == "r"
                sb.append("\r")
              elsif c == "t"
                sb.append("\t")
              elsif c == "v"
                sb.append("\v")
              elsif c == "f"
                sb.append("\f")
              elsif c == "b"
                sb.append("\b")
              elsif c == "a"
                sb.append("\a")
              elsif c == "e"
                sb.append("\e")
              else
                sb.append(c)
              end
            else
              sb.append(s.charAt(i))
            end
            i += 1
          end
          str = sb.toString
          ints = int[str.length]
          ints.length.times do |i|
            ints[i] = str.charAt(i)
          end
          ints
        
  end


  def compile_literal_string(_s:Object)

          s = unescape(String(_s))
          if s.length == 0
            "_t = ''\n"
          else
            var = "_p#{genvar}"
            render('literal_string', string:_s, chars: s, var: var)
          end
        
  end


  def lookup_token(name:Object)

          @tokens ||= ArrayList.new
          index = @tokens.indexOf(name)
          if index == -1
            index = @tokens.size
            @tokens.add(name)
          end
          return index
        
  end


  def lookup_range(first:Object, last:Object)

          key = "#{first},#{last}"
          val = String(@ranges.get(key))
          if val.nil?
            val = "@_trange#{@ranges.size}"
            @ranges.put(key, val)
          end
          val
        
  end


  def build_init()

          code = StringBuilder.new("\n@chars = _chars\nsuper()\n")
          @ranges.keySet.each do |key|
            tokens = String(key).split(",")
            first = tokens[0]
            last = tokens[1]
            name = @ranges.get(key)
            code.append("#{name} = EnumSet.range(Tokens.t#{first}, Tokens.t#{last})\n")
          end
          code.toString
        
  end


  def rule_body(n:Object, b:Object, force_memo:boolean)

          @rules.add(n)
          locals = localsAsInit
          render('rule_body', n:n, name:@name, memo: Boolean.valueOf(force_memo || @auto_memo),
                 b:b, recursion:Boolean.valueOf(@left_recursion), locals:locals)

        
  end



  def _jump(r:String)
    return destruct() if (r == "destruct")
    return trans() if (r == "trans")
    return HList() if (r == "HList")
    return HConcat() if (r == "HConcat")
    return HStr() if (r == "HStr")
    return HLit() if (r == "HLit")
    return Node() if (r == "Node")
    return Error() if (r == "Error")
    return Set() if (r == "Set")
    return Str() if (r == "Str")
    return Sym() if (r == "Sym")
    return App() if (r == "App")
    return Dot() if (r == "Dot")
    return SAct() if (r == "SAct")
    return Act() if (r == "Act")
    return Pred() if (r == "Pred")
    return SynPred() if (r == "SynPred")
    return Token() if (r == "Token")
    return TokenRange() if (r == "TokenRange")
    return TLit() if (r == "TLit")
    return Or() if (r == "Or")
    return And() if (r == "And")
    return Many() if (r == "Many")
    return Many1() if (r == "Many1")
    return Opt() if (r == "Opt")
    return Not() if (r == "Not")
    return Peek() if (r == "Peek")
    return List() if (r == "List")
    return MemoRule() if (r == "MemoRule")
    return Rule() if (r == "Rule")
    return Scope() if (r == "Scope")
    return Parser() if (r == "Parser")
    return Method() if (r == "Method")
    return Field() if (r == "Field")
    return Package() if (r == "Package")
    return Import() if (r == "Import")
    return Class() if (r == "Class")
    return Line() if (r == "Line")
    return File() if (r == "File")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "destruct")
    return true if (r == "trans")
    return true if (r == "HList")
    return true if (r == "HConcat")
    return true if (r == "HStr")
    return true if (r == "HLit")
    return true if (r == "Node")
    return true if (r == "Error")
    return true if (r == "Set")
    return true if (r == "Str")
    return true if (r == "Sym")
    return true if (r == "App")
    return true if (r == "Dot")
    return true if (r == "SAct")
    return true if (r == "Act")
    return true if (r == "Pred")
    return true if (r == "SynPred")
    return true if (r == "Token")
    return true if (r == "TokenRange")
    return true if (r == "TLit")
    return true if (r == "Or")
    return true if (r == "And")
    return true if (r == "Many")
    return true if (r == "Many1")
    return true if (r == "Opt")
    return true if (r == "Not")
    return true if (r == "Peek")
    return true if (r == "List")
    return true if (r == "MemoRule")
    return true if (r == "Rule")
    return true if (r == "Scope")
    return true if (r == "Parser")
    return true if (r == "Method")
    return true if (r == "Field")
    return true if (r == "Package")
    return true if (r == "Import")
    return true if (r == "Class")
    return true if (r == "Line")
    return true if (r == "File")
    return true if (r == "start")
    super(r)
  end
end
