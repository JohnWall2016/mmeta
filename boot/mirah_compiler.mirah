# generated by mmeta on Tue Apr 05 22:37:05 PDT 2011
# do not modify, instead edit original .mmeta file
import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import jmeta.*;


import java.util.*;
import org.stringtemplate.v4.*;

class MMetaCompiler < BaseParser
  def _init

    @chars = _chars
    super()

  end

    def self.main(args:String[]);
        returns void
        if args.length < 1
            puts "JMetaParser <input> [output]"
            System.exit(2)
        end
        # if args.length > 1 && args[1].equals("--embed")
        #     embed = true
        # end
        if args.length > 1
          output_file = args[1]
        else
          output_file = args[0] + ".mirah"
        end
        input = Utils.readFile(args[0])
        compiler = MMetaCompiler.new
        # compiler.embedded = embed
        parser = JMetaParser.new
        BaseParser.tracing = false
        ast = parser.parse(input)
        BaseParser.tracing = false
        # puts BaseParser.print_r(ast)

        output = String(compiler.parse(ast))
        Utils.writeFile(output_file, output)
        System.exit(0)
      ;end

    def initialize();
        @jpackage = String(nil)
        @embedded = false
        @locals = ArrayList.new
        @methods = ArrayList.new
        @rules = ArrayList.new
        @ranges = HashMap.new
        @sname = "ERROR-sname-ERROR"
        @name = "ERROR-name-ERROR"
        @_ = "  "
        @__genc = -1
        @left_recursion = Boolean.getBoolean("mmeta.left_recursion")
        @auto_memo = Boolean.getBoolean("mmeta.auto_memo")
        @templates = STGroupFile.new(MMetaCompiler.class.getResource("mmeta_compiler.stg"), "utf-8", '<'.charAt(0), '>'.charAt(0))
      ;end

    def render(name:String, args:Map);
        st = @templates.getInstanceOf(name)
        args.keySet().each do |k|
          st.add(String(k), args.get(k))
        end
        st.render
      ;end

    def reset();
          @locals = ArrayList.new
          @methods = ArrayList.new
          @rules = ArrayList.new
      ;end

    def addLocal(n:Object);
          s = String(n).intern
          @locals.add(s) unless @locals.contains(s)
      ;end

    def localsAsArgs();
        localsAsCall
      ;end

    def localsAsCall();
          join(@locals, ",")
      ;end

    def localsAsInit();
        return '' if @locals.size == 0
        res = join(@locals, " = ") + " = Object(nil)\n"
        @locals.clear
        res
      ;end

    def embedded_set(embedded:boolean);@embeded = embedded;end

    def indent(); @_ = @_ + "  " ;end

    def outdent(); @_ = @_.substring(2) ;end

    def genvar(); "" + (@__genc = @__genc + 1); ;end

  def destruct:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('destruct')
    t = r = Object(nil)

    begin  # and
      _p0 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
            t=_t;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _push(t); _t=self.apply();
            r=_t;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=r;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p0 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "destruct" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def trans:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('trans')
    r = Object(nil)

    begin  # and
      _p1 = _pos; _t=nil
      begin  # and (inner)
        _t=_listBegin(); if (_t!=BaseParser.__ERROR__)
                _t=self.destruct();
                r=_t;
              _listEnd(); end;
        break if _t == BaseParser.__ERROR__

        _t=r;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p1 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "trans" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HList:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HList')
    ls = Object(nil)

    begin  # and
      _p3 = _pos; _t=nil
      begin  # and (inner)
        as2 = ArrayList.new
                while true  # many
                _t=self.trans();
                if (_t==BaseParser.__ERROR__); break; else as2.add(_t);nil;end
                end; _t=as2

                ls=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              if List(ls).size == 0
                "ArrayList.new"
              else
                "[#{join(ls, ", ")}]"
              end
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p3 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HList" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HConcat:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HConcat')
    l = r = Object(nil)

    begin  # and
      _p4 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
                  l=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                  r=_t;
        break if _t == BaseParser.__ERROR__

        _t="concat(#{l}, #{r})";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p4 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HConcat" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HStr:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HStr')
    c = Object(nil)

    begin  # and
      _p5 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                    c=_t;
        break if _t == BaseParser.__ERROR__

        _t="\"#{c}\"";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p5 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HStr" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HLit:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HLit')
    c = Object(nil)

    begin  # and
      _p6 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                      c=_t;
        break if _t == BaseParser.__ERROR__

        _t=c;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p6 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HLit" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Node:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Node')
    n = c = Object(nil)

    begin  # and
      _p7 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                        n=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                        c=_t;
        break if _t == BaseParser.__ERROR__

        _t="build_node('#{n}', #{c}, _real_start > 1 ? _real_start : _start, _pos)";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p7 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Node" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Error:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Error')
    msg = Object(nil)

    begin  # and
      _p8 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                          msg=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
                DoError.new(msg);
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p8 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Error" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Set:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Set')
    n = x = Object(nil)

    begin  # and
      _p9 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                            n=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                            x=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
                addLocal(n);
                "#{x}\n#{@_}#{n}=_t;"
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p9 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Set" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Str:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Str')
    s = Object(nil)

    begin  # and
      _p10 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                              s=_t;
        break if _t == BaseParser.__ERROR__

        _t=( compile_literal_string(s) );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p10 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Str" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Sym:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Sym')
    s = Object(nil)

    begin  # and
      _p11 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                s=_t;
        break if _t == BaseParser.__ERROR__

        _t="_t=_sym(\"#{s}\");";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p11 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Sym" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def App:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('App')
    rule = args = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p13 = _pos; _t=nil
        begin  # and (inner)
          _t=_sym("super");
          break if _t == BaseParser.__ERROR__

          _t=self._any();
                                    rule=_t;
          break if _t == BaseParser.__ERROR__

          as12 = ArrayList.new
                                    _t=self.trans();
                                    if (_t!=BaseParser.__ERROR__)
                                      as12.add(_t)
                                      while true  # many
                                      _t=self.trans();
                                      if (_t==BaseParser.__ERROR__); break; else as12.add(_t);nil;end
                                      end; _t=as12

                                    end

                                    args=_t;
          break if _t == BaseParser.__ERROR__

          _t=(
                  arg_str = if List(args).size == 1
                    join(args, ", ")
                  else
                    "ArrayList.new([#{join(args, ", ")}]).toArray"
                  end
                  "_push(#{arg_str}); _t=super();"
              );
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p13 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p14 = _pos; _t=nil
        begin  # and (inner)
          _t=_sym("super");
          break if _t == BaseParser.__ERROR__

          _t=self._any();
                                      rule=_t;
          break if _t == BaseParser.__ERROR__

          _t="_t=super();";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p14 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p16 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
                                        rule=_t;
          break if _t == BaseParser.__ERROR__

          as15 = ArrayList.new
                                        _t=self.trans();
                                        if (_t!=BaseParser.__ERROR__)
                                          as15.add(_t)
                                          while true  # many
                                          _t=self.trans();
                                          if (_t==BaseParser.__ERROR__); break; else as15.add(_t);nil;end
                                          end; _t=as15

                                        end

                                        args=_t;
          break if _t == BaseParser.__ERROR__

          _t=(
                  arg_str = if List(args).size == 1
                    join(args, ", ")
                  else
                    "ArrayList.new([#{join(args, ", ")}]).toArray"
                  end
                  "_push(#{arg_str}); _t=self.#{rule}();"
              );
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p16 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p17 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
                                          rule=_t;
          break if _t == BaseParser.__ERROR__

          _t="_t=self.#{rule}();";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p17 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "App" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Dot:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Dot')
    _t="if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;";
    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Dot" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def SAct:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('SAct')
    expr = Object(nil)

    begin  # and
      _p18 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
                                          expr=_t;
        break if _t == BaseParser.__ERROR__

        _t="_t=#{expr};";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p18 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "SAct" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Act:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Act')
    expr = Object(nil)

    begin  # and
      _p19 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                            expr=_t;
        break if _t == BaseParser.__ERROR__

        _t="_t=(#{expr});";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p19 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Act" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Pred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Pred')
    expr = Object(nil)

    begin  # and
      _p20 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                              expr=_t;
        break if _t == BaseParser.__ERROR__

        _t="_t = (#{expr}) ? nil : BaseParser.__ERROR__;";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p20 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Pred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def SynPred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('SynPred')
    pred = t = e = Object(nil)

    begin  # and
      _p21 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
                                                pred=_t;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                t=_t;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                e=_t;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=(
              render('syn_pred', pred: pred, t:t, e:e)
            );
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p21 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "SynPred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Token:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Token')
    name = Object(nil)

    begin  # and
      _p22 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                  name=_t;
        break if _t == BaseParser.__ERROR__

        _t="_t = _lex(Tokens.t#{name})\n";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p22 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Token" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def TokenRange:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('TokenRange')
    first = last = Object(nil)

    begin  # and
      _p23 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                    first=_t;
        break if _t == BaseParser.__ERROR__

        _t=self._any();
                                                    last=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              range = lookup_range(first, last)
              render('token_range', first: first, last: last, range: range)
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p23 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "TokenRange" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def TLit:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('TLit')
    name = Object(nil)

    begin  # and
      _p24 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                      name=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              token = Integer.valueOf(lookup_token(name))
              render('token_literal', name: name, token: token)
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p24 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "TLit" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Or:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Or')
    xs = Object(nil)

    begin  # and
      _p26 = _pos; _t=nil
      begin  # and (inner)
        as25 = ArrayList.new
                                                        while true  # many
                                                        _t=self.trans();
                                                        if (_t==BaseParser.__ERROR__); break; else as25.add(_t);nil;end
                                                        end; _t=as25

                                                        xs=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              render('or', exprs: xs)
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p26 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Or" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def And:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('And')
    ts = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p28 = _pos; _t=nil
        begin  # and (inner)
          _t=self.indent();
          break if _t == BaseParser.__ERROR__

          as27 = ArrayList.new
                                                            _t=self.trans();
                                                            if (_t!=BaseParser.__ERROR__)
                                                              as27.add(_t)
                                                              while true  # many
                                                              _t=self.trans();
                                                              if (_t==BaseParser.__ERROR__); break; else as27.add(_t);nil;end
                                                              end; _t=as27

                                                            end

                                                            ts=_t;
          break if _t == BaseParser.__ERROR__

          _t=(
                  var = genvar
                  err = null
                  xs = List(ts)
                  nodes = ArrayList.new(xs.size)
                  errors = ArrayList.new(xs.size)
                  xs.each do |x|
                    if x.kind_of?(DoError)
                      err = DoError(x).message
                      next
                    end
                    nodes.add(x)
                    errors.add(err)
                  end
                  render('and', var: var, exprs: nodes, errors: errors)
              );
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p28 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t="";
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "And" if (_t==BaseParser.__ERROR__)
    return _t
  end

    def makeMany(x:Object, many1:boolean);
          var = genvar
          if many1
            render('build_list_no_empty', x: x, var: var)
          else
            render('build_list', x: x, var: var)
          end
      ;end

  def Many:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many')
    x = Object(nil)

    begin  # and
      _p29 = _pos; _t=nil
      begin  # and (inner)
        _t=self.indent();
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                            x=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.outdent();
        break if _t == BaseParser.__ERROR__

        _t=( makeMany(x, false) );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p29 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Many" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Many1:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many1')
    x = Object(nil)

    begin  # and
      _p30 = _pos; _t=nil
      begin  # and (inner)
        _t=self.indent();
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                              x=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.outdent();
        break if _t == BaseParser.__ERROR__

        _t=( makeMany(x, true)  );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p30 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Many1" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Opt:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Opt')
    x = Object(nil)

    begin  # and
      _p31 = _pos; _t=nil
      begin  # and (inner)
        _t=self.indent();
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                                x=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.outdent();
        break if _t == BaseParser.__ERROR__

        _t="#{x}\n#{@_}_t=(_string.nil? ? \"\" : nil) if _t == BaseParser.__ERROR__;";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p31 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Opt" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Not:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Not')
    x = Object(nil)

    begin  # and
      _p32 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
                                                                  x=_t;
        break if _t == BaseParser.__ERROR__

        _t="#{@_}#{x}\n_t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__);";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p32 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Not" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Peek:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Peek')
    x = Object(nil)

    begin  # and
      _p33 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
                                                                    x=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              var = genvar
              
              "begin\n#{indent}_l#{var}=_pos\n#{@_}#{x}\n#{@_}self._pos=_l#{var} if (_t!=BaseParser.__ERROR__)\n#{outdent}end\n"
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p33 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Peek" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def List:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('List')
    x = Object(nil)

    begin  # and
      _p34 = _pos; _t=nil
      begin  # and (inner)
        _t=self.indent();
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                                      x=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.outdent();
        break if _t == BaseParser.__ERROR__

        _t="_t=_listBegin(); if (_t!=BaseParser.__ERROR__)\n#{@_}  #{x}\n#{@_}_listEnd(); end;";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p34 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "List" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def MemoRule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('MemoRule')
    n = b = Object(nil)

    begin  # and
      _p35 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                        n=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                                        b=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              rule_body(n, b, true)
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p35 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "MemoRule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Rule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Rule')
    n = b = Object(nil)

    begin  # and
      _p36 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                          n=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                                          b=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              rule_body(n, b, false)
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p36 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Rule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Scope:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Scope')
    names = body = Object(nil)

    begin  # and
      _p37 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                            names=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.indent();
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                                            body=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.outdent();
        break if _t == BaseParser.__ERROR__

        _t=(
              pre = StringBuilder.new
              post = StringBuilder.new
              l = Object[].cast(names)
              l.each do |_name|
                name = String(_name)
                saved = "__saved_#{name.replace('@', '')}"
                pre.append("#@_#{saved} = #{name}\n")
                post.append("#@_  #{name} = #{saved}\n")
              end
              "#{pre}#{@_}begin\n#{@_}#{body}\n#{@_}ensure\n#{post}#{@_}end\n"
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p37 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Scope" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Parser:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Parser')
    p = n = s = xs = Object(nil)

    begin  # and
      _p39 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                              p=_t;
        break if _t == BaseParser.__ERROR__

        _t=self._any();
                                                                              n=_t;
        break if _t == BaseParser.__ERROR__

        _t=self._any();
                                                                              s=_t;
        break if _t == BaseParser.__ERROR__

        _t=( @name = String(n); @sname = String(s); nil );
        break if _t == BaseParser.__ERROR__

        as38 = ArrayList.new
                                                                              while true  # many
                                                                              _t=self.trans();
                                                                              if (_t==BaseParser.__ERROR__); break; else as38.add(_t);nil;end
                                                                              end; _t=as38

                                                                              xs=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
              init = build_init
              b = render('parser', name: @name, superclass: @sname, init: init, xs:xs, methods:@methods, rules:@rules)
              reset
              b
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p39 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Parser" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Method:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Method')
    c = Object(nil)

    begin  # and
      _p40 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                                c=_t;
        break if _t == BaseParser.__ERROR__

        _t="  #{c}\n";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p40 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Method" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Field:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Field')
    c = Object(nil)

    begin  # and
      _p41 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                                  c=_t;
        break if _t == BaseParser.__ERROR__

        _t="  #{c}\n";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p41 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Field" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Package:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Package')
    c = Object(nil)

    begin  # and
      _p42 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                                    c=_t;
        break if _t == BaseParser.__ERROR__

        _t=( @jpackage = String(c); ""; );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p42 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Package" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Import:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Import')
    c = Object(nil)

    begin  # and
      _p43 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                                      c=_t;
        break if _t == BaseParser.__ERROR__

        _t=c;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p43 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Import" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Class:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Class')
    q = d = c = Object(nil)

    begin  # and
      _p44 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                                        q=_t;
        break if _t == BaseParser.__ERROR__

        _t=self._any();
                                                                                        d=_t;
        break if _t == BaseParser.__ERROR__

        _t=self._any();
                                                                                        c=_t;
        break if _t == BaseParser.__ERROR__

        _t="#{d}\n#{c}\nend";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p44 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Class" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Line:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Line')
    ws = x = Object(nil)

    begin  # and
      _p45 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
                                                                                          ws=_t;
        break if _t == BaseParser.__ERROR__

        _t=self.trans();
                                                                                          x=_t;
        break if _t == BaseParser.__ERROR__

        _t=( ws.toString + x.toString );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p45 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Line" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def File:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('File')
    xs = Object(nil)

    begin  # and
      _p47 = _pos; _t=nil
      begin  # and (inner)
        as46 = ArrayList.new
                                                                                            while true  # many
                                                                                            _t=self.trans();
                                                                                            if (_t==BaseParser.__ERROR__); break; else as46.add(_t);nil;end
                                                                                            end; _t=as46

                                                                                            xs=_t;
        break if _t == BaseParser.__ERROR__

        _t=(
                "# generated by mmeta on #{Date.new}\n" +
                "# do not modify, instead edit original .mmeta file\n" +
                "import java.util.ArrayList\n" +
                "import java.util.Date\n" +
                "import java.util.List\n" +
                "import java.util.EnumSet\n" +
                (@embedded ? "" : "import jmeta.*;\n") + join(xs)
            );
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p47 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "File" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def start:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('start')
    r = Object(nil)

    begin  # and
      _p48 = _pos; _t=nil
      begin  # and (inner)
        _t=self.destruct();
                                                                                              r=_t;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=r;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p48 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "start" if (_t==BaseParser.__ERROR__)
    return _t
  end

    def unescape(s:String);
        sb = StringBuilder.new
        i = 0
        while i < s.length
          if s.charAt(i) == 92 # ?\\
            i += 1
            c = s.substring(i, i + 1)
            if c.equals("n")
              sb.append("\n")
            elsif c == "s"
              sb.append("\s")
            elsif c == "r"
              sb.append("\r")
            elsif c == "t"
              sb.append("\t")
            elsif c == "v"
              sb.append("\v")
            elsif c == "f"
              sb.append("\f")
            elsif c == "b"
              sb.append("\b")
            elsif c == "a"
              sb.append("\a")
            elsif c == "e"
              sb.append("\e")
            else
              sb.append(c)
            end
          else
            sb.append(s.charAt(i))
          end
          i += 1
        end
        str = sb.toString
        ints = int[str.length]
        ints.length.times do |i|
          ints[i] = str.charAt(i)
        end
        ints
      ;end

    def compile_literal_string(_s:Object);
        s = unescape(String(_s))
        if s.length == 0
          "_t = ''\n"
        else
          var = "_p#{genvar}"
          render('literal_string', string:_s, chars: s, var: var)
        end
      ;end

    def lookup_token(name:Object);
        @tokens ||= ArrayList.new
        index = @tokens.indexOf(name)
        if index == -1
          index = @tokens.size
          @tokens.add(name)
        end
        return index
      ;end

    def lookup_range(first:Object, last:Object);
        key = "#{first},#{last}"
        val = String(@ranges.get(key))
        if val.nil?
          val = "@_trange#{@ranges.size}"
          @ranges.put(key, val)
        end
        val
      ;end

    def build_init();
        code = StringBuilder.new("\n@chars = _chars\nsuper()\n")
        @ranges.keySet.each do |key|
          tokens = String(key).split(",")
          first = tokens[0]
          last = tokens[1]
          name = @ranges.get(key)
          code.append("#{name} = EnumSet.range(Tokens.t#{first}, Tokens.t#{last})\n")
        end
        code.toString
      ;end

    def rule_body(n:Object, b:Object, force_memo:boolean);
        @rules.add(n)
        locals = localsAsInit
        render('rule_body', n:n, name:@name, memo: Boolean.valueOf(force_memo || @auto_memo),
               b:b, recursion:Boolean.valueOf(@left_recursion), locals:locals)

      ;end


  def _jump(r:String)
    return destruct() if (r == "destruct")
    return trans() if (r == "trans")
    return HList() if (r == "HList")
    return HConcat() if (r == "HConcat")
    return HStr() if (r == "HStr")
    return HLit() if (r == "HLit")
    return Node() if (r == "Node")
    return Error() if (r == "Error")
    return Set() if (r == "Set")
    return Str() if (r == "Str")
    return Sym() if (r == "Sym")
    return App() if (r == "App")
    return Dot() if (r == "Dot")
    return SAct() if (r == "SAct")
    return Act() if (r == "Act")
    return Pred() if (r == "Pred")
    return SynPred() if (r == "SynPred")
    return Token() if (r == "Token")
    return TokenRange() if (r == "TokenRange")
    return TLit() if (r == "TLit")
    return Or() if (r == "Or")
    return And() if (r == "And")
    return Many() if (r == "Many")
    return Many1() if (r == "Many1")
    return Opt() if (r == "Opt")
    return Not() if (r == "Not")
    return Peek() if (r == "Peek")
    return List() if (r == "List")
    return MemoRule() if (r == "MemoRule")
    return Rule() if (r == "Rule")
    return Scope() if (r == "Scope")
    return Parser() if (r == "Parser")
    return Method() if (r == "Method")
    return Field() if (r == "Field")
    return Package() if (r == "Package")
    return Import() if (r == "Import")
    return Class() if (r == "Class")
    return Line() if (r == "Line")
    return File() if (r == "File")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "destruct")
    return true if (r == "trans")
    return true if (r == "HList")
    return true if (r == "HConcat")
    return true if (r == "HStr")
    return true if (r == "HLit")
    return true if (r == "Node")
    return true if (r == "Error")
    return true if (r == "Set")
    return true if (r == "Str")
    return true if (r == "Sym")
    return true if (r == "App")
    return true if (r == "Dot")
    return true if (r == "SAct")
    return true if (r == "Act")
    return true if (r == "Pred")
    return true if (r == "SynPred")
    return true if (r == "Token")
    return true if (r == "TokenRange")
    return true if (r == "TLit")
    return true if (r == "Or")
    return true if (r == "And")
    return true if (r == "Many")
    return true if (r == "Many1")
    return true if (r == "Opt")
    return true if (r == "Not")
    return true if (r == "Peek")
    return true if (r == "List")
    return true if (r == "MemoRule")
    return true if (r == "Rule")
    return true if (r == "Scope")
    return true if (r == "Parser")
    return true if (r == "Method")
    return true if (r == "Field")
    return true if (r == "Package")
    return true if (r == "Import")
    return true if (r == "Class")
    return true if (r == "Line")
    return true if (r == "File")
    return true if (r == "start")
    super(r)
  end
end
