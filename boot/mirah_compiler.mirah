# generated by mmeta on Tue Apr 26 15:11:31 PDT 2011
# do not modify, instead edit original .mmeta file
import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import jmeta.*;


import java.util.*;
import hapax.TemplateDataDictionary;
import hapax.TemplateDictionary;
import hapax.TemplateResourceLoader;


 class  DoError 

  def initialize(m:Object)
    @msg = String(m)
  end

  def message
    @msg
  end

end

class MMetaCompiler < BaseParser
  def _init

    @chars = _chars
    super()

  end

  def self.main(args:String[])

          returns void
          if args.length < 1
              puts "MMetaCompiler <input> [output]"
              System.exit(2)
          end
          # if args.length > 1 && args[1].equals("--embed")
          #     embed = true
          # end
          options = {recursion: Boolean.valueOf(false), auto_memo: Boolean.valueOf(false)}
          i = 0
          while i < args.length && args[i].startsWith('--')
            arg = args[i].substring(2)
            if options.containsKey(arg)
              options.put(arg, Boolean.valueOf(true))
            else
              puts "Unrecognized option --#{arg}."
              puts "Supported options: #{options.keySet}"
              System.exit(1)
            end
            i += 1
          end
          if args.length > i
            output_file = args[i + 1]
          else
            output_file = args[i] + ".mirah"
          end
          input = Utils.readFile(args[i])

          compiler = MMetaCompiler.new
          compiler.left_recursion = Boolean(options.get(:recursion)).booleanValue
          compiler.auto_memo = Boolean(options.get(:auto_memo)).booleanValue
          # compiler.embedded = embed
          parser = MMetaParser.new
          BaseParser.tracing = false
          ast = parser.parse(input)
          BaseParser.tracing = false
          # puts BaseParser.print_r(ast)

          output = String(compiler.parse(ast))
          Utils.writeFile(output_file, output)
          System.exit(0)
        
  end


  def initialize()

          @jpackage = String(nil)
          @embedded = false
          @locals = ArrayList.new
          @methods = ArrayList.new
          @rules = ArrayList.new
          @ranges = HashMap.new
          @sname = "ERROR-sname-ERROR"
          @name = "ERROR-name-ERROR"
          @_ = "  "
          @__genc = -1
          @left_recursion = Boolean.getBoolean("mmeta.left_recursion")
          @auto_memo = Boolean.getBoolean("mmeta.auto_memo")
          @templates = TemplateResourceLoader.create('mmeta/templates/')
        
  end


  def left_recursion_set(value:boolean)

          @left_recursion = value
        
  end


  def auto_memo_set(value:boolean)

          @auto_memo = value
        
  end


  def reset()

            @locals = ArrayList.new
            @methods = ArrayList.new
            @rules = ArrayList.new
        
  end


  def addLocal(n:Object)

            s = String(n).intern
            @locals.add(s) unless @locals.contains(s)
        
  end


  def localsAsArgs()

          localsAsCall
        
  end


  def localsAsCall()

            join(@locals, ",")
        
  end


  def localsAsInit()

          return '' if @locals.size == 0
          res = join(@locals, " = ") + " = Object(nil)\n"
          @locals.clear
          res
        
  end


  def embedded_set(embedded:boolean)
    @embeded = embedded
  end


  def genvar()
     "" + (@__genc = @__genc + 1); 
  end


  def destruct:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('destruct')
    t = r = Object(nil)

    begin  # and
      _p0 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        t = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _push(t); _t=self.apply();
        r = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=r;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p0 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "destruct" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def trans:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('trans')
    r = Object(nil)

    __saved_dict = @dict
    begin  # scope
      begin  # and
        _p3 = _pos; _t=nil
        begin  # and (inner)
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          begin  # or
            begin  # and
              _p2 = _pos; _t=nil
              begin  # and (inner)
                _t = _listBegin()
                if (_t != BaseParser.__ERROR__)
                  _t = BaseParser.__ERROR__
                  begin  # or
                    begin  # and
                      _p1 = _pos; _t=nil
                      begin  # and (inner)
                        _t=self.destruct();
                        r = _t

                        break if _t == BaseParser.__ERROR__

                      end while false  # and (inner)
                      self._pos=_p1 if (_t==BaseParser.__ERROR__)
                    end  # and

                    break unless _t == BaseParser.__ERROR__
                  end while false

                  _listEnd()
                end

                break if _t == BaseParser.__ERROR__

                _t=r;
                break if _t == BaseParser.__ERROR__

              end while false  # and (inner)
              self._pos=_p2 if (_t==BaseParser.__ERROR__)
            end  # and

            break unless _t == BaseParser.__ERROR__
          end while false

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p3 if (_t==BaseParser.__ERROR__)
      end  # and

    ensure
      @dict = __saved_dict
    end  # scope

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "trans" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HList:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HList')
    ls = Object(nil)

    begin  # and
      _p5 = _pos; _t=nil
      begin  # and (inner)
        as4 = ArrayList.new
        while true  # star
          _t=self.trans();
          if (_t == BaseParser.__ERROR__)
            break
          else
            as4.add(_t)
            nil
          end
        end
        _t = as4


        ls = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                if List(ls).size == 0
                  "ArrayList.new"
                else
                  "[#{join(ls, ", ")}]"
                end
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p5 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HList" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HConcat:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HConcat')
    l = r = Object(nil)

    begin  # and
      _p6 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        l = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        r = _t

        break if _t == BaseParser.__ERROR__

        _t="concat(#{l}, #{r})";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p6 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HConcat" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HStr:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HStr')
    c = Object(nil)

    begin  # and
      _p7 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="\"#{c}\"";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p7 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HStr" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def HLit:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('HLit')
    c = Object(nil)

    begin  # and
      _p8 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t=c;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p8 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "HLit" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Node:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Node')
    n = c = Object(nil)

    begin  # and
      _p9 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="build_node('#{n}', #{c}, _real_start > 1 ? _real_start : _start, _pos)";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p9 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Node" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Error:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Error')
    msg = Object(nil)

    begin  # and
      _p10 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        msg = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  DoError.new(msg);
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p10 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Error" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Set:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Set')
    n = x = Object(nil)

    begin  # and
      _p11 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  addLocal(n);
                  add_dict
                  @dict.setVariable(:NAME, n.toString)
                  add_expr(:EXPR, x)
                  render(:save_to_var)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p11 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Set" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Str:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Str')
    s = Object(nil)

    begin  # and
      _p12 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           compile_literal_string(s) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p12 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Str" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Sym:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Sym')
    s = Object(nil)

    begin  # and
      _p13 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t="_t=_sym(\"#{s}\");";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p13 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Sym" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def App:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('App')
    rule = args = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p15 = _pos; _t=nil
        begin  # and (inner)
          _t=_sym("super");
          break if _t == BaseParser.__ERROR__

          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          as14 = ArrayList.new
          _t=self.trans();
          if (_t!=BaseParser.__ERROR__)  # plus
            as14.add(_t)
            while true  # star
              _t=self.trans();
              if (_t == BaseParser.__ERROR__)
                break
              else
                as14.add(_t)
                nil
              end
            end
            _t = as14

          end

          args = _t

          break if _t == BaseParser.__ERROR__

          _t = begin

                    arg_str = if List(args).size == 1
                      join(args, ", ")
                    else
                      "[#{join(args, ", ")}].toArray"
                    end
                    "_push(#{arg_str}); _t=super();"
                
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p15 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p16 = _pos; _t=nil
        begin  # and (inner)
          _t=_sym("super");
          break if _t == BaseParser.__ERROR__

          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          _t="_t=super();";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p16 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p18 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          as17 = ArrayList.new
          _t=self.trans();
          if (_t!=BaseParser.__ERROR__)  # plus
            as17.add(_t)
            while true  # star
              _t=self.trans();
              if (_t == BaseParser.__ERROR__)
                break
              else
                as17.add(_t)
                nil
              end
            end
            _t = as17

          end

          args = _t

          break if _t == BaseParser.__ERROR__

          _t = begin

                    arg_str = if List(args).size == 1
                      join(args, ", ")
                    else
                      "[#{join(args, ", ")}].toArray"
                    end
                    "_push(#{arg_str}); _t=self.#{rule}();"
                
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p18 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p19 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          rule = _t

          break if _t == BaseParser.__ERROR__

          _t="_t=self.#{rule}();";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p19 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "App" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Dot:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Dot')
    _t="if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;";
    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Dot" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def SAct:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('SAct')
    expr = Object(nil)

    begin  # and
      _p20 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        expr = _t

        break if _t == BaseParser.__ERROR__

        _t="_t=#{expr};";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p20 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "SAct" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Act:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Act')
    expr = Object(nil)

    begin  # and
      _p21 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        expr = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  add_dict
                  add_expr(:BODY, expr)
                  render(:action)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p21 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Act" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Pred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Pred')
    expr = Object(nil)

    begin  # and
      _p22 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        expr = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                add_dict
                @dict.setVariable(:EXPR, expr.toString)
                render('predicate')
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p22 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Pred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def SynPred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('SynPred')
    pred = t = e = Object(nil)

    begin  # and
      _p23 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        pred = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.trans();
        t = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.trans();
        e = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = begin

                add_dict
                add_expr(:PRED, pred)
                add_expr(:BODY, t)
                add_expr(:ELSE, e)
                render('syn_pred')
              
        end

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p23 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "SynPred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Token:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Token')
    name = Object(nil)

    begin  # and
      _p24 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        name = _t

        break if _t == BaseParser.__ERROR__

        _t="_t = _lex(Tokens.t#{name})\n";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p24 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Token" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def TokenRange:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('TokenRange')
    first = last = Object(nil)

    begin  # and
      _p25 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        first = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        last = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                range = lookup_range(first, last)
                add_dict
                @dict.setVariable(:FIRST, first.toString)
                @dict.setVariable(:LAST, last.toString)
                @dict.setVariable(:RANGE, range)
                render('token_range')
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p25 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "TokenRange" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def TLit:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('TLit')
    name = Object(nil)

    begin  # and
      _p26 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        name = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                token = Integer.valueOf(lookup_token(name))
                add_dict
                @dict.setVariable(:NAME, name.toString)
                @dict.setVariable(:TOKEN, token.toString)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p26 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "TLit" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Or:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Or')
    xs = Object(nil)

    begin  # and
      _p28 = _pos; _t=nil
      begin  # and (inner)
        as27 = ArrayList.new
        while true  # star
          _t=self.trans();
          if (_t == BaseParser.__ERROR__)
            break
          else
            as27.add(_t)
            nil
          end
        end
        _t = as27


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                dict = add_dict
                List(xs).each do |expr|
                  @dict = dict.addSection(:EXPR)
                  add_expr(:EXPR, expr)
                end
                render('or', dict)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p28 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Or" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def And:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('And')
    ts = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p30 = _pos; _t=nil
        begin  # and (inner)
          as29 = ArrayList.new
          _t=self.trans();
          if (_t!=BaseParser.__ERROR__)  # plus
            as29.add(_t)
            while true  # star
              _t=self.trans();
              if (_t == BaseParser.__ERROR__)
                break
              else
                as29.add(_t)
                nil
              end
            end
            _t = as29

          end

          ts = _t

          break if _t == BaseParser.__ERROR__

          _t = begin

                  dict = add_dict
                  @dict.setVariable(:VAR, genvar)
                  err = String(nil)
                  List(ts).each do |expr|
                    if expr.kind_of?(DoError)
                      err = DoError(expr).message
                      next
                    end
                    @dict = dict.addSection(:EXPR)
                    if err
                      @dict.setVariable(:ERROR, err)
                    else
                      @dict.showSection(:NO_ERROR)
                    end
                    add_expr(:EXPR, expr)
                  end
                  render('and', dict)
                
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p30 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t="";
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "And" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def makeMany(x:Object, many1:boolean)

          add_dict
          @dict.setVariable(:VAR, genvar)
          @dict.setVariable(:LIST_ITEMS, :list_items)
          add_expr(:EXPR, x)
          add_expr(:EXPR, x, @dict.addSection(:LIST_ITEMS))
          if many1
            render('build_non_empty_list')
          else
            render('build_list')
          end
        
  end


  def Many:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many')
    x = Object(nil)

    begin  # and
      _p31 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           makeMany(x, false) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p31 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Many" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Many1:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many1')
    x = Object(nil)

    begin  # and
      _p32 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           makeMany(x, true)  
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p32 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Many1" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Opt:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Opt')
    x = Object(nil)

    begin  # and
      _p33 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                add_dict
                add_expr(:EXPR, x)
                render('opt')
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p33 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Opt" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Not:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Not')
    x = Object(nil)

    begin  # and
      _p34 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                add_dict
                add_expr(:EXPR, x)
                render('not')
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p34 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Not" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Peek:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Peek')
    x = Object(nil)

    begin  # and
      _p35 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                add_dict
                @dict.setVariable(:VAR, genvar)
                add_expr(:EXPR, x)
                render('peek')
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p35 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Peek" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def List:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('List')
    x = Object(nil)

    begin  # and
      _p36 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                add_dict
                add_expr(:EXPR, x)
                render('list')
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p36 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "List" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def MemoRule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('MemoRule')
    n = b = Object(nil)

    begin  # and
      _p37 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        b = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                rule_body(n, b, true)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p37 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "MemoRule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Rule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Rule')
    n = b = Object(nil)

    begin  # and
      _p38 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        b = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                rule_body(n, b, false)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p38 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Rule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Scope:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Scope')
    names = body = Object(nil)

    begin  # and
      _p39 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        names = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        body = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                add_dict
                add_expr(:BODY, body)
                l = if names.kind_of?(List)
                  List(names)
                else
                  Arrays.asList(Object[].cast(names))
                end
                l.each do |_name|
                  name = String(_name)
                  dict = @dict.addSection(:VARS)
                  dict.setVariable(:NAME, name)
                  dict.setVariable(:SIMPLE_NAME, name.replace('@', ''))
                end
                render('scope')
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p39 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Scope" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Parser:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Parser')
    p = n = s = xs = Object(nil)

    begin  # and
      _p41 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        p = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           @name = String(n); @sname = String(s) 
        end

        break if _t == BaseParser.__ERROR__

        as40 = ArrayList.new
        while true  # star
          _t=self.trans();
          if (_t == BaseParser.__ERROR__)
            break
          else
            as40.add(_t)
            nil
          end
        end
        _t = as40


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                dict = add_dict
                build_init
                @rules.each do |name|
                  @dict.addSection(:RULE).setVariable(:RULE, String(name))
                end
                @dict.setVariable(:PARSER, @name)
                @dict.setVariable(:SUPERCLASS, @sname)
                List(xs).each do |expr|
                  @dict = dict.addSection(:BODY)
                  add_expr(:BODY, expr)
                end
                b = render('parser', dict)
                reset
                b
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p41 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Parser" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Method:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Method')
    name = args = body = c = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p42 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          name = _t

          break if _t == BaseParser.__ERROR__

          _t=self._any();
          args = _t

          break if _t == BaseParser.__ERROR__

          _t=self._any();
          body = _t

          break if _t == BaseParser.__ERROR__

          _t = begin

                  add_dict
                  @dict.setVariable(:NAME, name.toString)
                  @dict.setVariable(:ARGS, args.toString)
                  add_expr(:BODY, body)
                  render('method')
                
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p42 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p43 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          c = _t

          break if _t == BaseParser.__ERROR__

          _t="  #{c}\n";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p43 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Method" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Field:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Field')
    c = Object(nil)

    begin  # and
      _p44 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="  #{c}\n";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p44 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Field" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Package:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Package')
    c = Object(nil)

    begin  # and
      _p45 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           @jpackage = String(c); ""; 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p45 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Package" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Import:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Import')
    c = Object(nil)

    begin  # and
      _p46 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t=c;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p46 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Import" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Class:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Class')
    q = d = c = Object(nil)

    begin  # and
      _p47 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        q = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        d = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        c = _t

        break if _t == BaseParser.__ERROR__

        _t="#{d}\n#{c}\n end";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p47 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Class" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Line:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Line')
    ws = x = Object(nil)

    begin  # and
      _p48 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        ws = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           ws.toString + x.toString 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p48 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "Line" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def File:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('File')
    xs = Object(nil)

    begin  # and
      _p50 = _pos; _t=nil
      begin  # and (inner)
        as49 = ArrayList.new
        while true  # star
          _t=self.trans();
          if (_t == BaseParser.__ERROR__)
            break
          else
            as49.add(_t)
            nil
          end
        end
        _t = as49


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  "# generated by mmeta on #{Date.new}\n" +
                  "# do not modify, instead edit original .mmeta file\n" +
                  "import java.util.ArrayList\n" +
                  "import java.util.Date\n" +
                  "import java.util.List\n" +
                  "import java.util.EnumSet\n" +
                  (@embedded ? "" : "import mmeta.*;\n") + join(xs)
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p50 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "File" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def start:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('start')
    r = Object(nil)

    begin  # and
      _p51 = _pos; _t=nil
      begin  # and (inner)
        _t=self.destruct();
        r = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=r;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p51 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_t)
    BaseParser.__ERROR__.last = "start" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def unescape(s:String)

          sb = StringBuilder.new
          i = 0
          while i < s.length
            if s.charAt(i) == 92 # ?\\
              i += 1
              c = s.substring(i, i + 1)
              if c.equals("n")
                sb.append("\n")
              elsif c == "s"
                sb.append("\s")
              elsif c == "r"
                sb.append("\r")
              elsif c == "t"
                sb.append("\t")
              elsif c == "v"
                sb.append("\v")
              elsif c == "f"
                sb.append("\f")
              elsif c == "b"
                sb.append("\b")
              elsif c == "a"
                sb.append("\a")
              elsif c == "e"
                sb.append("\e")
              else
                sb.append(c)
              end
            else
              sb.append(s.charAt(i))
            end
            i += 1
          end
          str = sb.toString
          ints = int[str.length]
          ints.length.times do |i|
            ints[i] = str.charAt(i)
          end
          ints
        
  end


  def compile_literal_string(_s:Object)

          s = unescape(String(_s))
          if s.length == 0
            "_t = ''\n"
          else
            add_dict
            @dict.setVariable(:VAR, "_p#{genvar}")
            @dict.setVariable(:STRING, String(_s))
            @dict.setVariable(:LENGTH, String.valueOf(s.length))
            s.each do |i|
              @dict.addSection(:CHAR).setVariable(:CHAR, String.valueOf(i))
            end
            render('string_literal')
          end
        
  end


  def lookup_token(name:Object)

          @tokens ||= ArrayList.new
          index = @tokens.indexOf(name)
          if index == -1
            index = @tokens.size
            @tokens.add(name)
          end
          return index
        
  end


  def lookup_range(first:Object, last:Object)

          key = "#{first},#{last}"
          val = String(@ranges.get(key))
          if val.nil?
            val = "@_trange#{@ranges.size}"
            @ranges.put(key, val)
          end
          val
        
  end


  def build_init()

          @ranges.keySet.each do |key|
            dict = @dict.addSection(:RANGE)
            tokens = String(key).split(",")
            dict.setVariable(:FIRST, tokens[0])
            dict.setVariable(:LAST, tokens[1])
            dict.setVariable(:NAME, @ranges.get(key).toString)
          end
        
  end


  def rule_body(n:Object, b:Object, force_memo:boolean)

          @rules.add(n)
          add_dict
          @dict.setVariable(:RULE, n.toString)
          @dict.setVariable(:MEMO_KEY, "#{@name}.#{n}")
          @dict.setVariable(:LOCALS, localsAsInit)
          @dict.setVariable(:RULE_BODY2, :rule_body_2)
          add_expr(:BODY, b, @dict.addSection(:RULE_BODY2))
          if force_memo || @auto_memo
            @dict.showSection(:MEMO)
          else
            @dict.showSection(:UNMEMO)
          end
          if @left_recursion
            @dict.showSection(:RECURSION)
          else
            @dict.showSection(:NO_RECURSION)
          end
          render('rule_body')
        
  end


  def render(template:String, dict:TemplateDataDictionary=nil)

          tpl = @templates.getTemplate(template)
          dict ||= @dict
          tpl.renderToString(dict)
        
  end


  def add_dict()

          @dict = TemplateDataDictionary(TemplateDictionary.create)
          # @dict.enableDebugAnnotations
        
  end


  def add_expr(name:String, expr:Object, dict:TemplateDataDictionary=nil)

          dict ||= @dict
          dict.setVariable(name, :simple_expr)
          dict.addSection(name).setVariable(:EXPR, expr.toString)
        
  end



  def _jump(r:String)
    return destruct() if (r == "destruct")
    return trans() if (r == "trans")
    return HList() if (r == "HList")
    return HConcat() if (r == "HConcat")
    return HStr() if (r == "HStr")
    return HLit() if (r == "HLit")
    return Node() if (r == "Node")
    return Error() if (r == "Error")
    return Set() if (r == "Set")
    return Str() if (r == "Str")
    return Sym() if (r == "Sym")
    return App() if (r == "App")
    return Dot() if (r == "Dot")
    return SAct() if (r == "SAct")
    return Act() if (r == "Act")
    return Pred() if (r == "Pred")
    return SynPred() if (r == "SynPred")
    return Token() if (r == "Token")
    return TokenRange() if (r == "TokenRange")
    return TLit() if (r == "TLit")
    return Or() if (r == "Or")
    return And() if (r == "And")
    return Many() if (r == "Many")
    return Many1() if (r == "Many1")
    return Opt() if (r == "Opt")
    return Not() if (r == "Not")
    return Peek() if (r == "Peek")
    return List() if (r == "List")
    return MemoRule() if (r == "MemoRule")
    return Rule() if (r == "Rule")
    return Scope() if (r == "Scope")
    return Parser() if (r == "Parser")
    return Method() if (r == "Method")
    return Field() if (r == "Field")
    return Package() if (r == "Package")
    return Import() if (r == "Import")
    return Class() if (r == "Class")
    return Line() if (r == "Line")
    return File() if (r == "File")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "destruct")
    return true if (r == "trans")
    return true if (r == "HList")
    return true if (r == "HConcat")
    return true if (r == "HStr")
    return true if (r == "HLit")
    return true if (r == "Node")
    return true if (r == "Error")
    return true if (r == "Set")
    return true if (r == "Str")
    return true if (r == "Sym")
    return true if (r == "App")
    return true if (r == "Dot")
    return true if (r == "SAct")
    return true if (r == "Act")
    return true if (r == "Pred")
    return true if (r == "SynPred")
    return true if (r == "Token")
    return true if (r == "TokenRange")
    return true if (r == "TLit")
    return true if (r == "Or")
    return true if (r == "And")
    return true if (r == "Many")
    return true if (r == "Many1")
    return true if (r == "Opt")
    return true if (r == "Not")
    return true if (r == "Peek")
    return true if (r == "List")
    return true if (r == "MemoRule")
    return true if (r == "Rule")
    return true if (r == "Scope")
    return true if (r == "Parser")
    return true if (r == "Method")
    return true if (r == "Field")
    return true if (r == "Package")
    return true if (r == "Import")
    return true if (r == "Class")
    return true if (r == "Line")
    return true if (r == "File")
    return true if (r == "start")
    super(r)
  end
end
