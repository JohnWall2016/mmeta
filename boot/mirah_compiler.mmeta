// copyright 2009 ActiveVideo; license: MIT; see license.txt
package mmeta;
import java.util.*;
import hapax.TemplateDataDictionary
import hapax.TemplateDictionary
import hapax.TemplateResourceLoader


public class DoError {
  def initialize(m:Object)
    @msg = String(m)
  end

  def message
    @msg
  end
}

public parser MMetaCompiler {
    def self.main(args:String[]) {
      returns void
      if args.length < 1
          puts "MMetaCompiler <input> [output]"
          System.exit(2)
      end
      # if args.length > 1 && args[1].equals("--embed")
      #     embed = true
      # end
      options = {recursion: Boolean.valueOf(false), auto_memo: Boolean.valueOf(false)}
      i = 0
      while i < args.length && args[i].startsWith('--')
        arg = args[i].substring(2)
        if options.containsKey(arg)
          options.put(arg, Boolean.valueOf(true))
        else
          puts "Unrecognized option --#{arg}."
          puts "Supported options: #{options.keySet}"
          System.exit(1)
        end
        i += 1
      end
      if args.length > i
        output_file = args[i + 1]
      else
        output_file = args[i] + ".mirah"
      end
      input = Utils.readFile(args[i])

      compiler = MMetaCompiler.new
      compiler.left_recursion = Boolean(options.get(:recursion)).booleanValue
      compiler.auto_memo = Boolean(options.get(:auto_memo)).booleanValue
      # compiler.embedded = embed
      parser = MMetaParser.new
      BaseParser.tracing = false
      ast = parser.parse(input)
      BaseParser.tracing = false
      # puts BaseParser.print_r(ast)

      output = String(compiler.parse(ast))
      Utils.writeFile(output_file, output)
      System.exit(0)
    }

    def initialize {
      @jpackage = String(nil)
      @embedded = false
      @locals = ArrayList.new
      @methods = ArrayList.new
      @rules = ArrayList.new
      @ranges = HashMap.new
      @sname = "ERROR-sname-ERROR"
      @name = "ERROR-name-ERROR"
      @_ = "  "
      @__genc = -1
      @left_recursion = Boolean.getBoolean("mmeta.left_recursion")
      @auto_memo = Boolean.getBoolean("mmeta.auto_memo")
      @templates = TemplateResourceLoader.create('mmeta/templates/')
    }

    def left_recursion_set(value:boolean) {
      @left_recursion = value
    }

    def auto_memo_set(value:boolean) {
      @auto_memo = value
    }

    def reset {
        @locals = ArrayList.new
        @methods = ArrayList.new
        @rules = ArrayList.new
    }

    def addLocal(n:Object) {
        s = String(n).intern
        @locals.add(s) unless @locals.contains(s)
    }
    def localsAsArgs {
      localsAsCall
    }
    def localsAsCall {
        join(@locals, ",")
    }
    def localsAsInit {
      return '' if @locals.size == 0
      res = join(@locals, " = ") + " = Object(nil)\n"
      @locals.clear
      res
    }

    def embedded_set(embedded:boolean) {@embeded = embedded}

    def genvar { "" + (@__genc = @__genc + 1); }

    destruct: ! t=_ r=apply(t) end    { r } ;
    trans scope(@dict): [ r=destruct ]             { r } ;

    HList ls=trans* {
      if List(ls).size == 0
        "ArrayList.new"
      else
        "[#{join(ls, ", ")}]"
      end
    };
    HConcat l=trans r=trans { "concat(#{l}, #{r})" };
    HStr c=_ { "\"#{c}\"" };
    HLit c=_ { c } ;

    Node n=_ c=trans {"build_node('#{n}', #{c}, _real_start > 1 ? _real_start : _start, _pos)"};

    Error msg=_ {
        DoError.new(msg);
    };
    Set n=_ x=trans {
        addLocal(n);
        add_dict
        @dict.setVariable(:NAME, n.toString)
        add_expr(:EXPR, x)
        render(:save_to_var)
    };
    Str s=_ { compile_literal_string(s) };
    Sym s=_ { "_t=_sym(\"#{s}\");" };


    App :super rule=_ args=trans+ {
        arg_str = if List(args).size == 1
          join(args, ", ")
        else
          "[#{join(args, ", ")}].toArray"
        end
        "_push(#{arg_str}); _t=super();"
    };
    App :super rule=_ { "_t=super();" };
    App rule=_ args=trans+ {
        arg_str = if List(args).size == 1
          join(args, ", ")
        else
          "[#{join(args, ", ")}].toArray"
        end
        "_push(#{arg_str}); _t=self.#{rule}();"
    };
    App rule=_ { "_t=self.#{rule}();" };

    # Don't include whitespace at the beginning of the rule in it's position
    Dot {"if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;"};

    SAct expr=trans { "_t=#{expr};" };
    Act expr=_ {
        add_dict
        add_expr(:BODY, expr)
        render(:action)
    };
    Pred expr=_ {
      add_dict
      @dict.setVariable(:EXPR, expr.toString)
      render('predicate')
    };
    SynPred! pred=trans t=trans e=trans {
      add_dict
      add_expr(:PRED, pred)
      add_expr(:BODY, t)
      add_expr(:ELSE, e)
      render('syn_pred')
    };

    Token name=_ {
      "_t = _lex(Tokens.t#{name})\n"
    };
    TokenRange first=_ last=_ {
      range = lookup_range(first, last)
      add_dict
      @dict.setVariable(:FIRST, first.toString)
      @dict.setVariable(:LAST, last.toString)
      @dict.setVariable(:RANGE, range)
      render('token_range')
    };
    TLit name=_ {
      token = Integer.valueOf(lookup_token(name))
      add_dict
      @dict.setVariable(:NAME, name.toString)
      @dict.setVariable(:TOKEN, token.toString)
    };

    Or xs=trans* {
      dict = add_dict
      List(xs).each do |expr|
        @dict = dict.addSection(:EXPR)
        add_expr(:EXPR, expr)
      end
      render('or', dict)
    };


    And ts=trans+ {
      dict = add_dict
      @dict.setVariable(:VAR, genvar)
      err = String(nil)
      List(ts).each do |expr|
        if expr.kind_of?(DoError)
          err = DoError(expr).message
          next
        end
        @dict = dict.addSection(:EXPR)
        if err
          @dict.setVariable(:ERROR, err)
        else
          @dict.showSection(:NO_ERROR)
        end
        add_expr(:EXPR, expr)
      end
      render('and', dict)
    };
    And { "" };

    def makeMany(x:Object, many1:boolean) {
      add_dict
      @dict.setVariable(:VAR, genvar)
      @dict.setVariable(:LIST_ITEMS, :list_items)
      add_expr(:EXPR, x)
      add_expr(:EXPR, x, @dict.addSection(:LIST_ITEMS))
      if many1
        render('build_non_empty_list')
      else
        render('build_list')
      end
    }
    Many x=trans { makeMany(x, false) } ;
    Many1 x=trans { makeMany(x, true)  } ;

    Opt x=trans {
      add_dict
      add_expr(:EXPR, x)
      render('opt')
    };

    Not x=trans {
      add_dict
      add_expr(:EXPR, x)
      render('not')
    };

    Peek x=trans {
      add_dict
      @dict.setVariable(:VAR, genvar)
      add_expr(:EXPR, x)
      render('peek')
    };

    List x=trans {
      add_dict
      add_expr(:EXPR, x)
      render('list')
    };

    MemoRule n=_ b=trans {
      rule_body(n, b, true)
    };

    Rule n=_ b=trans {
      rule_body(n, b, false)
    };

    Scope names=_ body=trans {
      add_dict
      add_expr(:BODY, body)
      l = if names.kind_of?(List)
        List(names)
      else
        Arrays.asList(Object[].cast(names))
      end
      l.each do |_name|
        name = String(_name)
        dict = @dict.addSection(:VARS)
        dict.setVariable(:NAME, name)
        dict.setVariable(:SIMPLE_NAME, name.replace('@', ''))
      end
      render('scope')
    };

    Parser p=_ n=_ s=_ { @name = String(n); @sname = String(s) } xs=trans* {
      dict = add_dict
      build_init
      @rules.each do |name|
        @dict.addSection(:RULE).setVariable(:RULE, String(name))
      end
      @dict.setVariable(:PARSER, @name)
      @dict.setVariable(:SUPERCLASS, @sname)
      List(xs).each do |expr|
        @dict = dict.addSection(:BODY)
        add_expr(:BODY, expr)
      end
      b = render('parser', dict)
      reset
      b
    };

    Method name=_ args=_ body=_ {
      add_dict
      @dict.setVariable(:NAME, name.toString)
      @dict.setVariable(:ARGS, args.toString)
      add_expr(:BODY, body)
      render('method')
    };
    Method  c=_ { "  #{c}\n" } ;
    Field   c=_ { "  #{c}\n" } ;
    Package c=_ { @jpackage = String(c); ""; } ;
    Import  c=_ { c } ;
    Class   q=_ d=_ c=_ { "#{d}\n#{c}\n end" } ;
    Line  ws=_ x=trans { ws.toString + x.toString } ;

    File  xs=trans* {
        "# generated by mmeta on #{Date.new}\n" +
        "# do not modify, instead edit original .mmeta file\n" +
        "import java.util.ArrayList\n" +
        "import java.util.Date\n" +
        "import java.util.List\n" +
        "import java.util.EnumSet\n" +
        (@embedded ? "" : "import mmeta.*;\n") + join(xs)
    } ;

    start: ! r=destruct end           { r } ;

    def unescape(s:String) {
      sb = StringBuilder.new
      i = 0
      while i < s.length
        if s.charAt(i) == 92 # ?\\
          i += 1
          c = s.substring(i, i + 1)
          if c.equals("n")
            sb.append("\n")
          elsif c == "s"
            sb.append("\s")
          elsif c == "r"
            sb.append("\r")
          elsif c == "t"
            sb.append("\t")
          elsif c == "v"
            sb.append("\v")
          elsif c == "f"
            sb.append("\f")
          elsif c == "b"
            sb.append("\b")
          elsif c == "a"
            sb.append("\a")
          elsif c == "e"
            sb.append("\e")
          else
            sb.append(c)
          end
        else
          sb.append(s.charAt(i))
        end
        i += 1
      end
      str = sb.toString
      ints = int[str.length]
      ints.length.times do |i|
        ints[i] = str.charAt(i)
      end
      ints
    }

    def compile_literal_string(_s:Object) {
      s = unescape(String(_s))
      if s.length == 0
        "_t = ''\n"
      else
        add_dict
        @dict.setVariable(:VAR, "_p#{genvar}")
        @dict.setVariable(:STRING, String(_s))
        @dict.setVariable(:LENGTH, String.valueOf(s.length))
        s.each do |i|
          @dict.addSection(:CHAR).setVariable(:CHAR, String.valueOf(i))
        end
        render('string_literal')
      end
    }

    def lookup_token(name:Object) {
      @tokens ||= ArrayList.new
      index = @tokens.indexOf(name)
      if index == -1
        index = @tokens.size
        @tokens.add(name)
      end
      return index
    }

    def lookup_range(first:Object, last:Object) {
      key = "#{first},#{last}"
      val = String(@ranges.get(key))
      if val.nil?
        val = "@_trange#{@ranges.size}"
        @ranges.put(key, val)
      end
      val
    }

    def build_init {
      @ranges.keySet.each do |key|
        dict = @dict.addSection(:RANGE)
        tokens = String(key).split(",")
        dict.setVariable(:FIRST, tokens[0])
        dict.setVariable(:LAST, tokens[1])
        dict.setVariable(:NAME, @ranges.get(key).toString)
      end
    }

    def rule_body(n:Object, b:Object, force_memo:boolean) {
      @rules.add(n)
      add_dict
      @dict.setVariable(:RULE, n.toString)
      @dict.setVariable(:MEMO_KEY, "#{@name}.#{n}")
      @dict.setVariable(:LOCALS, localsAsInit)
      @dict.setVariable(:RULE_BODY2, :rule_body_2)
      add_expr(:BODY, b, @dict.addSection(:RULE_BODY2))
      if force_memo || @auto_memo
        @dict.showSection(:MEMO)
      else
        @dict.showSection(:UNMEMO)
      end
      if @left_recursion
        @dict.showSection(:RECURSION)
      else
        @dict.showSection(:NO_RECURSION)
      end
      render('rule_body')
    }

    def render(template:String, dict:TemplateDataDictionary=nil) {
      tpl = @templates.getTemplate(template)
      dict ||= @dict
      tpl.renderToString(dict)
    }

    def add_dict {
      @dict = TemplateDataDictionary(TemplateDictionary.create)
      # @dict.enableDebugAnnotations
    }

    def add_expr(name:String, expr:Object, dict:TemplateDataDictionary=nil) {
      dict ||= @dict
      dict.setVariable(name, :simple_expr)
      dict.addSection(name).setVariable(:EXPR, expr.toString)
    }
}
