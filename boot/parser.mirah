# generated by mmeta on Wed May 11 12:31:34 PDT 2011
# do not modify, instead edit original .mmeta file
import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import mmeta.*
import java.util.*

class MMetaParser < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  def oneOf()
    
          chars = String(_pop())
          return _char(chars)
        
  end
  

  
  def fromTo
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      y = nil
      _t = _sretrieve("MMetaParser.fromTo")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p2 = _pos
            begin
              x = (
                self._any()
              )
              y = (
                self._any()
              )
              begin
                _push([x].toArray)
                self.str()
              end
              begin
                as1 = ArrayList.new
                begin
                  while true do
                    _li = Object(
                      begin
                        _p0 = _pos
                        begin
                          begin  # not
                            begin
                              _push([y].toArray)
                              self.str()
                            end
                            nil
                          rescue RuleFailure
                            nil  # expected
                          else
                            raise @error
                          end
                          self._any()
                        rescue RuleFailure => ex
                          self._pos = _p0
                          raise ex
                        end
                      end
                    )
                    as1.add(_li)
                  end
                rescue RuleFailure; end
                as1
              end
              begin
                _push([y].toArray)
                self.str()
              end
            rescue RuleFailure => ex
              self._pos = _p2
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.fromTo", _start, ex)
      else
        _t = _memoize("MMetaParser.fromTo", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'fromTo'
      raise ex
    end
  end
  

  
  def sp
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.sp")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            super()
          rescue RuleFailure
            begin
              begin
                _push(["//", "\n"].toArray)
                self.fromTo()
              end
            rescue RuleFailure
              begin
                begin
                  _push(["/*", "*/"].toArray)
                  self.fromTo()
                end
              rescue RuleFailure
                begin
                  _push(["#", "\n"].toArray)
                  self.fromTo()
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.sp", _start, ex)
      else
        _t = _memoize("MMetaParser.sp", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'sp'
      raise ex
    end
  end
  

  
  def ws
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.ws")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            as3 = ArrayList.new
            begin
              while true do
                _li = Object(
                  begin
                    self.sp()
                  rescue RuleFailure
                    self.nl()
                  end
                )
                as3.add(_li)
              end
            rescue RuleFailure; end
            as3
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ws", _start, ex)
      else
        _t = _memoize("MMetaParser.ws", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ws'
      raise ex
    end
  end
  

  
  def listOf
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      e = nil
      s = nil
      f = nil
      rs = nil
      _t = _sretrieve("MMetaParser.listOf")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p8 = _pos
            begin
              e = (
                self._any()
              )
              s = (
                self._any()
              )
              begin
                begin
                  _p6 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    f = (
                      begin
                        _push([e].toArray)
                        self.apply()
                      end
                    )
                    rs = (
                      begin
                        as5 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p4 = _pos
                                begin
                                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                  begin
                                    _push([s].toArray)
                                    self.str()
                                  end
                                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                  begin
                                    _push([e].toArray)
                                    self.apply()
                                  end
                                rescue RuleFailure => ex
                                  self._pos = _p4
                                  raise ex
                                end
                              end
                            )
                            as5.add(_li)
                          end
                        rescue RuleFailure; end
                        as5
                      end
                    )
                    concat([f], rs)
                  rescue RuleFailure => ex
                    self._pos = _p6
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  _p7 = _pos
                  begin
                    self.empty()
                    ArrayList.new
                  rescue RuleFailure => ex
                    self._pos = _p7
                    raise ex
                  end
                end
              end
            rescue RuleFailure => ex
              self._pos = _p8
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.listOf", _start, ex)
      else
        _t = _memoize("MMetaParser.listOf", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'listOf'
      raise ex
    end
  end
  

  
  def nameFirst
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.nameFirst")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin  # '_'
              _p9 = _pos
              raise @error if _p9 + 1 > @chars.length
              raise @error unless @chars[_p9] == 95
              _p9 += 1
              self._pos = _p9
              "_"
            end
          rescue RuleFailure
            self.letter()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.nameFirst", _start, ex)
      else
        _t = _memoize("MMetaParser.nameFirst", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'nameFirst'
      raise ex
    end
  end
  

  
  def nameRest
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.nameRest")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            self.nameFirst()
          rescue RuleFailure
            self.digit()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.nameRest", _start, ex)
      else
        _t = _memoize("MMetaParser.nameRest", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'nameRest'
      raise ex
    end
  end
  

  
  def name
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      f = nil
      rs = nil
      _t = _sretrieve("MMetaParser.name")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p11 = _pos
            begin
              f = (
                self.nameFirst()
              )
              rs = (
                begin
                  as10 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.nameRest()
                      )
                      as10.add(_li)
                    end
                  rescue RuleFailure; end
                  as10
                end
              )
              begin
                 join(concat([f], rs)) 
              end
            rescue RuleFailure => ex
              self._pos = _p11
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.name", _start, ex)
      else
        _t = _memoize("MMetaParser.name", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'name'
      raise ex
    end
  end
  

  
  def rulename
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.rulename")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p12 = _pos
            begin
              begin  # not
                begin
                  _push(["def"].toArray)
                  self.k()
                end
                nil
              rescue RuleFailure
                nil  # expected
              else
                raise @error
              end
              self.name()
            rescue RuleFailure => ex
              self._pos = _p12
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rulename", _start, ex)
      else
        _t = _memoize("MMetaParser.rulename", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rulename'
      raise ex
    end
  end
  

  
  def varname
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      p = nil
      n = nil
      _t = _sretrieve("MMetaParser.varname")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p14 = _pos
            begin
              p = (
                begin
                  begin  # '@'
                    _p13 = _pos
                    raise @error if _p13 + 1 > @chars.length
                    raise @error unless @chars[_p13] == 64
                    _p13 += 1
                    self._pos = _p13
                    "@"
                  end
                rescue RuleFailure
                  ""
                end
              )
              n = (
                self.name()
              )
              "#{p}#{n}"
            rescue RuleFailure => ex
              self._pos = _p14
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.varname", _start, ex)
      else
        _t = _memoize("MMetaParser.varname", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'varname'
      raise ex
    end
  end
  

  
  def hex
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.hex")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _push(["0123456789abcdefABCDEF"].toArray)
            self.oneOf()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.hex", _start, ex)
      else
        _t = _memoize("MMetaParser.hex", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'hex'
      raise ex
    end
  end
  

  
  def echar
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      c = nil
      _t = _sretrieve("MMetaParser.echar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p17 = _pos
              begin
                begin  # '\\'
                  _p15 = _pos
                  raise @error if _p15 + 1 > @chars.length
                  raise @error unless @chars[_p15] == 92
                  _p15 += 1
                  self._pos = _p15
                  "\\"
                end
                begin
                  begin
                    _p16 = _pos
                    begin
                      c = (
                        self._any()
                      )
                      begin
                         "\\#{c}"; 
                      end
                    rescue RuleFailure => ex
                      self._pos = _p16
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p17
                raise ex
              end
            end
          rescue RuleFailure
            self._any()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.echar", _start, ex)
      else
        _t = _memoize("MMetaParser.echar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'echar'
      raise ex
    end
  end
  

  
  def tsString
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaParser.tsString")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p23 = _pos
            begin
              begin  # '\"'
                _p18 = _pos
                raise @error if _p18 + 1 > @chars.length
                raise @error unless @chars[_p18] == 34
                _p18 += 1
                self._pos = _p18
                "\""
              end
              xs = (
                begin
                  as21 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p20 = _pos
                          begin
                            begin  # not
                              begin  # '\"'
                                _p19 = _pos
                                raise @error if _p19 + 1 > @chars.length
                                raise @error unless @chars[_p19] == 34
                                _p19 += 1
                                self._pos = _p19
                                "\""
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            self.echar()
                          rescue RuleFailure => ex
                            self._pos = _p20
                            raise ex
                          end
                        end
                      )
                      as21.add(_li)
                    end
                  rescue RuleFailure; end
                  as21
                end
              )
              begin  # '\"'
                _p22 = _pos
                raise @error if _p22 + 1 > @chars.length
                raise @error unless @chars[_p22] == 34
                _p22 += 1
                self._pos = _p22
                "\""
              end
              begin
                 join(xs) 
              end
            rescue RuleFailure => ex
              self._pos = _p23
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.tsString", _start, ex)
      else
        _t = _memoize("MMetaParser.tsString", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'tsString'
      raise ex
    end
  end
  

  
  def dollar
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      n = nil
      _t = _sretrieve("MMetaParser.dollar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p27 = _pos
              begin
                begin  # '${'
                  _p24 = _pos
                  raise @error if _p24 + 2 > @chars.length
                  raise @error unless @chars[_p24] == 36
                  _p24 += 1
                  raise @error unless @chars[_p24] == 123
                  _p24 += 1
                  self._pos = _p24
                  "${"
                end
                xs = (
                  begin
                    as25 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.cbraces()
                        )
                        as25.add(_li)
                      end
                    rescue RuleFailure; end
                    as25
                  end
                )
                begin  # '}'
                  _p26 = _pos
                  raise @error if _p26 + 1 > @chars.length
                  raise @error unless @chars[_p26] == 125
                  _p26 += 1
                  self._pos = _p26
                  "}"
                end
                "\"+#{join(xs)}+\""
              rescue RuleFailure => ex
                self._pos = _p27
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p29 = _pos
              begin
                begin  # '$'
                  _p28 = _pos
                  raise @error if _p28 + 1 > @chars.length
                  raise @error unless @chars[_p28] == 36
                  _p28 += 1
                  self._pos = _p28
                  "$"
                end
                n = (
                  self.name()
                )
                "\"+#{n}+\""
              rescue RuleFailure => ex
                self._pos = _p29
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.dollar", _start, ex)
      else
        _t = _memoize("MMetaParser.dollar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'dollar'
      raise ex
    end
  end
  

  
  def dollarstring
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaParser.dollarstring")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p35 = _pos
            begin
              begin  # '\"'
                _p30 = _pos
                raise @error if _p30 + 1 > @chars.length
                raise @error unless @chars[_p30] == 34
                _p30 += 1
                self._pos = _p30
                "\""
              end
              xs = (
                begin
                  as33 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p32 = _pos
                          begin
                            begin  # not
                              begin  # '\"'
                                _p31 = _pos
                                raise @error if _p31 + 1 > @chars.length
                                raise @error unless @chars[_p31] == 34
                                _p31 += 1
                                self._pos = _p31
                                "\""
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            begin
                              self.dollar()
                            rescue RuleFailure
                              self.echar()
                            end
                          rescue RuleFailure => ex
                            self._pos = _p32
                            raise ex
                          end
                        end
                      )
                      as33.add(_li)
                    end
                  rescue RuleFailure; end
                  as33
                end
              )
              begin  # '\"'
                _p34 = _pos
                raise @error if _p34 + 1 > @chars.length
                raise @error unless @chars[_p34] == 34
                _p34 += 1
                self._pos = _p34
                "\""
              end
              begin
                 join(xs) 
              end
            rescue RuleFailure => ex
              self._pos = _p35
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.dollarstring", _start, ex)
      else
        _t = _memoize("MMetaParser.dollarstring", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'dollarstring'
      raise ex
    end
  end
  

  
  def string
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      s = nil
      _t = _sretrieve("MMetaParser.string")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p36 = _pos
            begin
              s = (
                self.tsString()
              )
              ["Str", s]
            rescue RuleFailure => ex
              self._pos = _p36
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.string", _start, ex)
      else
        _t = _memoize("MMetaParser.string", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'string'
      raise ex
    end
  end
  

  
  def number
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      sign = nil
      ds = nil
      _t = _sretrieve("MMetaParser.number")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p40 = _pos
            begin
              sign = (
                begin
                  begin  # '-'
                    _p37 = _pos
                    raise @error if _p37 + 1 > @chars.length
                    raise @error unless @chars[_p37] == 45
                    _p37 += 1
                    self._pos = _p37
                    "-"
                  end
                rescue RuleFailure
                  begin
                    begin  # '+'
                      _p38 = _pos
                      raise @error if _p38 + 1 > @chars.length
                      raise @error unless @chars[_p38] == 43
                      _p38 += 1
                      self._pos = _p38
                      "+"
                    end
                  rescue RuleFailure
                    self.empty()
                  end
                end
              )
              ds = (
                begin
                  as39 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.digit()
                      )
                      as39.add(_li)
                    end
                  rescue RuleFailure; end
                  raise @error if as39.size == 0
                  as39
                end
              )
              ["HLit", "#{sign}#{join(ds)}"]
            rescue RuleFailure => ex
              self._pos = _p40
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.number", _start, ex)
      else
        _t = _memoize("MMetaParser.number", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'number'
      raise ex
    end
  end
  

  
  def symbol
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      s = nil
      c = nil
      _t = _sretrieve("MMetaParser.symbol")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p49 = _pos
            begin
              begin
                begin  # '''
                  _p41 = _pos
                  raise @error if _p41 + 1 > @chars.length
                  raise @error unless @chars[_p41] == 39
                  _p41 += 1
                  self._pos = _p41
                  "'"
                end
              rescue RuleFailure
                begin  # ':'
                  _p42 = _pos
                  raise @error if _p42 + 1 > @chars.length
                  raise @error unless @chars[_p42] == 58
                  _p42 += 1
                  self._pos = _p42
                  ":"
                end
              end
              begin
                s = (
                  self.name()
                )
              rescue RuleFailure
                begin
                  _p48 = _pos
                  begin
                    begin  # '''
                      _p43 = _pos
                      raise @error if _p43 + 1 > @chars.length
                      raise @error unless @chars[_p43] == 39
                      _p43 += 1
                      self._pos = _p43
                      "'"
                    end
                    c = (
                      begin
                        as46 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p45 = _pos
                                begin
                                  begin  # not
                                    begin  # '''
                                      _p44 = _pos
                                      raise @error if _p44 + 1 > @chars.length
                                      raise @error unless @chars[_p44] == 39
                                      _p44 += 1
                                      self._pos = _p44
                                      "'"
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p45
                                  raise ex
                                end
                              end
                            )
                            as46.add(_li)
                          end
                        rescue RuleFailure; end
                        raise @error if as46.size == 0
                        as46
                      end
                    )
                    begin  # '''
                      _p47 = _pos
                      raise @error if _p47 + 1 > @chars.length
                      raise @error unless @chars[_p47] == 39
                      _p47 += 1
                      self._pos = _p47
                      "'"
                    end
                    s = (
                      begin
                        join(c)
                      end
                    )
                  rescue RuleFailure => ex
                    self._pos = _p48
                    raise ex
                  end
                end
              end
              ["Sym", s]
            rescue RuleFailure => ex
              self._pos = _p49
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.symbol", _start, ex)
      else
        _t = _memoize("MMetaParser.symbol", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'symbol'
      raise ex
    end
  end
  

  
  def k
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      keyword = nil
      _t = _sretrieve("MMetaParser.k")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p50 = _pos
            begin
              keyword = (
                self._any()
              )
              begin
                _push([keyword].toArray)
                self.str()
              end
              begin  # not
                begin
                  self.nameFirst()
                rescue RuleFailure
                  self.digit()
                end
                nil
              rescue RuleFailure
                nil  # expected
              else
                raise @error
              end
              keyword
            rescue RuleFailure => ex
              self._pos = _p50
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.k", _start, ex)
      else
        _t = _memoize("MMetaParser.k", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'k'
      raise ex
    end
  end
  

  
  def error
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      msg = nil
      b = nil
      _t = _sretrieve("MMetaParser.error")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p52 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin  # '!'
                _p51 = _pos
                raise @error if _p51 + 1 > @chars.length
                raise @error unless @chars[_p51] == 33
                _p51 += 1
                self._pos = _p51
                "!"
              end
              msg = (
                begin
                  self.dollarstring()
                rescue RuleFailure
                  self.empty()
                end
              )
              b = (
                self.expr4()
              )
              ["Error", msg, b]
            rescue RuleFailure => ex
              self._pos = _p52
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.error", _start, ex)
      else
        _t = _memoize("MMetaParser.error", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'error'
      raise ex
    end
  end
  

  
  def any
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.any")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p54 = _pos
            begin
              begin  # '_'
                _p53 = _pos
                raise @error if _p53 + 1 > @chars.length
                raise @error unless @chars[_p53] == 95
                _p53 += 1
                self._pos = _p53
                "_"
              end
              ["App", "_any"]
            rescue RuleFailure => ex
              self._pos = _p54
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.any", _start, ex)
      else
        _t = _memoize("MMetaParser.any", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'any'
      raise ex
    end
  end
  

  
  def wsdot
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.wsdot")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p56 = _pos
            begin
              begin  # '.'
                _p55 = _pos
                raise @error if _p55 + 1 > @chars.length
                raise @error unless @chars[_p55] == 46
                _p55 += 1
                self._pos = _p55
                "."
              end
              ["Dot"]
            rescue RuleFailure => ex
              self._pos = _p56
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.wsdot", _start, ex)
      else
        _t = _memoize("MMetaParser.wsdot", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'wsdot'
      raise ex
    end
  end
  

  
  def args
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      as = nil
      _t = _sretrieve("MMetaParser.args")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p60 = _pos
              begin
                begin  # '('
                  _p57 = _pos
                  raise @error if _p57 + 1 > @chars.length
                  raise @error unless @chars[_p57] == 40
                  _p57 += 1
                  self._pos = _p57
                  "("
                end
                begin
                  begin
                    _p59 = _pos
                    begin
                      as = (
                        begin
                          _push(["simplehost", ","].toArray)
                          self.listOf()
                        end
                      )
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      begin  # ')'
                        _p58 = _pos
                        raise @error if _p58 + 1 > @chars.length
                        raise @error unless @chars[_p58] == 41
                        _p58 += 1
                        self._pos = _p58
                        ")"
                      end
                      as
                    rescue RuleFailure => ex
                      self._pos = _p59
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p60
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p61 = _pos
              begin
                self.empty()
                ArrayList.new
              rescue RuleFailure => ex
                self._pos = _p61
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.args", _start, ex)
      else
        _t = _memoize("MMetaParser.args", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'args'
      raise ex
    end
  end
  

  
  def application
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      r = nil
      as = nil
      _t = _sretrieve("MMetaParser.application")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p64 = _pos
              begin
                begin  # 'super.'
                  _p62 = _pos
                  raise @error if _p62 + 6 > @chars.length
                  raise @error unless @chars[_p62] == 115
                  _p62 += 1
                  raise @error unless @chars[_p62] == 117
                  _p62 += 1
                  raise @error unless @chars[_p62] == 112
                  _p62 += 1
                  raise @error unless @chars[_p62] == 101
                  _p62 += 1
                  raise @error unless @chars[_p62] == 114
                  _p62 += 1
                  raise @error unless @chars[_p62] == 46
                  _p62 += 1
                  self._pos = _p62
                  "super."
                end
                begin
                  begin
                    _p63 = _pos
                    begin
                      r = (
                        self.name()
                      )
                      as = (
                        self.args()
                      )
                      concat(["App", "super", r], as)
                    rescue RuleFailure => ex
                      self._pos = _p63
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p64
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p65 = _pos
              begin
                r = (
                  self.name()
                )
                as = (
                  self.args()
                )
                concat(["App", r], as)
              rescue RuleFailure => ex
                self._pos = _p65
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.application", _start, ex)
      else
        _t = _memoize("MMetaParser.application", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'application'
      raise ex
    end
  end
  

  
  def fname
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      t = nil
      n = nil
      _t = _sretrieve("MMetaParser.fname")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p69 = _pos
            begin
              t = (
                begin
                  as68 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p67 = _pos
                          begin
                            x = (
                              self.name()
                            )
                            begin  # '.'
                              _p66 = _pos
                              raise @error if _p66 + 1 > @chars.length
                              raise @error unless @chars[_p66] == 46
                              _p66 += 1
                              self._pos = _p66
                              "."
                            end
                            "#{x}."
                          rescue RuleFailure => ex
                            self._pos = _p67
                            raise ex
                          end
                        end
                      )
                      as68.add(_li)
                    end
                  rescue RuleFailure; end
                  as68
                end
              )
              n = (
                self.name()
              )
              "#{join(t)}#{n}"
            rescue RuleFailure => ex
              self._pos = _p69
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.fname", _start, ex)
      else
        _t = _memoize("MMetaParser.fname", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'fname'
      raise ex
    end
  end
  

  
  def parens
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaParser.parens")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p74 = _pos
            begin
              begin  # '('
                _p70 = _pos
                raise @error if _p70 + 1 > @chars.length
                raise @error unless @chars[_p70] == 40
                _p70 += 1
                self._pos = _p70
                "("
              end
              x = (
                begin
                  as72 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          self.parens()
                        rescue RuleFailure
                          begin
                            _p71 = _pos
                            begin
                              begin  # not
                                begin
                                  _push(["()"].toArray)
                                  self.oneOf()
                                end
                                nil
                              rescue RuleFailure
                                nil  # expected
                              else
                                raise @error
                              end
                              self._any()
                            rescue RuleFailure => ex
                              self._pos = _p71
                              raise ex
                            end
                          end
                        end
                      )
                      as72.add(_li)
                    end
                  rescue RuleFailure; end
                  as72
                end
              )
              begin  # ')'
                _p73 = _pos
                raise @error if _p73 + 1 > @chars.length
                raise @error unless @chars[_p73] == 41
                _p73 += 1
                self._pos = _p73
                ")"
              end
              "(#{join(x)})"
            rescue RuleFailure => ex
              self._pos = _p74
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.parens", _start, ex)
      else
        _t = _memoize("MMetaParser.parens", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'parens'
      raise ex
    end
  end
  

  
  def rewrite_expr
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      n = nil
      p = nil
      c = nil
      cl = nil
      s = nil
      xs = nil
      _t = _sretrieve("MMetaParser.rewrite_expr")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p75 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                n = (
                  self.name()
                )
                p = (
                  self.parens()
                )
                ["HLit", "#{n}#{p}"]
              rescue RuleFailure => ex
                self._pos = _p75
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p78 = _pos
                begin
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  begin  # '^('
                    _p76 = _pos
                    raise @error if _p76 + 2 > @chars.length
                    raise @error unless @chars[_p76] == 94
                    _p76 += 1
                    raise @error unless @chars[_p76] == 40
                    _p76 += 1
                    self._pos = _p76
                    "^("
                  end
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  n = (
                    self.name()
                  )
                  c = (
                    self.rewrite_expr()
                  )
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  begin
                    _push(["*+"].toArray)
                    self.oneOf()
                  end
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  begin  # ')'
                    _p77 = _pos
                    raise @error if _p77 + 1 > @chars.length
                    raise @error unless @chars[_p77] == 41
                    _p77 += 1
                    self._pos = _p77
                    ")"
                  end
                  ["Node", n, c]
                rescue RuleFailure => ex
                  self._pos = _p78
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                begin
                  _p82 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin  # '^('
                      _p79 = _pos
                      raise @error if _p79 + 2 > @chars.length
                      raise @error unless @chars[_p79] == 94
                      _p79 += 1
                      raise @error unless @chars[_p79] == 40
                      _p79 += 1
                      self._pos = _p79
                      "^("
                    end
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    n = (
                      self.name()
                    )
                    cl = (
                      begin
                        as80 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.rewrite_expr()
                            )
                            as80.add(_li)
                          end
                        rescue RuleFailure; end
                        as80
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin  # ')'
                      _p81 = _pos
                      raise @error if _p81 + 1 > @chars.length
                      raise @error unless @chars[_p81] == 41
                      _p81 += 1
                      self._pos = _p81
                      ")"
                    end
                    ["Node", n, concat(["HList"], cl)]
                  rescue RuleFailure => ex
                    self._pos = _p82
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p84 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      begin  # '$'
                        _p83 = _pos
                        raise @error if _p83 + 1 > @chars.length
                        raise @error unless @chars[_p83] == 36
                        _p83 += 1
                        self._pos = _p83
                        "$"
                      end
                      n = (
                        self.name()
                      )
                      ["TLit", n]
                    rescue RuleFailure => ex
                      self._pos = _p84
                      raise ex
                    end
                  end
                rescue RuleFailure
                  begin
                    begin
                      _p85 = _pos
                      begin
                        if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                        s = (
                          self.tsString()
                        )
                        ["HStr", s]
                      rescue RuleFailure => ex
                        self._pos = _p85
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    begin
                      begin
                        _p86 = _pos
                        begin
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          n = (
                            self.name()
                          )
                          ["HLit", n]
                        rescue RuleFailure => ex
                          self._pos = _p86
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      begin
                        _p89 = _pos
                        begin
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          begin  # '['
                            _p87 = _pos
                            raise @error if _p87 + 1 > @chars.length
                            raise @error unless @chars[_p87] == 91
                            _p87 += 1
                            self._pos = _p87
                            "["
                          end
                          xs = (
                            begin
                              _push(["rewrite_expr", ","].toArray)
                              self.listOf()
                            end
                          )
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          begin  # ']'
                            _p88 = _pos
                            raise @error if _p88 + 1 > @chars.length
                            raise @error unless @chars[_p88] == 93
                            _p88 += 1
                            self._pos = _p88
                            "]"
                          end
                          concat(["HList"], xs)
                        rescue RuleFailure => ex
                          self._pos = _p89
                          raise ex
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rewrite_expr", _start, ex)
      else
        _t = _memoize("MMetaParser.rewrite_expr", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rewrite_expr'
      raise ex
    end
  end
  

  
  def simplehost
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      rs = nil
      ls = nil
      x = nil
      _t = _sretrieve("MMetaParser.simplehost")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p91 = _pos
              begin
                rs = (
                  self.simplehost1()
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                begin  # '+'
                  _p90 = _pos
                  raise @error if _p90 + 1 > @chars.length
                  raise @error unless @chars[_p90] == 43
                  _p90 += 1
                  self._pos = _p90
                  "+"
                end
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                ls = (
                  self.simplehost()
                )
                ["HConcat", rs, ls]
              rescue RuleFailure => ex
                self._pos = _p91
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p92 = _pos
              begin
                x = (
                  self.simplehost1()
                )
                x
              rescue RuleFailure => ex
                self._pos = _p92
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.simplehost", _start, ex)
      else
        _t = _memoize("MMetaParser.simplehost", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'simplehost'
      raise ex
    end
  end
  

  
  def simplehost1
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      num = nil
      s = nil
      n = nil
      _t = _sretrieve("MMetaParser.simplehost1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p95 = _pos
              begin
                begin  # '['
                  _p93 = _pos
                  raise @error if _p93 + 1 > @chars.length
                  raise @error unless @chars[_p93] == 91
                  _p93 += 1
                  self._pos = _p93
                  "["
                end
                xs = (
                  begin
                    _push(["simplehost", ","].toArray)
                    self.listOf()
                  end
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                begin  # ']'
                  _p94 = _pos
                  raise @error if _p94 + 1 > @chars.length
                  raise @error unless @chars[_p94] == 93
                  _p94 += 1
                  self._pos = _p94
                  "]"
                end
                concat(["HList"], xs)
              rescue RuleFailure => ex
                self._pos = _p95
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p96 = _pos
                begin
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  num = (
                    self.number()
                  )
                  num
                rescue RuleFailure => ex
                  self._pos = _p96
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                begin
                  _p99 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin
                      begin  # '''
                        _p97 = _pos
                        raise @error if _p97 + 1 > @chars.length
                        raise @error unless @chars[_p97] == 39
                        _p97 += 1
                        self._pos = _p97
                        "'"
                      end
                    rescue RuleFailure
                      begin  # ':'
                        _p98 = _pos
                        raise @error if _p98 + 1 > @chars.length
                        raise @error unless @chars[_p98] == 58
                        _p98 += 1
                        self._pos = _p98
                        ":"
                      end
                    end
                    s = (
                      self.name()
                    )
                    ["HStr", s]
                  rescue RuleFailure => ex
                    self._pos = _p99
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p100 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      s = (
                        self.tsString()
                      )
                      ["HStr", s]
                    rescue RuleFailure => ex
                      self._pos = _p100
                      raise ex
                    end
                  end
                rescue RuleFailure
                  begin
                    begin
                      _p102 = _pos
                      begin
                        if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                        begin  # '@'
                          _p101 = _pos
                          raise @error if _p101 + 1 > @chars.length
                          raise @error unless @chars[_p101] == 64
                          _p101 += 1
                          self._pos = _p101
                          "@"
                        end
                        n = (
                          self.name()
                        )
                        ["HLit", "@#{n}"]
                      rescue RuleFailure => ex
                        self._pos = _p102
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    begin
                      _p103 = _pos
                      begin
                        if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                        n = (
                          self.name()
                        )
                        ["HLit", n]
                      rescue RuleFailure => ex
                        self._pos = _p103
                        raise ex
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.simplehost1", _start, ex)
      else
        _t = _memoize("MMetaParser.simplehost1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'simplehost1'
      raise ex
    end
  end
  

  
  def cbraces
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaParser.cbraces")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p107 = _pos
              begin
                begin  # '{'
                  _p104 = _pos
                  raise @error if _p104 + 1 > @chars.length
                  raise @error unless @chars[_p104] == 123
                  _p104 += 1
                  self._pos = _p104
                  "{"
                end
                xs = (
                  begin
                    as105 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.cbraces()
                        )
                        as105.add(_li)
                      end
                    rescue RuleFailure; end
                    as105
                  end
                )
                begin  # '}'
                  _p106 = _pos
                  raise @error if _p106 + 1 > @chars.length
                  raise @error unless @chars[_p106] == 125
                  _p106 += 1
                  self._pos = _p106
                  "}"
                end
                begin
                   "{"+ join(xs) +"}" 
                end
              rescue RuleFailure => ex
                self._pos = _p107
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p109 = _pos
              begin
                begin  # not
                  begin  # '}'
                    _p108 = _pos
                    raise @error if _p108 + 1 > @chars.length
                    raise @error unless @chars[_p108] == 125
                    _p108 += 1
                    self._pos = _p108
                    "}"
                  end
                  nil
                rescue RuleFailure
                  nil  # expected
                else
                  raise @error
                end
                self._any()
              rescue RuleFailure => ex
                self._pos = _p109
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.cbraces", _start, ex)
      else
        _t = _memoize("MMetaParser.cbraces", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'cbraces'
      raise ex
    end
  end
  

  
  def semAction
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      s = nil
      xs = nil
      _t = _sretrieve("MMetaParser.semAction")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p112 = _pos
              begin
                begin  # '{'
                  _p110 = _pos
                  raise @error if _p110 + 1 > @chars.length
                  raise @error unless @chars[_p110] == 123
                  _p110 += 1
                  self._pos = _p110
                  "{"
                end
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                s = (
                  self.simplehost()
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                begin  # '}'
                  _p111 = _pos
                  raise @error if _p111 + 1 > @chars.length
                  raise @error unless @chars[_p111] == 125
                  _p111 += 1
                  self._pos = _p111
                  "}"
                end
                ["SAct", s]
              rescue RuleFailure => ex
                self._pos = _p112
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p117 = _pos
                begin
                  begin  # '{'
                    _p113 = _pos
                    raise @error if _p113 + 1 > @chars.length
                    raise @error unless @chars[_p113] == 123
                    _p113 += 1
                    self._pos = _p113
                    "{"
                  end
                  begin
                    begin
                      _p116 = _pos
                      begin
                        xs = (
                          begin
                            as114 = ArrayList.new
                            begin
                              while true do
                                _li = Object(
                                  self.cbraces()
                                )
                                as114.add(_li)
                              end
                            rescue RuleFailure; end
                            as114
                          end
                        )
                        begin  # '}'
                          _p115 = _pos
                          raise @error if _p115 + 1 > @chars.length
                          raise @error unless @chars[_p115] == 125
                          _p115 += 1
                          self._pos = _p115
                          "}"
                        end
                        ["Act", "#{join(xs)}"]
                      rescue RuleFailure => ex
                        self._pos = _p116
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p117
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                _p120 = _pos
                begin
                  begin  # '->'
                    _p118 = _pos
                    raise @error if _p118 + 2 > @chars.length
                    raise @error unless @chars[_p118] == 45
                    _p118 += 1
                    raise @error unless @chars[_p118] == 62
                    _p118 += 1
                    self._pos = _p118
                    "->"
                  end
                  begin
                    begin
                      _p119 = _pos
                      begin
                        s = (
                          self.rewrite_expr()
                        )
                        ["SAct", s]
                      rescue RuleFailure => ex
                        self._pos = _p119
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p120
                  raise ex
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.semAction", _start, ex)
      else
        _t = _memoize("MMetaParser.semAction", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'semAction'
      raise ex
    end
  end
  

  
  def semPred
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaParser.semPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p125 = _pos
            begin
              begin  # '?{'
                _p121 = _pos
                raise @error if _p121 + 2 > @chars.length
                raise @error unless @chars[_p121] == 63
                _p121 += 1
                raise @error unless @chars[_p121] == 123
                _p121 += 1
                self._pos = _p121
                "?{"
              end
              begin
                begin
                  _p124 = _pos
                  begin
                    xs = (
                      begin
                        as122 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.cbraces()
                            )
                            as122.add(_li)
                          end
                        rescue RuleFailure; end
                        as122
                      end
                    )
                    begin  # '}'
                      _p123 = _pos
                      raise @error if _p123 + 1 > @chars.length
                      raise @error unless @chars[_p123] == 125
                      _p123 += 1
                      self._pos = _p123
                      "}"
                    end
                    ["Pred", "#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p124
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p125
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.semPred", _start, ex)
      else
        _t = _memoize("MMetaParser.semPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'semPred'
      raise ex
    end
  end
  

  
  def synPred
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      p = nil
      e = nil
      t = nil
      _t = _sretrieve("MMetaParser.synPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p130 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin  # '('
                _p126 = _pos
                raise @error if _p126 + 1 > @chars.length
                raise @error unless @chars[_p126] == 40
                _p126 += 1
                self._pos = _p126
                "("
              end
              p = (
                self.expr()
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin  # ')'
                _p127 = _pos
                raise @error if _p127 + 1 > @chars.length
                raise @error unless @chars[_p127] == 41
                _p127 += 1
                self._pos = _p127
                ")"
              end
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin  # '=>'
                _p128 = _pos
                raise @error if _p128 + 2 > @chars.length
                raise @error unless @chars[_p128] == 61
                _p128 += 1
                raise @error unless @chars[_p128] == 62
                _p128 += 1
                self._pos = _p128
                "=>"
              end
              e = (
                self.expr4()
              )
              begin
                begin
                  _p129 = _pos
                  begin
                    t = (
                      self.synPredTail()
                    )
                    ["SynPred", ["Peek", p], e, t]
                  rescue RuleFailure => ex
                    self._pos = _p129
                    raise ex
                  end
                end
              rescue RuleFailure
                ["SynPred", ["Peek", p], e]
              end
            rescue RuleFailure => ex
              self._pos = _p130
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.synPred", _start, ex)
      else
        _t = _memoize("MMetaParser.synPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'synPred'
      raise ex
    end
  end
  

  
  def synPredTail
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.synPredTail")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p132 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin  # '|'
                _p131 = _pos
                raise @error if _p131 + 1 > @chars.length
                raise @error unless @chars[_p131] == 124
                _p131 += 1
                self._pos = _p131
                "|"
              end
              begin
                self.synPred()
              rescue RuleFailure
                self.expr4()
              end
            rescue RuleFailure => ex
              self._pos = _p132
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.synPredTail", _start, ex)
      else
        _t = _memoize("MMetaParser.synPredTail", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'synPredTail'
      raise ex
    end
  end
  

  
  def token
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      n = nil
      _t = _sretrieve("MMetaParser.token")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p134 = _pos
            begin
              begin  # '$'
                _p133 = _pos
                raise @error if _p133 + 1 > @chars.length
                raise @error unless @chars[_p133] == 36
                _p133 += 1
                self._pos = _p133
                "$"
              end
              n = (
                self.name()
              )
              n
            rescue RuleFailure => ex
              self._pos = _p134
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.token", _start, ex)
      else
        _t = _memoize("MMetaParser.token", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'token'
      raise ex
    end
  end
  

  
  def tokens
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      a = nil
      b = nil
      _t = _sretrieve("MMetaParser.tokens")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p137 = _pos
            begin
              a = (
                self.token()
              )
              begin
                begin
                  _p136 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin  # '..'
                      _p135 = _pos
                      raise @error if _p135 + 2 > @chars.length
                      raise @error unless @chars[_p135] == 46
                      _p135 += 1
                      raise @error unless @chars[_p135] == 46
                      _p135 += 1
                      self._pos = _p135
                      ".."
                    end
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    b = (
                      self.token()
                    )
                    ["TokenRange", a, b]
                  rescue RuleFailure => ex
                    self._pos = _p136
                    raise ex
                  end
                end
              rescue RuleFailure
                ["Token", a]
              end
            rescue RuleFailure => ex
              self._pos = _p137
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.tokens", _start, ex)
      else
        _t = _memoize("MMetaParser.tokens", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'tokens'
      raise ex
    end
  end
  

  
  def expr
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaParser.expr")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p138 = _pos
            begin
              xs = (
                begin
                  _push(["expr4", "|"].toArray)
                  self.listOf()
                end
              )
              concat(["Or"], xs)
            rescue RuleFailure => ex
              self._pos = _p138
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr", _start, ex)
      else
        _t = _memoize("MMetaParser.expr", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr'
      raise ex
    end
  end
  

  
  def expr4
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaParser.expr4")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p140 = _pos
            begin
              xs = (
                begin
                  as139 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          self.error()
                        rescue RuleFailure
                          self.expr3()
                        end
                      )
                      as139.add(_li)
                    end
                  rescue RuleFailure; end
                  as139
                end
              )
              concat(["And"], xs)
            rescue RuleFailure => ex
              self._pos = _p140
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr4", _start, ex)
      else
        _t = _memoize("MMetaParser.expr4", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr4'
      raise ex
    end
  end
  

  
  def optIter
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaParser.optIter")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p148 = _pos
            begin
              x = (
                self._any()
              )
              begin
                begin
                  _p142 = _pos
                  begin
                    begin  # '*'
                      _p141 = _pos
                      raise @error if _p141 + 1 > @chars.length
                      raise @error unless @chars[_p141] == 42
                      _p141 += 1
                      self._pos = _p141
                      "*"
                    end
                    ["Many", x]
                  rescue RuleFailure => ex
                    self._pos = _p142
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p144 = _pos
                    begin
                      begin  # '+'
                        _p143 = _pos
                        raise @error if _p143 + 1 > @chars.length
                        raise @error unless @chars[_p143] == 43
                        _p143 += 1
                        self._pos = _p143
                        "+"
                      end
                      ["Many1", x]
                    rescue RuleFailure => ex
                      self._pos = _p144
                      raise ex
                    end
                  end
                rescue RuleFailure
                  begin
                    begin
                      _p146 = _pos
                      begin
                        begin  # '?'
                          _p145 = _pos
                          raise @error if _p145 + 1 > @chars.length
                          raise @error unless @chars[_p145] == 63
                          _p145 += 1
                          self._pos = _p145
                          "?"
                        end
                        ["Opt", x]
                      rescue RuleFailure => ex
                        self._pos = _p146
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    begin
                      _p147 = _pos
                      begin
                        self.empty()
                        x
                      rescue RuleFailure => ex
                        self._pos = _p147
                        raise ex
                      end
                    end
                  end
                end
              end
            rescue RuleFailure => ex
              self._pos = _p148
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.optIter", _start, ex)
      else
        _t = _memoize("MMetaParser.optIter", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'optIter'
      raise ex
    end
  end
  

  
  def expr3
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      n = nil
      e = nil
      x = nil
      _t = _sretrieve("MMetaParser.expr3")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p151 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                n = (
                  self.name()
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                begin  # '='
                  _p149 = _pos
                  raise @error if _p149 + 1 > @chars.length
                  raise @error unless @chars[_p149] == 61
                  _p149 += 1
                  self._pos = _p149
                  "="
                end
                begin
                  begin
                    _p150 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      e = (
                        self.expr2()
                      )
                      x = (
                        begin
                          _push([e].toArray)
                          self.optIter()
                        end
                      )
                      ["Set", n, x]
                    rescue RuleFailure => ex
                      self._pos = _p150
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p151
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p152 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                e = (
                  self.expr2()
                )
                x = (
                  begin
                    _push([e].toArray)
                    self.optIter()
                  end
                )
                x
              rescue RuleFailure => ex
                self._pos = _p152
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr3", _start, ex)
      else
        _t = _memoize("MMetaParser.expr3", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr3'
      raise ex
    end
  end
  

  
  def expr2
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaParser.expr2")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p155 = _pos
              begin
                begin  # '~'
                  _p153 = _pos
                  raise @error if _p153 + 1 > @chars.length
                  raise @error unless @chars[_p153] == 126
                  _p153 += 1
                  self._pos = _p153
                  "~"
                end
                begin
                  begin
                    _p154 = _pos
                    begin
                      x = (
                        self.expr2()
                      )
                      ["Not", x]
                    rescue RuleFailure => ex
                      self._pos = _p154
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p155
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p158 = _pos
                begin
                  begin  # '&'
                    _p156 = _pos
                    raise @error if _p156 + 1 > @chars.length
                    raise @error unless @chars[_p156] == 38
                    _p156 += 1
                    self._pos = _p156
                    "&"
                  end
                  begin
                    begin
                      _p157 = _pos
                      begin
                        x = (
                          self.expr1()
                        )
                        ["Peek", x]
                      rescue RuleFailure => ex
                        self._pos = _p157
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p158
                  raise ex
                end
              end
            rescue RuleFailure
              self.expr1()
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr2", _start, ex)
      else
        _t = _memoize("MMetaParser.expr2", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr2'
      raise ex
    end
  end
  

  
  def expr1
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaParser.expr1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            self.wsdot()
          rescue RuleFailure
            begin
              self.any()
            rescue RuleFailure
              begin
                self.semPred()
              rescue RuleFailure
                begin
                  self.semAction()
                rescue RuleFailure
                  begin
                    self.application()
                  rescue RuleFailure
                    begin
                      self.tokens()
                    rescue RuleFailure
                      begin
                        begin
                          _p159 = _pos
                          begin
                            x = (
                              begin
                                begin
                                  _push(["null"].toArray)
                                  self.k()
                                end
                              rescue RuleFailure
                                begin
                                  begin
                                    _push(["true"].toArray)
                                    self.k()
                                  end
                                rescue RuleFailure
                                  begin
                                    _push(["false"].toArray)
                                    self.k()
                                  end
                                end
                              end
                            )
                            ["HLit", x]
                          rescue RuleFailure => ex
                            self._pos = _p159
                            raise ex
                          end
                        end
                      rescue RuleFailure
                        begin
                          self.string()
                        rescue RuleFailure
                          begin
                            self.symbol()
                          rescue RuleFailure
                            begin
                              self.number()
                            rescue RuleFailure
                              begin
                                begin
                                  _p163 = _pos
                                  begin
                                    begin  # '['
                                      _p160 = _pos
                                      raise @error if _p160 + 1 > @chars.length
                                      raise @error unless @chars[_p160] == 91
                                      _p160 += 1
                                      self._pos = _p160
                                      "["
                                    end
                                    begin
                                      begin
                                        _p162 = _pos
                                        begin
                                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                          x = (
                                            self.expr()
                                          )
                                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                          begin  # ']'
                                            _p161 = _pos
                                            raise @error if _p161 + 1 > @chars.length
                                            raise @error unless @chars[_p161] == 93
                                            _p161 += 1
                                            self._pos = _p161
                                            "]"
                                          end
                                          ["List", x]
                                        rescue RuleFailure => ex
                                          self._pos = _p162
                                          raise ex
                                        end
                                      end
                                    rescue RuleFailure
                                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                                    end
                                  rescue RuleFailure => ex
                                    self._pos = _p163
                                    raise ex
                                  end
                                end
                              rescue RuleFailure
                                begin
                                  self.synPred()
                                rescue RuleFailure
                                  begin
                                    _p167 = _pos
                                    begin
                                      begin  # '('
                                        _p164 = _pos
                                        raise @error if _p164 + 1 > @chars.length
                                        raise @error unless @chars[_p164] == 40
                                        _p164 += 1
                                        self._pos = _p164
                                        "("
                                      end
                                      begin
                                        begin
                                          _p166 = _pos
                                          begin
                                            if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                            x = (
                                              self.expr()
                                            )
                                            if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                            begin  # ')'
                                              _p165 = _pos
                                              raise @error if _p165 + 1 > @chars.length
                                              raise @error unless @chars[_p165] == 41
                                              _p165 += 1
                                              self._pos = _p165
                                              ")"
                                            end
                                            x
                                          rescue RuleFailure => ex
                                            self._pos = _p166
                                            raise ex
                                          end
                                        end
                                      rescue RuleFailure
                                        raise SyntaxError.new("", @error.last, _pos, _string, _list)
                                      end
                                    rescue RuleFailure => ex
                                      self._pos = _p167
                                      raise ex
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr1", _start, ex)
      else
        _t = _memoize("MMetaParser.expr1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr1'
      raise ex
    end
  end
  

  
  def annotation
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      t = nil
      l = nil
      _t = _sretrieve("MMetaParser.annotation")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p172 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                begin  # '$Memo'
                  _p168 = _pos
                  raise @error if _p168 + 5 > @chars.length
                  raise @error unless @chars[_p168] == 36
                  _p168 += 1
                  raise @error unless @chars[_p168] == 77
                  _p168 += 1
                  raise @error unless @chars[_p168] == 101
                  _p168 += 1
                  raise @error unless @chars[_p168] == 109
                  _p168 += 1
                  raise @error unless @chars[_p168] == 111
                  _p168 += 1
                  self._pos = _p168
                  "$Memo"
                end
                begin  # optional
                  begin
                    _p171 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      begin  # '['
                        _p169 = _pos
                        raise @error if _p169 + 1 > @chars.length
                        raise @error unless @chars[_p169] == 91
                        _p169 += 1
                        self._pos = _p169
                        "["
                      end
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      t = (
                        self.name()
                      )
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      begin  # ']'
                        _p170 = _pos
                        raise @error if _p170 + 1 > @chars.length
                        raise @error unless @chars[_p170] == 93
                        _p170 += 1
                        self._pos = _p170
                        "]"
                      end
                    rescue RuleFailure => ex
                      self._pos = _p171
                      raise ex
                    end
                  end
                rescue RuleFailure
                  nil
                end
                ["Memo", t]
              rescue RuleFailure => ex
                self._pos = _p172
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p177 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                begin  # '$Scope'
                  _p173 = _pos
                  raise @error if _p173 + 6 > @chars.length
                  raise @error unless @chars[_p173] == 36
                  _p173 += 1
                  raise @error unless @chars[_p173] == 83
                  _p173 += 1
                  raise @error unless @chars[_p173] == 99
                  _p173 += 1
                  raise @error unless @chars[_p173] == 111
                  _p173 += 1
                  raise @error unless @chars[_p173] == 112
                  _p173 += 1
                  raise @error unless @chars[_p173] == 101
                  _p173 += 1
                  self._pos = _p173
                  "$Scope"
                end
                begin
                  begin
                    _p176 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      begin  # '['
                        _p174 = _pos
                        raise @error if _p174 + 1 > @chars.length
                        raise @error unless @chars[_p174] == 91
                        _p174 += 1
                        self._pos = _p174
                        "["
                      end
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      l = (
                        begin
                          _push(["varname", ","].toArray)
                          self.listOf()
                        end
                      )
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      begin  # ']'
                        _p175 = _pos
                        raise @error if _p175 + 1 > @chars.length
                        raise @error unless @chars[_p175] == 93
                        _p175 += 1
                        self._pos = _p175
                        "]"
                      end
                      ["Scope", l]
                    rescue RuleFailure => ex
                      self._pos = _p176
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p177
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.annotation", _start, ex)
      else
        _t = _memoize("MMetaParser.annotation", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'annotation'
      raise ex
    end
  end
  

  
  def ruleArgs
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaParser.ruleArgs")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p183 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin  # '('
                _p178 = _pos
                raise @error if _p178 + 1 > @chars.length
                raise @error unless @chars[_p178] == 40
                _p178 += 1
                self._pos = _p178
                "("
              end
              begin
                begin
                  _p182 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    x = (
                      begin
                        as180 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin  # not
                                begin  # ')'
                                  _p179 = _pos
                                  raise @error if _p179 + 1 > @chars.length
                                  raise @error unless @chars[_p179] == 41
                                  _p179 += 1
                                  self._pos = _p179
                                  ")"
                                end
                                nil
                              rescue RuleFailure
                                nil  # expected
                              else
                                raise @error
                              end
                            )
                            as180.add(_li)
                          end
                        rescue RuleFailure; end
                        as180
                      end
                    )
                    begin  # ')'
                      _p181 = _pos
                      raise @error if _p181 + 1 > @chars.length
                      raise @error unless @chars[_p181] == 41
                      _p181 += 1
                      self._pos = _p181
                      ")"
                    end
                    "(#{join(x)})"
                  rescue RuleFailure => ex
                    self._pos = _p182
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p183
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ruleArgs", _start, ex)
      else
        _t = _memoize("MMetaParser.ruleArgs", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ruleArgs'
      raise ex
    end
  end
  

  
  def rule
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      a = nil
      n = nil
      args = nil
      x = nil
      _t = _sretrieve("MMetaParser.rule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p187 = _pos
            begin
              a = (
                begin
                  as184 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.annotation()
                      )
                      as184.add(_li)
                    end
                  rescue RuleFailure; end
                  as184
                end
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              n = (
                self.rulename()
              )
              begin
                begin
                  _p186 = _pos
                  begin
                    args = (
                      begin  # optional
                        self.ruleArgs()
                      rescue RuleFailure
                        nil
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    x = (
                      self.ruleStuff()
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin  # ';'
                      _p185 = _pos
                      raise @error if _p185 + 1 > @chars.length
                      raise @error unless @chars[_p185] == 59
                      _p185 += 1
                      self._pos = _p185
                      ";"
                    end
                    ["Rule", n, args, x, a]
                  rescue RuleFailure => ex
                    self._pos = _p186
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p187
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rule", _start, ex)
      else
        _t = _memoize("MMetaParser.rule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rule'
      raise ex
    end
  end
  

  
  def ruleStuff
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      b1 = nil
      b2 = nil
      _t = _sretrieve("MMetaParser.ruleStuff")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p192 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              b1 = (
                self.expr4()
              )
              begin
                begin
                  _p190 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin  # ':'
                      _p188 = _pos
                      raise @error if _p188 + 1 > @chars.length
                      raise @error unless @chars[_p188] == 58
                      _p188 += 1
                      self._pos = _p188
                      ":"
                    end
                    begin
                      begin
                        _p189 = _pos
                        begin
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          b2 = (
                            self.expr()
                          )
                          ["And", b1, b2]
                        rescue RuleFailure => ex
                          self._pos = _p189
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p190
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  _p191 = _pos
                  begin
                    self.empty()
                    b1
                  rescue RuleFailure => ex
                    self._pos = _p191
                    raise ex
                  end
                end
              end
            rescue RuleFailure => ex
              self._pos = _p192
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ruleStuff", _start, ex)
      else
        _t = _memoize("MMetaParser.ruleStuff", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ruleStuff'
      raise ex
    end
  end
  

  
  def qualifiers
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      qs = nil
      _t = _sretrieve("MMetaParser.qualifiers")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p199 = _pos
            begin
              qs = (
                begin
                  as198 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          begin
                            _p193 = _pos
                            begin
                              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                              begin
                                _push(["public"].toArray)
                                self.k()
                              end
                            rescue RuleFailure => ex
                              self._pos = _p193
                              raise ex
                            end
                          end
                        rescue RuleFailure
                          begin
                            begin
                              _p194 = _pos
                              begin
                                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                begin
                                  _push(["private"].toArray)
                                  self.k()
                                end
                              rescue RuleFailure => ex
                                self._pos = _p194
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            begin
                              begin
                                _p195 = _pos
                                begin
                                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                  begin
                                    _push(["final"].toArray)
                                    self.k()
                                  end
                                rescue RuleFailure => ex
                                  self._pos = _p195
                                  raise ex
                                end
                              end
                            rescue RuleFailure
                              begin
                                begin
                                  _p196 = _pos
                                  begin
                                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                    begin
                                      _push(["static"].toArray)
                                      self.k()
                                    end
                                  rescue RuleFailure => ex
                                    self._pos = _p196
                                    raise ex
                                  end
                                end
                              rescue RuleFailure
                                begin
                                  _p197 = _pos
                                  begin
                                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                    begin
                                      _push(["abstract"].toArray)
                                      self.k()
                                    end
                                  rescue RuleFailure => ex
                                    self._pos = _p197
                                    raise ex
                                  end
                                end
                              end
                            end
                          end
                        end
                      )
                      as198.add(_li)
                    end
                  rescue RuleFailure; end
                  raise @error if as198.size == 0
                  as198
                end
              )
              begin
                
                        join(qs, " ")
                    
              end
            rescue RuleFailure => ex
              self._pos = _p199
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.qualifiers", _start, ex)
      else
        _t = _memoize("MMetaParser.qualifiers", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'qualifiers'
      raise ex
    end
  end
  

  
  def method
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      s = nil
      n = nil
      as = nil
      bs = nil
      _t = _sretrieve("MMetaParser.method")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p214 = _pos
            begin
              begin  # 'def'
                _p200 = _pos
                raise @error if _p200 + 3 > @chars.length
                raise @error unless @chars[_p200] == 100
                _p200 += 1
                raise @error unless @chars[_p200] == 101
                _p200 += 1
                raise @error unless @chars[_p200] == 102
                _p200 += 1
                self._pos = _p200
                "def"
              end
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              s = (
                begin
                  begin  # 'self.'
                    _p201 = _pos
                    raise @error if _p201 + 5 > @chars.length
                    raise @error unless @chars[_p201] == 115
                    _p201 += 1
                    raise @error unless @chars[_p201] == 101
                    _p201 += 1
                    raise @error unless @chars[_p201] == 108
                    _p201 += 1
                    raise @error unless @chars[_p201] == 102
                    _p201 += 1
                    raise @error unless @chars[_p201] == 46
                    _p201 += 1
                    self._pos = _p201
                    "self."
                  end
                rescue RuleFailure
                  ""
                end
              )
              begin
                begin
                  _p213 = _pos
                  begin
                    n = (
                      self.name()
                    )
                    begin
                      begin
                        _p212 = _pos
                        begin
                          begin
                            begin
                              _p207 = _pos
                              begin
                                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                begin  # '('
                                  _p202 = _pos
                                  raise @error if _p202 + 1 > @chars.length
                                  raise @error unless @chars[_p202] == 40
                                  _p202 += 1
                                  self._pos = _p202
                                  "("
                                end
                                as = (
                                  begin
                                    as205 = ArrayList.new
                                    begin
                                      while true do
                                        _li = Object(
                                          begin
                                            _p204 = _pos
                                            begin
                                              begin  # not
                                                begin  # ')'
                                                  _p203 = _pos
                                                  raise @error if _p203 + 1 > @chars.length
                                                  raise @error unless @chars[_p203] == 41
                                                  _p203 += 1
                                                  self._pos = _p203
                                                  ")"
                                                end
                                                nil
                                              rescue RuleFailure
                                                nil  # expected
                                              else
                                                raise @error
                                              end
                                              self._any()
                                            rescue RuleFailure => ex
                                              self._pos = _p204
                                              raise ex
                                            end
                                          end
                                        )
                                        as205.add(_li)
                                      end
                                    rescue RuleFailure; end
                                    as205
                                  end
                                )
                                begin  # ')'
                                  _p206 = _pos
                                  raise @error if _p206 + 1 > @chars.length
                                  raise @error unless @chars[_p206] == 41
                                  _p206 += 1
                                  self._pos = _p206
                                  ")"
                                end
                              rescue RuleFailure => ex
                                self._pos = _p207
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            ""
                          end
                          begin
                            begin
                              _p211 = _pos
                              begin
                                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                begin  # '{'
                                  _p208 = _pos
                                  raise @error if _p208 + 1 > @chars.length
                                  raise @error unless @chars[_p208] == 123
                                  _p208 += 1
                                  self._pos = _p208
                                  "{"
                                end
                                bs = (
                                  begin
                                    as209 = ArrayList.new
                                    begin
                                      while true do
                                        _li = Object(
                                          self.cbraces()
                                        )
                                        as209.add(_li)
                                      end
                                    rescue RuleFailure; end
                                    as209
                                  end
                                )
                                begin  # '}'
                                  _p210 = _pos
                                  raise @error if _p210 + 1 > @chars.length
                                  raise @error unless @chars[_p210] == 125
                                  _p210 += 1
                                  self._pos = _p210
                                  "}"
                                end
                                ["Method", "#{s}#{n}", "#{join(as)}", "#{join(bs)}"]
                              rescue RuleFailure => ex
                                self._pos = _p211
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            raise SyntaxError.new("", @error.last, _pos, _string, _list)
                          end
                        rescue RuleFailure => ex
                          self._pos = _p212
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p213
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p214
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.method", _start, ex)
      else
        _t = _memoize("MMetaParser.method", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'method'
      raise ex
    end
  end
  

  
  def jimport
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      stm = nil
      xs = nil
      _t = _sretrieve("MMetaParser.jimport")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p219 = _pos
            begin
              stm = (
                begin
                  _push(["import"].toArray)
                  self.k()
                end
              )
              begin
                begin
                  _p218 = _pos
                  begin
                    xs = (
                      begin
                        as216 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p215 = _pos
                                begin
                                  begin  # not
                                    begin
                                      _push([";\n"].toArray)
                                      self.oneOf()
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p215
                                  raise ex
                                end
                              end
                            )
                            as216.add(_li)
                          end
                        rescue RuleFailure; end
                        as216
                      end
                    )
                    begin  # optional
                      begin  # ';'
                        _p217 = _pos
                        raise @error if _p217 + 1 > @chars.length
                        raise @error unless @chars[_p217] == 59
                        _p217 += 1
                        self._pos = _p217
                        ";"
                      end
                    rescue RuleFailure
                      nil
                    end
                    ["Import", "#{stm}#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p218
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p219
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.jimport", _start, ex)
      else
        _t = _memoize("MMetaParser.jimport", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'jimport'
      raise ex
    end
  end
  

  
  def jpackage
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      stm = nil
      xs = nil
      _t = _sretrieve("MMetaParser.jpackage")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p224 = _pos
            begin
              stm = (
                begin
                  _push(["package"].toArray)
                  self.k()
                end
              )
              begin
                begin
                  _p223 = _pos
                  begin
                    xs = (
                      begin
                        as221 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p220 = _pos
                                begin
                                  begin  # not
                                    begin
                                      _push([";\n"].toArray)
                                      self.oneOf()
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p220
                                  raise ex
                                end
                              end
                            )
                            as221.add(_li)
                          end
                        rescue RuleFailure; end
                        as221
                      end
                    )
                    begin  # optional
                      begin  # ';'
                        _p222 = _pos
                        raise @error if _p222 + 1 > @chars.length
                        raise @error unless @chars[_p222] == 59
                        _p222 += 1
                        self._pos = _p222
                        ";"
                      end
                    rescue RuleFailure
                      nil
                    end
                    ["Package", "#{stm}#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p223
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p224
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.jpackage", _start, ex)
      else
        _t = _memoize("MMetaParser.jpackage", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'jpackage'
      raise ex
    end
  end
  

  
  def classdef
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      q = nil
      xs = nil
      bs = nil
      _t = _sretrieve("MMetaParser.classdef")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p232 = _pos
            begin
              q = (
                self.qualifiers()
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin
                _push(["class"].toArray)
                self.k()
              end
              begin
                begin
                  _p231 = _pos
                  begin
                    xs = (
                      begin
                        as227 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p226 = _pos
                                begin
                                  begin  # not
                                    begin  # '{'
                                      _p225 = _pos
                                      raise @error if _p225 + 1 > @chars.length
                                      raise @error unless @chars[_p225] == 123
                                      _p225 += 1
                                      self._pos = _p225
                                      "{"
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p226
                                  raise ex
                                end
                              end
                            )
                            as227.add(_li)
                          end
                        rescue RuleFailure; end
                        as227
                      end
                    )
                    begin  # '{'
                      _p228 = _pos
                      raise @error if _p228 + 1 > @chars.length
                      raise @error unless @chars[_p228] == 123
                      _p228 += 1
                      self._pos = _p228
                      "{"
                    end
                    bs = (
                      begin
                        as229 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.cbraces()
                            )
                            as229.add(_li)
                          end
                        rescue RuleFailure; end
                        as229
                      end
                    )
                    begin  # '}'
                      _p230 = _pos
                      raise @error if _p230 + 1 > @chars.length
                      raise @error unless @chars[_p230] == 125
                      _p230 += 1
                      self._pos = _p230
                      "}"
                    end
                    ["Class", q, " class #{join(xs)}", "#{join(bs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p231
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p232
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.classdef", _start, ex)
      else
        _t = _memoize("MMetaParser.classdef", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'classdef'
      raise ex
    end
  end
  

  
  def ruleMethod
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.ruleMethod")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p233 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                self.method()
              rescue RuleFailure => ex
                self._pos = _p233
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p234 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                self.rule()
              rescue RuleFailure => ex
                self._pos = _p234
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ruleMethod", _start, ex)
      else
        _t = _memoize("MMetaParser.ruleMethod", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ruleMethod'
      raise ex
    end
  end
  

  
  def parser
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      p = nil
      n = nil
      sn = nil
      rs = nil
      _t = _sretrieve("MMetaParser.parser")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p243 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              p = (
                begin
                  begin
                    _push(["public"].toArray)
                    self.k()
                  end
                rescue RuleFailure
                  self.empty()
                end
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              begin
                _push(["parser"].toArray)
                self.k()
              end
              begin
                begin
                  _p242 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    n = (
                      self.name()
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    sn = (
                      begin
                        begin
                          _p237 = _pos
                          begin
                            begin
                              begin
                                _push(["extends"].toArray)
                                self.k()
                              end
                            rescue RuleFailure
                              begin
                                _p236 = _pos
                                begin
                                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                  begin  # '<'
                                    _p235 = _pos
                                    raise @error if _p235 + 1 > @chars.length
                                    raise @error unless @chars[_p235] == 60
                                    _p235 += 1
                                    self._pos = _p235
                                    "<"
                                  end
                                rescue RuleFailure => ex
                                  self._pos = _p236
                                  raise ex
                                end
                              end
                            end
                            if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                            self.name()
                          rescue RuleFailure => ex
                            self._pos = _p237
                            raise ex
                          end
                        end
                      rescue RuleFailure
                        begin
                          _p238 = _pos
                          begin
                            self.empty()
                            "BaseParser"
                          rescue RuleFailure => ex
                            self._pos = _p238
                            raise ex
                          end
                        end
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin  # '{'
                      _p239 = _pos
                      raise @error if _p239 + 1 > @chars.length
                      raise @error unless @chars[_p239] == 123
                      _p239 += 1
                      self._pos = _p239
                      "{"
                    end
                    rs = (
                      begin
                        as240 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.ruleMethod()
                            )
                            as240.add(_li)
                          end
                        rescue RuleFailure; end
                        as240
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin  # '}'
                      _p241 = _pos
                      raise @error if _p241 + 1 > @chars.length
                      raise @error unless @chars[_p241] == 125
                      _p241 += 1
                      self._pos = _p241
                      "}"
                    end
                    p = (
                      concat(["Parser", p, n, sn], rs)
                    )
                    begin
                      begin
                        
                                           if (Boolean.getBoolean("mmeta.optimize.debug"))
                                             System.out.println("Before:\n" + BaseParser.print_r(p));
                                           end
                                           MMetaOptimizer.new().parse(p, "optimizeGrammar");
                                        
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p242
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p243
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.parser", _start, ex)
      else
        _t = _memoize("MMetaParser.parser", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'parser'
      raise ex
    end
  end
  

  
  def line
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      p = nil
      l = nil
      _t = _sretrieve("MMetaParser.line")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p244 = _pos
            begin
              p = (
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              )
              l = (
                begin
                  self.parser()
                rescue RuleFailure
                  begin
                    self.jpackage()
                  rescue RuleFailure
                    begin
                      self.jimport()
                    rescue RuleFailure
                      self.classdef()
                    end
                  end
                end
              )
              ["Line", "#{join(p)}", l]
            rescue RuleFailure => ex
              self._pos = _p244
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.line", _start, ex)
      else
        _t = _memoize("MMetaParser.line", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'line'
      raise ex
    end
  end
  

  
  def file
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      ls = nil
      _t = _sretrieve("MMetaParser.file")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p246 = _pos
              begin
                ls = (
                  begin
                    as245 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.line()
                        )
                        as245.add(_li)
                      end
                    rescue RuleFailure; end
                    as245
                  end
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                self.end()
                concat(["File"], ls)
              rescue RuleFailure => ex
                self._pos = _p246
                raise ex
              end
            end
          rescue RuleFailure
            raise SyntaxError.new("", @error.last, _pos, _string, _list)
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.file", _start, ex)
      else
        _t = _memoize("MMetaParser.file", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'file'
      raise ex
    end
  end
  

  
  def start
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaParser.start")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          self.file()
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.start", _start, ex)
      else
        _t = _memoize("MMetaParser.start", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'start'
      raise ex
    end
  end
  


  def _jump(r:String)
    return fromTo() if (r == "fromTo")
    return sp() if (r == "sp")
    return ws() if (r == "ws")
    return listOf() if (r == "listOf")
    return nameFirst() if (r == "nameFirst")
    return nameRest() if (r == "nameRest")
    return name() if (r == "name")
    return rulename() if (r == "rulename")
    return varname() if (r == "varname")
    return hex() if (r == "hex")
    return echar() if (r == "echar")
    return tsString() if (r == "tsString")
    return dollar() if (r == "dollar")
    return dollarstring() if (r == "dollarstring")
    return string() if (r == "string")
    return number() if (r == "number")
    return symbol() if (r == "symbol")
    return k() if (r == "k")
    return error() if (r == "error")
    return any() if (r == "any")
    return wsdot() if (r == "wsdot")
    return args() if (r == "args")
    return application() if (r == "application")
    return fname() if (r == "fname")
    return parens() if (r == "parens")
    return rewrite_expr() if (r == "rewrite_expr")
    return simplehost() if (r == "simplehost")
    return simplehost1() if (r == "simplehost1")
    return cbraces() if (r == "cbraces")
    return semAction() if (r == "semAction")
    return semPred() if (r == "semPred")
    return synPred() if (r == "synPred")
    return synPredTail() if (r == "synPredTail")
    return token() if (r == "token")
    return tokens() if (r == "tokens")
    return expr() if (r == "expr")
    return expr4() if (r == "expr4")
    return optIter() if (r == "optIter")
    return expr3() if (r == "expr3")
    return expr2() if (r == "expr2")
    return expr1() if (r == "expr1")
    return annotation() if (r == "annotation")
    return ruleArgs() if (r == "ruleArgs")
    return rule() if (r == "rule")
    return ruleStuff() if (r == "ruleStuff")
    return qualifiers() if (r == "qualifiers")
    return method() if (r == "method")
    return jimport() if (r == "jimport")
    return jpackage() if (r == "jpackage")
    return classdef() if (r == "classdef")
    return ruleMethod() if (r == "ruleMethod")
    return parser() if (r == "parser")
    return line() if (r == "line")
    return file() if (r == "file")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "fromTo")
    return true if (r == "sp")
    return true if (r == "ws")
    return true if (r == "listOf")
    return true if (r == "nameFirst")
    return true if (r == "nameRest")
    return true if (r == "name")
    return true if (r == "rulename")
    return true if (r == "varname")
    return true if (r == "hex")
    return true if (r == "echar")
    return true if (r == "tsString")
    return true if (r == "dollar")
    return true if (r == "dollarstring")
    return true if (r == "string")
    return true if (r == "number")
    return true if (r == "symbol")
    return true if (r == "k")
    return true if (r == "error")
    return true if (r == "any")
    return true if (r == "wsdot")
    return true if (r == "args")
    return true if (r == "application")
    return true if (r == "fname")
    return true if (r == "parens")
    return true if (r == "rewrite_expr")
    return true if (r == "simplehost")
    return true if (r == "simplehost1")
    return true if (r == "cbraces")
    return true if (r == "semAction")
    return true if (r == "semPred")
    return true if (r == "synPred")
    return true if (r == "synPredTail")
    return true if (r == "token")
    return true if (r == "tokens")
    return true if (r == "expr")
    return true if (r == "expr4")
    return true if (r == "optIter")
    return true if (r == "expr3")
    return true if (r == "expr2")
    return true if (r == "expr1")
    return true if (r == "annotation")
    return true if (r == "ruleArgs")
    return true if (r == "rule")
    return true if (r == "ruleStuff")
    return true if (r == "qualifiers")
    return true if (r == "method")
    return true if (r == "jimport")
    return true if (r == "jpackage")
    return true if (r == "classdef")
    return true if (r == "ruleMethod")
    return true if (r == "parser")
    return true if (r == "line")
    return true if (r == "file")
    return true if (r == "start")
    super(r)
  end
end

class MMetaPass < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  def init()
    
        @changed = false
      
  end
  

  def changed()
    
        @changed
      
  end
  

  def changed_set(value:boolean)
    
        @changed = value
      
  end
  

  
  def setChanged
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      _t = _sretrieve("MMetaPass.setChanged")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            @changed = true; nil;
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.setChanged", _start, ex)
      else
        _t = _memoize("MMetaPass.setChanged", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'setChanged'
      raise ex
    end
  end
  

  
  def destruct
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      r = nil
      x = nil
      _t = _sretrieve("MMetaPass.destruct")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p248 = _pos
            begin
              r = (
                self._any()
              )
              raise @error unless ( hasRule(r) )
              begin
                begin
                  _p247 = _pos
                  begin
                    x = (
                      begin
                        _push([r].toArray)
                        self.apply()
                      end
                    )
                    self.end()
                    x
                  rescue RuleFailure => ex
                    self._pos = _p247
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p248
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.destruct", _start, ex)
      else
        _t = _memoize("MMetaPass.destruct", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'destruct'
      raise ex
    end
  end
  

  
  def trans
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaPass.trans")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p249 = _pos
              begin
                begin
                  _t = _listBegin()
                  begin
                    x = (
                      self.destruct()
                    )
                  ensure
                    _listEnd()
                  end
                end
                x
              rescue RuleFailure => ex
                self._pos = _p249
                raise ex
              end
            end
          rescue RuleFailure
            self._any()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.trans", _start, ex)
      else
        _t = _memoize("MMetaPass.trans", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'trans'
      raise ex
    end
  end
  

  
  def Or
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaPass.Or")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p251 = _pos
            begin
              xs = (
                begin
                  as250 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as250.add(_li)
                    end
                  rescue RuleFailure; end
                  as250
                end
              )
              concat(["Or"], xs)
            rescue RuleFailure => ex
              self._pos = _p251
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Or", _start, ex)
      else
        _t = _memoize("MMetaPass.Or", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Or'
      raise ex
    end
  end
  

  
  def And
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaPass.And")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p253 = _pos
            begin
              xs = (
                begin
                  as252 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as252.add(_li)
                    end
                  rescue RuleFailure; end
                  as252
                end
              )
              concat(["And"], xs)
            rescue RuleFailure => ex
              self._pos = _p253
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.And", _start, ex)
      else
        _t = _memoize("MMetaPass.And", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'And'
      raise ex
    end
  end
  

  
  def Not
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaPass.Not")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p254 = _pos
            begin
              x = (
                self.trans()
              )
              ["Not", x]
            rescue RuleFailure => ex
              self._pos = _p254
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Not", _start, ex)
      else
        _t = _memoize("MMetaPass.Not", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Not'
      raise ex
    end
  end
  

  
  def Many
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaPass.Many")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p255 = _pos
            begin
              x = (
                self.trans()
              )
              ["Many", x]
            rescue RuleFailure => ex
              self._pos = _p255
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Many", _start, ex)
      else
        _t = _memoize("MMetaPass.Many", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Many'
      raise ex
    end
  end
  

  
  def Many1
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaPass.Many1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p256 = _pos
            begin
              x = (
                self.trans()
              )
              ["Many1", x]
            rescue RuleFailure => ex
              self._pos = _p256
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Many1", _start, ex)
      else
        _t = _memoize("MMetaPass.Many1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Many1'
      raise ex
    end
  end
  

  
  def Peek
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaPass.Peek")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p257 = _pos
            begin
              x = (
                self.trans()
              )
              ["Peek", x]
            rescue RuleFailure => ex
              self._pos = _p257
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Peek", _start, ex)
      else
        _t = _memoize("MMetaPass.Peek", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Peek'
      raise ex
    end
  end
  

  
  def List
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      _t = _sretrieve("MMetaPass.List")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p258 = _pos
            begin
              x = (
                self.trans()
              )
              ["List", x]
            rescue RuleFailure => ex
              self._pos = _p258
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.List", _start, ex)
      else
        _t = _memoize("MMetaPass.List", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'List'
      raise ex
    end
  end
  

  
  def Set
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      n = nil
      x = nil
      _t = _sretrieve("MMetaPass.Set")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p259 = _pos
            begin
              n = (
                self._any()
              )
              x = (
                self.trans()
              )
              ["Set", n, x]
            rescue RuleFailure => ex
              self._pos = _p259
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Set", _start, ex)
      else
        _t = _memoize("MMetaPass.Set", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Set'
      raise ex
    end
  end
  

  
  def Rule
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      n = nil
      args = nil
      x = nil
      anno = nil
      _t = _sretrieve("MMetaPass.Rule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p260 = _pos
            begin
              n = (
                self._any()
              )
              args = (
                self._any()
              )
              x = (
                self.trans()
              )
              anno = (
                self._any()
              )
              ["Rule", n, args, x, anno]
            rescue RuleFailure => ex
              self._pos = _p260
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Rule", _start, ex)
      else
        _t = _memoize("MMetaPass.Rule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Rule'
      raise ex
    end
  end
  

  
  def SynPred
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      xs = nil
      _t = _sretrieve("MMetaPass.SynPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p262 = _pos
            begin
              xs = (
                begin
                  as261 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as261.add(_li)
                    end
                  rescue RuleFailure; end
                  as261
                end
              )
              concat(["SynPred"], xs)
            rescue RuleFailure => ex
              self._pos = _p262
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.SynPred", _start, ex)
      else
        _t = _memoize("MMetaPass.SynPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'SynPred'
      raise ex
    end
  end
  

  
  def Error
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      m = nil
      x = nil
      _t = _sretrieve("MMetaPass.Error")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p263 = _pos
            begin
              m = (
                self._any()
              )
              x = (
                self.trans()
              )
              ["Error", m, x]
            rescue RuleFailure => ex
              self._pos = _p263
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Error", _start, ex)
      else
        _t = _memoize("MMetaPass.Error", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Error'
      raise ex
    end
  end
  

  
  def start
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      r = nil
      _t = _sretrieve("MMetaPass.start")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p264 = _pos
              begin
                r = (
                  self.destruct()
                )
                self.end()
                r
              rescue RuleFailure => ex
                self._pos = _p264
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p265 = _pos
                begin
                  r = (
                    self._any()
                  )
                  self.end()
                  r
                rescue RuleFailure => ex
                  self._pos = _p265
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                _p267 = _pos
                begin
                  r = (
                    begin
                      as266 = ArrayList.new
                      begin
                        while true do
                          _li = Object(
                            self._any()
                          )
                          as266.add(_li)
                        end
                      rescue RuleFailure; end
                      as266
                    end
                  )
                  self.end()
                  r
                rescue RuleFailure => ex
                  self._pos = _p267
                  raise ex
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.start", _start, ex)
      else
        _t = _memoize("MMetaPass.start", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'start'
      raise ex
    end
  end
  


  def _jump(r:String)
    return setChanged() if (r == "setChanged")
    return destruct() if (r == "destruct")
    return trans() if (r == "trans")
    return Or() if (r == "Or")
    return And() if (r == "And")
    return Not() if (r == "Not")
    return Many() if (r == "Many")
    return Many1() if (r == "Many1")
    return Peek() if (r == "Peek")
    return List() if (r == "List")
    return Set() if (r == "Set")
    return Rule() if (r == "Rule")
    return SynPred() if (r == "SynPred")
    return Error() if (r == "Error")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "setChanged")
    return true if (r == "destruct")
    return true if (r == "trans")
    return true if (r == "Or")
    return true if (r == "And")
    return true if (r == "Not")
    return true if (r == "Many")
    return true if (r == "Many1")
    return true if (r == "Peek")
    return true if (r == "List")
    return true if (r == "Set")
    return true if (r == "Rule")
    return true if (r == "SynPred")
    return true if (r == "Error")
    return true if (r == "start")
    super(r)
  end
end

class MMetaAndOrOpt < MMetaPass
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  
  def And
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      xs = nil
      _t = _sretrieve("MMetaAndOrOpt.And")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p268 = _pos
              begin
                x = (
                  self.trans()
                )
                self.end()
                self.setChanged()
                x
              rescue RuleFailure => ex
                self._pos = _p268
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p269 = _pos
              begin
                xs = (
                  begin
                    _push(["And"].toArray)
                    self.transInside()
                  end
                )
                self.end()
                concat(["And"], xs)
              rescue RuleFailure => ex
                self._pos = _p269
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaAndOrOpt.And", _start, ex)
      else
        _t = _memoize("MMetaAndOrOpt.And", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'And'
      raise ex
    end
  end
  

  
  def Or
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      x = nil
      xs = nil
      _t = _sretrieve("MMetaAndOrOpt.Or")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p270 = _pos
              begin
                x = (
                  self.trans()
                )
                self.end()
                self.setChanged()
                x
              rescue RuleFailure => ex
                self._pos = _p270
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p271 = _pos
              begin
                xs = (
                  begin
                    _push(["Or"].toArray)
                    self.transInside()
                  end
                )
                self.end()
                concat(["Or"], xs)
              rescue RuleFailure => ex
                self._pos = _p271
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaAndOrOpt.Or", _start, ex)
      else
        _t = _memoize("MMetaAndOrOpt.Or", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Or'
      raise ex
    end
  end
  

  
  def transInside
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      s = nil
      xs = nil
      ys = nil
      x = nil
      _t = _sretrieve("MMetaAndOrOpt.transInside")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p275 = _pos
            begin
              s = (
                self._any()
              )
              begin
                begin
                  _p273 = _pos
                  begin
                    begin
                      _t = _listBegin()
                      begin
                        begin
                          _p272 = _pos
                          begin
                            begin
                              _push([s].toArray)
                              self.sym()
                            end
                            xs = (
                              begin
                                _push([s].toArray)
                                self.transInside()
                              end
                            )
                          rescue RuleFailure => ex
                            self._pos = _p272
                            raise ex
                          end
                        end
                      ensure
                        _listEnd()
                      end
                    end
                    ys = (
                      begin
                        _push([s].toArray)
                        self.transInside()
                      end
                    )
                    self.setChanged()
                    concat(xs, ys)
                  rescue RuleFailure => ex
                    self._pos = _p273
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p274 = _pos
                    begin
                      x = (
                        self.trans()
                      )
                      xs = (
                        begin
                          _push([s].toArray)
                          self.transInside()
                        end
                      )
                      concat([x], xs)
                    rescue RuleFailure => ex
                      self._pos = _p274
                      raise ex
                    end
                  end
                rescue RuleFailure
                  ArrayList.new
                end
              end
            rescue RuleFailure => ex
              self._pos = _p275
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaAndOrOpt.transInside", _start, ex)
      else
        _t = _memoize("MMetaAndOrOpt.transInside", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'transInside'
      raise ex
    end
  end
  


  def _jump(r:String)
    return And() if (r == "And")
    return Or() if (r == "Or")
    return transInside() if (r == "transInside")
    super(r)
  end

  def _has(r:String)
    return true if (r == "And")
    return true if (r == "Or")
    return true if (r == "transInside")
    super(r)
  end
end

class MMetaOptimizer < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  
  def optimizeGrammar
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      p = nil
      n = nil
      sn = nil
      rs = nil
      x = nil
      _t = _sretrieve("MMetaOptimizer.optimizeGrammar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p277 = _pos
              begin
                _sym("Parser")
                p = (
                  self._any()
                )
                n = (
                  self._any()
                )
                sn = (
                  self._any()
                )
                rs = (
                  begin
                    as276 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.optimizeRule()
                        )
                        as276.add(_li)
                      end
                    rescue RuleFailure; end
                    as276
                  end
                )
                self.end()
                x = (
                  concat(["Parser", p, n, sn], rs)
                )
                begin
                  
                                         if (Boolean.getBoolean("mmeta.optimize.debug"))
                                           System.out.println("Opt:\n" + BaseParser.print_r(x))
                                         end
                                         x
                                       
                end
              rescue RuleFailure => ex
                self._pos = _p277
                raise ex
              end
            end
          rescue RuleFailure
            raise SyntaxError.new("", @error.last, _pos, _string, _list)
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaOptimizer.optimizeGrammar", _start, ex)
      else
        _t = _memoize("MMetaOptimizer.optimizeGrammar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'optimizeGrammar'
      raise ex
    end
  end
  

  
  def optimizeRule
    throws RuleFailure
    begin
      _start = _pos; _real_start = -1
      r = nil
      _t = _sretrieve("MMetaOptimizer.optimizeRule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p278 = _pos
            begin
              r = (
                self._any()
              )
              begin
                
                        MMetaAndOrOpt opt = MMetaAndOrOpt.new()
                        begin
                            opt.changed = false
                            r = opt.parse(r)
                        end while (opt.changed)
                        r
                    
              end
            rescue RuleFailure => ex
              self._pos = _p278
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaOptimizer.optimizeRule", _start, ex)
      else
        _t = _memoize("MMetaOptimizer.optimizeRule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'optimizeRule'
      raise ex
    end
  end
  


  def _jump(r:String)
    return optimizeGrammar() if (r == "optimizeGrammar")
    return optimizeRule() if (r == "optimizeRule")
    super(r)
  end

  def _has(r:String)
    return true if (r == "optimizeGrammar")
    return true if (r == "optimizeRule")
    super(r)
  end
end
