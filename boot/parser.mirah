# generated by mmeta on Fri Apr 22 09:23:40 PDT 2011
# do not modify, instead edit original .mmeta file
import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import jmeta.*;


import java.util.*

class MMetaParser < BaseParser
  def _init

    @chars = _chars
    super()

  end

  def oneOf()

          chars = String(_pop())
          return _char(chars)
        
  end


  def fromTo:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('fromTo')
    _t = _sretrieve("MMetaParser.fromTo")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = y = Object(nil)

    begin  # and
      _p2 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        y = _t

        break if _t == BaseParser.__ERROR__

        _push(x); _t=self.str();
        break if _t == BaseParser.__ERROR__

        as1 = ArrayList.new
        while true  # star
          begin  # and
            _p0 = _pos; _t=nil
            begin  # and (inner)
              _push(y); _t=self.str();
              _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

              break if _t == BaseParser.__ERROR__

              _t=self._any();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p0 if (_t==BaseParser.__ERROR__)
          end  # and

          break if (_t == BaseParser.__ERROR__)
          as1.add(_t)
        end
        _t = as1


        break if _t == BaseParser.__ERROR__

        _push(y); _t=self.str();
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p2 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.fromTo", _start, _t))
    BaseParser.__ERROR__.last = "fromTo" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def sp:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('sp')
    _t = _sretrieve("MMetaParser.sp")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _t = BaseParser.__ERROR__
    begin  # or
      _t=super();
      break unless _t == BaseParser.__ERROR__
      _push(["//", "\n"].toArray); _t=self.fromTo();
      break unless _t == BaseParser.__ERROR__
      _push(["/*", "*/"].toArray); _t=self.fromTo();
      break unless _t == BaseParser.__ERROR__
      _push(["#", "\n"].toArray); _t=self.fromTo();
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.sp", _start, _t))
    BaseParser.__ERROR__.last = "sp" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def ws:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('ws')
    _t = _sretrieve("MMetaParser.ws")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    as3 = ArrayList.new
    while true  # star
      _t = BaseParser.__ERROR__
      begin  # or
        _t=self.sp();
        break unless _t == BaseParser.__ERROR__
        _t=self.nl();
        break unless _t == BaseParser.__ERROR__
      end while false

      break if (_t == BaseParser.__ERROR__)
      as3.add(_t)
    end
    _t = as3


    _t = _exit(_memoize("MMetaParser.ws", _start, _t))
    BaseParser.__ERROR__.last = "ws" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def listOf:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('listOf')
    _t = _sretrieve("MMetaParser.listOf")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    e = s = f = rs = Object(nil)

    begin  # and
      _p8 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        e = _t

        break if _t == BaseParser.__ERROR__

        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p6 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _push(e); _t=self.apply();
              f = _t

              break if _t == BaseParser.__ERROR__

              as5 = ArrayList.new
              while true  # star
                begin  # and
                  _p4 = _pos; _t=nil
                  begin  # and (inner)
                    if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                    break if _t == BaseParser.__ERROR__

                    _push(s); _t=self.str();
                    break if _t == BaseParser.__ERROR__

                    if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                    break if _t == BaseParser.__ERROR__

                    _push(e); _t=self.apply();
                    break if _t == BaseParser.__ERROR__

                  end while false  # and (inner)
                  self._pos=_p4 if (_t==BaseParser.__ERROR__)
                end  # and

                break if (_t == BaseParser.__ERROR__)
                as5.add(_t)
              end
              _t = as5


              rs = _t

              break if _t == BaseParser.__ERROR__

              _t=concat([f], rs);
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p6 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p7 = _pos; _t=nil
            begin  # and (inner)
              _t=self.empty();
              break if _t == BaseParser.__ERROR__

              _t=ArrayList.new;
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p7 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
        end while false

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p8 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.listOf", _start, _t))
    BaseParser.__ERROR__.last = "listOf" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def nameFirst:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('nameFirst')
    _t = _sretrieve("MMetaParser.nameFirst")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _t = BaseParser.__ERROR__
    begin  # or
      _t = BaseParser.__ERROR__
      _p9 = _pos
      begin
        break if _p9 + 1 > @chars.length
        break unless @chars[_p9] == 95
        _p9 += 1

        _t = "_"; self._pos = _p9
      end while false

      break unless _t == BaseParser.__ERROR__
      _t=self.letter();
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.nameFirst", _start, _t))
    BaseParser.__ERROR__.last = "nameFirst" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def nameRest:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('nameRest')
    _t = _sretrieve("MMetaParser.nameRest")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _t = BaseParser.__ERROR__
    begin  # or
      _t=self.nameFirst();
      break unless _t == BaseParser.__ERROR__
      _t=self.digit();
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.nameRest", _start, _t))
    BaseParser.__ERROR__.last = "nameRest" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def name:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('name')
    _t = _sretrieve("MMetaParser.name")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    f = rs = Object(nil)

    begin  # and
      _p11 = _pos; _t=nil
      begin  # and (inner)
        _t=self.nameFirst();
        f = _t

        break if _t == BaseParser.__ERROR__

        as10 = ArrayList.new
        while true  # star
          _t=self.nameRest();
          break if (_t == BaseParser.__ERROR__)
          as10.add(_t)
        end
        _t = as10


        rs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin
           join(concat([f], rs)) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p11 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.name", _start, _t))
    BaseParser.__ERROR__.last = "name" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def rulename:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('rulename')
    _t = _sretrieve("MMetaParser.rulename")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    begin  # and
      _p12 = _pos; _t=nil
      begin  # and (inner)
        _push("def"); _t=self.k();
        _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

        break if _t == BaseParser.__ERROR__

        _t=self.name();
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p12 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.rulename", _start, _t))
    BaseParser.__ERROR__.last = "rulename" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def varname:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('varname')
    _t = _sretrieve("MMetaParser.varname")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    p = n = Object(nil)

    begin  # and
      _p14 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        begin  # or
          _t = BaseParser.__ERROR__
          _p13 = _pos
          begin
            break if _p13 + 1 > @chars.length
            break unless @chars[_p13] == 64
            _p13 += 1

            _t = "@"; self._pos = _p13
          end while false

          break unless _t == BaseParser.__ERROR__
          _t="";
          break unless _t == BaseParser.__ERROR__
        end while false

        p = _t

        break if _t == BaseParser.__ERROR__

        _t=self.name();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t="#{p}#{n}";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p14 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.varname", _start, _t))
    BaseParser.__ERROR__.last = "varname" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def hex:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('hex')
    _t = _sretrieve("MMetaParser.hex")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _push("0123456789abcdefABCDEF"); _t=self.oneOf();
    _t = _exit(_memoize("MMetaParser.hex", _start, _t))
    BaseParser.__ERROR__.last = "hex" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def echar:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('echar')
    _t = _sretrieve("MMetaParser.echar")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    c = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p16 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p15 = _pos
          begin
            break if _p15 + 1 > @chars.length
            break unless @chars[_p15] == 92
            _p15 += 1

            _t = "\\"; self._pos = _p15
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self._any();
          c = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t = begin
             "\\#{c}"; 
          end

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p16 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t=self._any();
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.echar", _start, _t))
    BaseParser.__ERROR__.last = "echar" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def tsString:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('tsString')
    _t = _sretrieve("MMetaParser.tsString")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p22 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p17 = _pos
        begin
          break if _p17 + 1 > @chars.length
          break unless @chars[_p17] == 34
          _p17 += 1

          _t = "\""; self._pos = _p17
        end while false

        break if _t == BaseParser.__ERROR__

        as20 = ArrayList.new
        while true  # star
          begin  # and
            _p19 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p18 = _pos
              begin
                break if _p18 + 1 > @chars.length
                break unless @chars[_p18] == 34
                _p18 += 1

                _t = "\""; self._pos = _p18
              end while false

              _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

              break if _t == BaseParser.__ERROR__

              _t=self.echar();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p19 if (_t==BaseParser.__ERROR__)
          end  # and

          break if (_t == BaseParser.__ERROR__)
          as20.add(_t)
        end
        _t = as20


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p21 = _pos
        begin
          break if _p21 + 1 > @chars.length
          break unless @chars[_p21] == 34
          _p21 += 1

          _t = "\""; self._pos = _p21
        end while false

        break if _t == BaseParser.__ERROR__

        _t = begin
           join(xs) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p22 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.tsString", _start, _t))
    BaseParser.__ERROR__.last = "tsString" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def dollar:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('dollar')
    _t = _sretrieve("MMetaParser.dollar")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = n = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p26 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p23 = _pos
          begin
            break if _p23 + 2 > @chars.length
            break unless @chars[_p23] == 36
            _p23 += 1
            break unless @chars[_p23] == 123
            _p23 += 1

            _t = "${"; self._pos = _p23
          end while false

          break if _t == BaseParser.__ERROR__

          as24 = ArrayList.new
          while true  # star
            _t=self.cbraces();
            break if (_t == BaseParser.__ERROR__)
            as24.add(_t)
          end
          _t = as24


          xs = _t

          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p25 = _pos
          begin
            break if _p25 + 1 > @chars.length
            break unless @chars[_p25] == 125
            _p25 += 1

            _t = "}"; self._pos = _p25
          end while false

          break if _t == BaseParser.__ERROR__

          _t="\"+#{join(xs)}+\"";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p26 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p28 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p27 = _pos
          begin
            break if _p27 + 1 > @chars.length
            break unless @chars[_p27] == 36
            _p27 += 1

            _t = "$"; self._pos = _p27
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t="\"+#{n}+\"";
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p28 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.dollar", _start, _t))
    BaseParser.__ERROR__.last = "dollar" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def dollarstring:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('dollarstring')
    _t = _sretrieve("MMetaParser.dollarstring")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p34 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p29 = _pos
        begin
          break if _p29 + 1 > @chars.length
          break unless @chars[_p29] == 34
          _p29 += 1

          _t = "\""; self._pos = _p29
        end while false

        break if _t == BaseParser.__ERROR__

        as32 = ArrayList.new
        while true  # star
          begin  # and
            _p31 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p30 = _pos
              begin
                break if _p30 + 1 > @chars.length
                break unless @chars[_p30] == 34
                _p30 += 1

                _t = "\""; self._pos = _p30
              end while false

              _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

              break if _t == BaseParser.__ERROR__

              _t = BaseParser.__ERROR__
              begin  # or
                _t=self.dollar();
                break unless _t == BaseParser.__ERROR__
                _t=self.echar();
                break unless _t == BaseParser.__ERROR__
              end while false

              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p31 if (_t==BaseParser.__ERROR__)
          end  # and

          break if (_t == BaseParser.__ERROR__)
          as32.add(_t)
        end
        _t = as32


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p33 = _pos
        begin
          break if _p33 + 1 > @chars.length
          break unless @chars[_p33] == 34
          _p33 += 1

          _t = "\""; self._pos = _p33
        end while false

        break if _t == BaseParser.__ERROR__

        _t = begin
           join(xs) 
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p34 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.dollarstring", _start, _t))
    BaseParser.__ERROR__.last = "dollarstring" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def string:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('string')
    _t = _sretrieve("MMetaParser.string")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    s = Object(nil)

    begin  # and
      _p35 = _pos; _t=nil
      begin  # and (inner)
        _t=self.tsString();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t=["Str", s];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p35 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.string", _start, _t))
    BaseParser.__ERROR__.last = "string" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def number:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('number')
    _t = _sretrieve("MMetaParser.number")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    sign = ds = Object(nil)

    begin  # and
      _p39 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        begin  # or
          _t = BaseParser.__ERROR__
          _p36 = _pos
          begin
            break if _p36 + 1 > @chars.length
            break unless @chars[_p36] == 45
            _p36 += 1

            _t = "-"; self._pos = _p36
          end while false

          break unless _t == BaseParser.__ERROR__
          _t = BaseParser.__ERROR__
          _p37 = _pos
          begin
            break if _p37 + 1 > @chars.length
            break unless @chars[_p37] == 43
            _p37 += 1

            _t = "+"; self._pos = _p37
          end while false

          break unless _t == BaseParser.__ERROR__
          _t=self.empty();
          break unless _t == BaseParser.__ERROR__
        end while false

        sign = _t

        break if _t == BaseParser.__ERROR__

        as38 = ArrayList.new
        _t=self.digit();
        if (_t!=BaseParser.__ERROR__)  # plus
          as38.add(_t)
          while true  # star
            _t=self.digit();
            break if (_t == BaseParser.__ERROR__)
            as38.add(_t)
          end
          _t = as38

        end

        ds = _t

        break if _t == BaseParser.__ERROR__

        _t=["HLit", "#{sign}#{join(ds)}"];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p39 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.number", _start, _t))
    BaseParser.__ERROR__.last = "number" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def symbol:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('symbol')
    _t = _sretrieve("MMetaParser.symbol")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    s = c = Object(nil)

    begin  # and
      _p49 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p41 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p40 = _pos
              begin
                break if _p40 + 1 > @chars.length
                break unless @chars[_p40] == 39
                _p40 += 1

                _t = "'"; self._pos = _p40
              end while false

              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p41 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          _t = BaseParser.__ERROR__
          _p42 = _pos
          begin
            break if _p42 + 1 > @chars.length
            break unless @chars[_p42] == 58
            _p42 += 1

            _t = ":"; self._pos = _p42
          end while false

          break unless _t == BaseParser.__ERROR__
        end while false

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          _t=self.name();
          s = _t

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p48 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p43 = _pos
              begin
                break if _p43 + 1 > @chars.length
                break unless @chars[_p43] == 39
                _p43 += 1

                _t = "'"; self._pos = _p43
              end while false

              break if _t == BaseParser.__ERROR__

              as46 = ArrayList.new
              begin  # and
                _p45 = _pos; _t=nil
                begin  # and (inner)
                  _t = BaseParser.__ERROR__
                  _p44 = _pos
                  begin
                    break if _p44 + 1 > @chars.length
                    break unless @chars[_p44] == 39
                    _p44 += 1

                    _t = "'"; self._pos = _p44
                  end while false

                  _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

                  break if _t == BaseParser.__ERROR__

                  _t=self._any();
                  break if _t == BaseParser.__ERROR__

                end while false  # and (inner)
                self._pos=_p45 if (_t==BaseParser.__ERROR__)
              end  # and

              if (_t!=BaseParser.__ERROR__)  # plus
                as46.add(_t)
                while true  # star
                  begin  # and
                    _p45 = _pos; _t=nil
                    begin  # and (inner)
                      _t = BaseParser.__ERROR__
                      _p44 = _pos
                      begin
                        break if _p44 + 1 > @chars.length
                        break unless @chars[_p44] == 39
                        _p44 += 1

                        _t = "'"; self._pos = _p44
                      end while false

                      _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

                      break if _t == BaseParser.__ERROR__

                      _t=self._any();
                      break if _t == BaseParser.__ERROR__

                    end while false  # and (inner)
                    self._pos=_p45 if (_t==BaseParser.__ERROR__)
                  end  # and

                  break if (_t == BaseParser.__ERROR__)
                  as46.add(_t)
                end
                _t = as46

              end

              c = _t

              break if _t == BaseParser.__ERROR__

              _t = BaseParser.__ERROR__
              _p47 = _pos
              begin
                break if _p47 + 1 > @chars.length
                break unless @chars[_p47] == 39
                _p47 += 1

                _t = "'"; self._pos = _p47
              end while false

              break if _t == BaseParser.__ERROR__

              _t = begin
                join(c)
              end

              s = _t

              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p48 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
        end while false

        break if _t == BaseParser.__ERROR__

        _t=["Sym", s];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p49 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.symbol", _start, _t))
    BaseParser.__ERROR__.last = "symbol" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def k:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('k')
    _t = _sretrieve("MMetaParser.k")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    keyword = Object(nil)

    begin  # and
      _p50 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        keyword = _t

        break if _t == BaseParser.__ERROR__

        _push(keyword); _t=self.str();
        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          _t=self.nameFirst();
          break unless _t == BaseParser.__ERROR__
          _t=self.digit();
          break unless _t == BaseParser.__ERROR__
        end while false

        _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

        break if _t == BaseParser.__ERROR__

        _t=keyword;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p50 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.k", _start, _t))
    BaseParser.__ERROR__.last = "k" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def error:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('error')
    _t = _sretrieve("MMetaParser.error")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    msg = Object(nil)

    begin  # and
      _p52 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p51 = _pos
        begin
          break if _p51 + 1 > @chars.length
          break unless @chars[_p51] == 33
          _p51 += 1

          _t = "!"; self._pos = _p51
        end while false

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          _t=self.dollarstring();
          break unless _t == BaseParser.__ERROR__
          _t=self.empty();
          break unless _t == BaseParser.__ERROR__
        end while false

        msg = _t

        break if _t == BaseParser.__ERROR__

        _t=["Error", msg];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p52 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.error", _start, _t))
    BaseParser.__ERROR__.last = "error" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def any:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('any')
    _t = _sretrieve("MMetaParser.any")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    begin  # and
      _p54 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p53 = _pos
        begin
          break if _p53 + 1 > @chars.length
          break unless @chars[_p53] == 95
          _p53 += 1

          _t = "_"; self._pos = _p53
        end while false

        break if _t == BaseParser.__ERROR__

        _t=["App", "_any"];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p54 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.any", _start, _t))
    BaseParser.__ERROR__.last = "any" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def wsdot:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('wsdot')
    _t = _sretrieve("MMetaParser.wsdot")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    begin  # and
      _p56 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p55 = _pos
        begin
          break if _p55 + 1 > @chars.length
          break unless @chars[_p55] == 46
          _p55 += 1

          _t = "."; self._pos = _p55
        end while false

        break if _t == BaseParser.__ERROR__

        _t=["Dot"];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p56 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.wsdot", _start, _t))
    BaseParser.__ERROR__.last = "wsdot" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def args:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('args')
    _t = _sretrieve("MMetaParser.args")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    as = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p59 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p57 = _pos
          begin
            break if _p57 + 1 > @chars.length
            break unless @chars[_p57] == 40
            _p57 += 1

            _t = "("; self._pos = _p57
          end while false

          break if _t == BaseParser.__ERROR__

          _push(["simplehost", ","].toArray); _t=self.listOf();
          as = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p58 = _pos
          begin
            break if _p58 + 1 > @chars.length
            break unless @chars[_p58] == 41
            _p58 += 1

            _t = ")"; self._pos = _p58
          end while false

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=as;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p59 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p60 = _pos; _t=nil
        begin  # and (inner)
          _t=self.empty();
          break if _t == BaseParser.__ERROR__

          _t=ArrayList.new;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p60 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.args", _start, _t))
    BaseParser.__ERROR__.last = "args" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def application:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('application')
    _t = _sretrieve("MMetaParser.application")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    r = as = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p62 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p61 = _pos
          begin
            break if _p61 + 6 > @chars.length
            break unless @chars[_p61] == 115
            _p61 += 1
            break unless @chars[_p61] == 117
            _p61 += 1
            break unless @chars[_p61] == 112
            _p61 += 1
            break unless @chars[_p61] == 101
            _p61 += 1
            break unless @chars[_p61] == 114
            _p61 += 1
            break unless @chars[_p61] == 46
            _p61 += 1

            _t = "super."; self._pos = _p61
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.name();
          r = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=self.args();
          as = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=concat(["App", "super", r], as);
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p62 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p63 = _pos; _t=nil
        begin  # and (inner)
          _t=self.name();
          r = _t

          break if _t == BaseParser.__ERROR__

          _t=self.args();
          as = _t

          break if _t == BaseParser.__ERROR__

          _t=concat(["App", r], as);
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p63 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.application", _start, _t))
    BaseParser.__ERROR__.last = "application" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def fname:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('fname')
    _t = _sretrieve("MMetaParser.fname")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = t = n = Object(nil)

    begin  # and
      _p67 = _pos; _t=nil
      begin  # and (inner)
        as66 = ArrayList.new
        while true  # star
          begin  # and
            _p65 = _pos; _t=nil
            begin  # and (inner)
              _t=self.name();
              x = _t

              break if _t == BaseParser.__ERROR__

              _t = BaseParser.__ERROR__
              _p64 = _pos
              begin
                break if _p64 + 1 > @chars.length
                break unless @chars[_p64] == 46
                _p64 += 1

                _t = "."; self._pos = _p64
              end while false

              break if _t == BaseParser.__ERROR__

              _t="#{x}.";
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p65 if (_t==BaseParser.__ERROR__)
          end  # and

          break if (_t == BaseParser.__ERROR__)
          as66.add(_t)
        end
        _t = as66


        t = _t

        break if _t == BaseParser.__ERROR__

        _t=self.name();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t="#{join(t)}#{n}";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p67 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.fname", _start, _t))
    BaseParser.__ERROR__.last = "fname" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def parens:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('parens')
    _t = _sretrieve("MMetaParser.parens")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    begin  # and
      _p72 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p68 = _pos
        begin
          break if _p68 + 1 > @chars.length
          break unless @chars[_p68] == 40
          _p68 += 1

          _t = "("; self._pos = _p68
        end while false

        break if _t == BaseParser.__ERROR__

        as70 = ArrayList.new
        while true  # star
          _t = BaseParser.__ERROR__
          begin  # or
            _t=self.parens();
            break unless _t == BaseParser.__ERROR__
            begin  # and
              _p69 = _pos; _t=nil
              begin  # and (inner)
                _push("()"); _t=self.oneOf();
                _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

                break if _t == BaseParser.__ERROR__

                _t=self._any();
                break if _t == BaseParser.__ERROR__

              end while false  # and (inner)
              self._pos=_p69 if (_t==BaseParser.__ERROR__)
            end  # and

            break unless _t == BaseParser.__ERROR__
          end while false

          break if (_t == BaseParser.__ERROR__)
          as70.add(_t)
        end
        _t = as70


        x = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p71 = _pos
        begin
          break if _p71 + 1 > @chars.length
          break unless @chars[_p71] == 41
          _p71 += 1

          _t = ")"; self._pos = _p71
        end while false

        break if _t == BaseParser.__ERROR__

        _t="(#{join(x)})";
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p72 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.parens", _start, _t))
    BaseParser.__ERROR__.last = "parens" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def rewrite_expr:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('rewrite_expr')
    _t = _sretrieve("MMetaParser.rewrite_expr")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    n = p = c = s = xs = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p73 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t=self.parens();
          p = _t

          break if _t == BaseParser.__ERROR__

          _t=["HLit", "#{n}#{p}"];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p73 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p76 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p74 = _pos
          begin
            break if _p74 + 2 > @chars.length
            break unless @chars[_p74] == 94
            _p74 += 1
            break unless @chars[_p74] == 40
            _p74 += 1

            _t = "^("; self._pos = _p74
          end while false

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t=self.rewrite_expr();
          c = _t

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _push("*+"); _t=self.oneOf();
          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p75 = _pos
          begin
            break if _p75 + 1 > @chars.length
            break unless @chars[_p75] == 41
            _p75 += 1

            _t = ")"; self._pos = _p75
          end while false

          break if _t == BaseParser.__ERROR__

          _t=["Node", n, c];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p76 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p80 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p77 = _pos
          begin
            break if _p77 + 2 > @chars.length
            break unless @chars[_p77] == 94
            _p77 += 1
            break unless @chars[_p77] == 40
            _p77 += 1

            _t = "^("; self._pos = _p77
          end while false

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          as78 = ArrayList.new
          while true  # star
            _t=self.rewrite_expr();
            break if (_t == BaseParser.__ERROR__)
            as78.add(_t)
          end
          _t = as78


          c = _t

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p79 = _pos
          begin
            break if _p79 + 1 > @chars.length
            break unless @chars[_p79] == 41
            _p79 += 1

            _t = ")"; self._pos = _p79
          end while false

          break if _t == BaseParser.__ERROR__

          _t=["Node", n, concat(["HList"], c)];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p80 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p82 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p81 = _pos
          begin
            break if _p81 + 1 > @chars.length
            break unless @chars[_p81] == 36
            _p81 += 1

            _t = "$"; self._pos = _p81
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t=["TLit", n];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p82 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p83 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.tsString();
          s = _t

          break if _t == BaseParser.__ERROR__

          _t=["HStr", s];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p83 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p84 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t=["HLit", n];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p84 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p87 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p85 = _pos
          begin
            break if _p85 + 1 > @chars.length
            break unless @chars[_p85] == 91
            _p85 += 1

            _t = "["; self._pos = _p85
          end while false

          break if _t == BaseParser.__ERROR__

          _push(["rewrite_expr", ","].toArray); _t=self.listOf();
          xs = _t

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p86 = _pos
          begin
            break if _p86 + 1 > @chars.length
            break unless @chars[_p86] == 93
            _p86 += 1

            _t = "]"; self._pos = _p86
          end while false

          break if _t == BaseParser.__ERROR__

          _t=concat(["HList"], xs);
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p87 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.rewrite_expr", _start, _t))
    BaseParser.__ERROR__.last = "rewrite_expr" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def simplehost:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('simplehost')
    _t = _sretrieve("MMetaParser.simplehost")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    rs = ls = x = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p89 = _pos; _t=nil
        begin  # and (inner)
          _t=self.simplehost1();
          rs = _t

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p88 = _pos
          begin
            break if _p88 + 1 > @chars.length
            break unless @chars[_p88] == 43
            _p88 += 1

            _t = "+"; self._pos = _p88
          end while false

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.simplehost();
          ls = _t

          break if _t == BaseParser.__ERROR__

          _t=["HConcat", rs, ls];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p89 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p90 = _pos; _t=nil
        begin  # and (inner)
          _t=self.simplehost1();
          x = _t

          break if _t == BaseParser.__ERROR__

          _t=x;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p90 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.simplehost", _start, _t))
    BaseParser.__ERROR__.last = "simplehost" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def simplehost1:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('simplehost1')
    _t = _sretrieve("MMetaParser.simplehost1")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = n = s = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p93 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p91 = _pos
          begin
            break if _p91 + 1 > @chars.length
            break unless @chars[_p91] == 91
            _p91 += 1

            _t = "["; self._pos = _p91
          end while false

          break if _t == BaseParser.__ERROR__

          _push(["simplehost", ","].toArray); _t=self.listOf();
          xs = _t

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p92 = _pos
          begin
            break if _p92 + 1 > @chars.length
            break unless @chars[_p92] == 93
            _p92 += 1

            _t = "]"; self._pos = _p92
          end while false

          break if _t == BaseParser.__ERROR__

          _t=concat(["HList"], xs);
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p93 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p94 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.number();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t=n;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p94 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p98 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          begin  # or
            begin  # and
              _p96 = _pos; _t=nil
              begin  # and (inner)
                _t = BaseParser.__ERROR__
                _p95 = _pos
                begin
                  break if _p95 + 1 > @chars.length
                  break unless @chars[_p95] == 39
                  _p95 += 1

                  _t = "'"; self._pos = _p95
                end while false

                break if _t == BaseParser.__ERROR__

              end while false  # and (inner)
              self._pos=_p96 if (_t==BaseParser.__ERROR__)
            end  # and

            break unless _t == BaseParser.__ERROR__
            _t = BaseParser.__ERROR__
            _p97 = _pos
            begin
              break if _p97 + 1 > @chars.length
              break unless @chars[_p97] == 58
              _p97 += 1

              _t = ":"; self._pos = _p97
            end while false

            break unless _t == BaseParser.__ERROR__
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.name();
          s = _t

          break if _t == BaseParser.__ERROR__

          _t=["HStr", s];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p98 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p99 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.tsString();
          s = _t

          break if _t == BaseParser.__ERROR__

          _t=["HStr", s];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p99 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p101 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p100 = _pos
          begin
            break if _p100 + 1 > @chars.length
            break unless @chars[_p100] == 64
            _p100 += 1

            _t = "@"; self._pos = _p100
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t=["HLit", "@#{n}"];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p101 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p102 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          _t=["HLit", n];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p102 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.simplehost1", _start, _t))
    BaseParser.__ERROR__.last = "simplehost1" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def cbraces:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('cbraces')
    _t = _sretrieve("MMetaParser.cbraces")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p106 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p103 = _pos
          begin
            break if _p103 + 1 > @chars.length
            break unless @chars[_p103] == 123
            _p103 += 1

            _t = "{"; self._pos = _p103
          end while false

          break if _t == BaseParser.__ERROR__

          as104 = ArrayList.new
          while true  # star
            _t=self.cbraces();
            break if (_t == BaseParser.__ERROR__)
            as104.add(_t)
          end
          _t = as104


          xs = _t

          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p105 = _pos
          begin
            break if _p105 + 1 > @chars.length
            break unless @chars[_p105] == 125
            _p105 += 1

            _t = "}"; self._pos = _p105
          end while false

          break if _t == BaseParser.__ERROR__

          _t = begin
             "{"+ join(xs) +"}" 
          end

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p106 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p108 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p107 = _pos
          begin
            break if _p107 + 1 > @chars.length
            break unless @chars[_p107] == 125
            _p107 += 1

            _t = "}"; self._pos = _p107
          end while false

          _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

          break if _t == BaseParser.__ERROR__

          _t=self._any();
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p108 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.cbraces", _start, _t))
    BaseParser.__ERROR__.last = "cbraces" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def semAction:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('semAction')
    _t = _sretrieve("MMetaParser.semAction")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    s = xs = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p111 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p109 = _pos
          begin
            break if _p109 + 1 > @chars.length
            break unless @chars[_p109] == 123
            _p109 += 1

            _t = "{"; self._pos = _p109
          end while false

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.simplehost();
          s = _t

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p110 = _pos
          begin
            break if _p110 + 1 > @chars.length
            break unless @chars[_p110] == 125
            _p110 += 1

            _t = "}"; self._pos = _p110
          end while false

          break if _t == BaseParser.__ERROR__

          _t=["SAct", s];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p111 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p115 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p112 = _pos
          begin
            break if _p112 + 1 > @chars.length
            break unless @chars[_p112] == 123
            _p112 += 1

            _t = "{"; self._pos = _p112
          end while false

          break if _t == BaseParser.__ERROR__

          as113 = ArrayList.new
          while true  # star
            _t=self.cbraces();
            break if (_t == BaseParser.__ERROR__)
            as113.add(_t)
          end
          _t = as113


          xs = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p114 = _pos
          begin
            break if _p114 + 1 > @chars.length
            break unless @chars[_p114] == 125
            _p114 += 1

            _t = "}"; self._pos = _p114
          end while false

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["Act", "#{join(xs)}"];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p115 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p117 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p116 = _pos
          begin
            break if _p116 + 2 > @chars.length
            break unless @chars[_p116] == 45
            _p116 += 1
            break unless @chars[_p116] == 62
            _p116 += 1

            _t = "->"; self._pos = _p116
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.rewrite_expr();
          s = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["SAct", s];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p117 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.semAction", _start, _t))
    BaseParser.__ERROR__.last = "semAction" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def semPred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('semPred')
    _t = _sretrieve("MMetaParser.semPred")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p121 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p118 = _pos
        begin
          break if _p118 + 2 > @chars.length
          break unless @chars[_p118] == 63
          _p118 += 1
          break unless @chars[_p118] == 123
          _p118 += 1

          _t = "?{"; self._pos = _p118
        end while false

        break if _t == BaseParser.__ERROR__

        as119 = ArrayList.new
        while true  # star
          _t=self.cbraces();
          break if (_t == BaseParser.__ERROR__)
          as119.add(_t)
        end
        _t = as119


        xs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p120 = _pos
        begin
          break if _p120 + 1 > @chars.length
          break unless @chars[_p120] == 125
          _p120 += 1

          _t = "}"; self._pos = _p120
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=["Pred", "#{join(xs)}"];
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p121 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.semPred", _start, _t))
    BaseParser.__ERROR__.last = "semPred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def synPred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('synPred')
    _t = _sretrieve("MMetaParser.synPred")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    p = e = t = Object(nil)

    begin  # and
      _p125 = _pos; _t=nil
      begin  # and (inner)
        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p122 = _pos
        begin
          break if _p122 + 1 > @chars.length
          break unless @chars[_p122] == 40
          _p122 += 1

          _t = "("; self._pos = _p122
        end while false

        break if _t == BaseParser.__ERROR__

        _t=self.expr();
        p = _t

        break if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p123 = _pos
        begin
          break if _p123 + 1 > @chars.length
          break unless @chars[_p123] == 41
          _p123 += 1

          _t = ")"; self._pos = _p123
        end while false

        break if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p124 = _pos
        begin
          break if _p124 + 2 > @chars.length
          break unless @chars[_p124] == 61
          _p124 += 1
          break unless @chars[_p124] == 62
          _p124 += 1

          _t = "=>"; self._pos = _p124
        end while false

        break if _t == BaseParser.__ERROR__

        _t=self.expr4();
        e = _t

        break if _t == BaseParser.__ERROR__

        _t=self.synPredTail();
        t = _t

        break if _t == BaseParser.__ERROR__

        _t=["SynPred", ["Peek", p], e, t];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p125 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.synPred", _start, _t))
    BaseParser.__ERROR__.last = "synPred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def synPredTail:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('synPredTail')
    _t = _sretrieve("MMetaParser.synPredTail")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p127 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p126 = _pos
          begin
            break if _p126 + 1 > @chars.length
            break unless @chars[_p126] == 124
            _p126 += 1

            _t = "|"; self._pos = _p126
          end while false

          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          begin  # or
            _t=self.synPred();
            break unless _t == BaseParser.__ERROR__
            _t=self.expr4();
            break unless _t == BaseParser.__ERROR__
          end while false

          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p127 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t=["Pred", "false"];
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.synPredTail", _start, _t))
    BaseParser.__ERROR__.last = "synPredTail" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def token:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('token')
    _t = _sretrieve("MMetaParser.token")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    n = Object(nil)

    begin  # and
      _p129 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p128 = _pos
        begin
          break if _p128 + 1 > @chars.length
          break unless @chars[_p128] == 36
          _p128 += 1

          _t = "$"; self._pos = _p128
        end while false

        break if _t == BaseParser.__ERROR__

        _t=self.name();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=n;
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p129 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.token", _start, _t))
    BaseParser.__ERROR__.last = "token" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def tokens:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('tokens')
    _t = _sretrieve("MMetaParser.tokens")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    a = b = Object(nil)

    begin  # and
      _p132 = _pos; _t=nil
      begin  # and (inner)
        _t=self.token();
        a = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p131 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _t = BaseParser.__ERROR__
              _p130 = _pos
              begin
                break if _p130 + 2 > @chars.length
                break unless @chars[_p130] == 46
                _p130 += 1
                break unless @chars[_p130] == 46
                _p130 += 1

                _t = ".."; self._pos = _p130
              end while false

              break if _t == BaseParser.__ERROR__

              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _t=self.token();
              b = _t

              break if _t == BaseParser.__ERROR__

              _t=["TokenRange", a, b];
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p131 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          _t=["Token", a];
          break unless _t == BaseParser.__ERROR__
        end while false

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p132 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.tokens", _start, _t))
    BaseParser.__ERROR__.last = "tokens" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def expr:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('expr')
    _t = _sretrieve("MMetaParser.expr")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p133 = _pos; _t=nil
      begin  # and (inner)
        _push(["expr4", "|"].toArray); _t=self.listOf();
        xs = _t

        break if _t == BaseParser.__ERROR__

        _t=concat(["Or"], xs);
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p133 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.expr", _start, _t))
    BaseParser.__ERROR__.last = "expr" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def expr4:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('expr4')
    _t = _sretrieve("MMetaParser.expr4")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p135 = _pos; _t=nil
      begin  # and (inner)
        as134 = ArrayList.new
        while true  # star
          _t=self.expr3();
          break if (_t == BaseParser.__ERROR__)
          as134.add(_t)
        end
        _t = as134


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t=concat(["And"], xs);
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p135 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.expr4", _start, _t))
    BaseParser.__ERROR__.last = "expr4" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def optIter:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('optIter')
    _t = _sretrieve("MMetaParser.optIter")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    begin  # and
      _p143 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p137 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p136 = _pos
              begin
                break if _p136 + 1 > @chars.length
                break unless @chars[_p136] == 42
                _p136 += 1

                _t = "*"; self._pos = _p136
              end while false

              break if _t == BaseParser.__ERROR__

              _t=["Many", x];
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p137 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p139 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p138 = _pos
              begin
                break if _p138 + 1 > @chars.length
                break unless @chars[_p138] == 43
                _p138 += 1

                _t = "+"; self._pos = _p138
              end while false

              break if _t == BaseParser.__ERROR__

              _t=["Many1", x];
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p139 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p141 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p140 = _pos
              begin
                break if _p140 + 1 > @chars.length
                break unless @chars[_p140] == 63
                _p140 += 1

                _t = "?"; self._pos = _p140
              end while false

              break if _t == BaseParser.__ERROR__

              _t=["Opt", x];
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p141 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p142 = _pos; _t=nil
            begin  # and (inner)
              _t=self.empty();
              break if _t == BaseParser.__ERROR__

              _t=x;
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p142 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
        end while false

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p143 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.optIter", _start, _t))
    BaseParser.__ERROR__.last = "optIter" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def expr3:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('expr3')
    _t = _sretrieve("MMetaParser.expr3")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    n = e = x = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p145 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.name();
          n = _t

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p144 = _pos
          begin
            break if _p144 + 1 > @chars.length
            break unless @chars[_p144] == 61
            _p144 += 1

            _t = "="; self._pos = _p144
          end while false

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=self.expr2();
          e = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _push(e); _t=self.optIter();
          x = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["Set", n, x];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p145 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p146 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.expr2();
          e = _t

          break if _t == BaseParser.__ERROR__

          _push(e); _t=self.optIter();
          x = _t

          break if _t == BaseParser.__ERROR__

          _t=x;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p146 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.expr3", _start, _t))
    BaseParser.__ERROR__.last = "expr3" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def expr2:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('expr2')
    _t = _sretrieve("MMetaParser.expr2")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p148 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p147 = _pos
          begin
            break if _p147 + 1 > @chars.length
            break unless @chars[_p147] == 126
            _p147 += 1

            _t = "~"; self._pos = _p147
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.expr2();
          x = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["Not", x];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p148 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p150 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p149 = _pos
          begin
            break if _p149 + 1 > @chars.length
            break unless @chars[_p149] == 38
            _p149 += 1

            _t = "&"; self._pos = _p149
          end while false

          break if _t == BaseParser.__ERROR__

          _t=self.expr1();
          x = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["Peek", x];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p150 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t=self.expr1();
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.expr2", _start, _t))
    BaseParser.__ERROR__.last = "expr2" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def expr1:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('expr1')
    _t = _sretrieve("MMetaParser.expr1")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      _t=self.wsdot();
      break unless _t == BaseParser.__ERROR__
      _t=self.any();
      break unless _t == BaseParser.__ERROR__
      _t=self.error();
      break unless _t == BaseParser.__ERROR__
      _t=self.semPred();
      break unless _t == BaseParser.__ERROR__
      _t=self.semAction();
      break unless _t == BaseParser.__ERROR__
      _t=self.application();
      break unless _t == BaseParser.__ERROR__
      _t=self.tokens();
      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p151 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          begin  # or
            _push("null"); _t=self.k();
            break unless _t == BaseParser.__ERROR__
            _push("true"); _t=self.k();
            break unless _t == BaseParser.__ERROR__
            _push("false"); _t=self.k();
            break unless _t == BaseParser.__ERROR__
          end while false

          x = _t

          break if _t == BaseParser.__ERROR__

          _t=["HLit", x];
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p151 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t=self.string();
      break unless _t == BaseParser.__ERROR__
      _t=self.symbol();
      break unless _t == BaseParser.__ERROR__
      _t=self.number();
      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p154 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p152 = _pos
          begin
            break if _p152 + 1 > @chars.length
            break unless @chars[_p152] == 91
            _p152 += 1

            _t = "["; self._pos = _p152
          end while false

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=self.expr();
          x = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p153 = _pos
          begin
            break if _p153 + 1 > @chars.length
            break unless @chars[_p153] == 93
            _p153 += 1

            _t = "]"; self._pos = _p153
          end while false

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["List", x];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p154 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t=self.synPred();
      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p157 = _pos; _t=nil
        begin  # and (inner)
          _t = BaseParser.__ERROR__
          _p155 = _pos
          begin
            break if _p155 + 1 > @chars.length
            break unless @chars[_p155] == 40
            _p155 += 1

            _t = "("; self._pos = _p155
          end while false

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=self.expr();
          x = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p156 = _pos
          begin
            break if _p156 + 1 > @chars.length
            break unless @chars[_p156] == 41
            _p156 += 1

            _t = ")"; self._pos = _p156
          end while false

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=x;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p157 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.expr1", _start, _t))
    BaseParser.__ERROR__.last = "expr1" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def rule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('rule')
    _t = _sretrieve("MMetaParser.rule")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    n = x = xs = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p165 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p158 = _pos
          begin
            break if _p158 + 5 > @chars.length
            break unless @chars[_p158] == 64
            _p158 += 1
            break unless @chars[_p158] == 77
            _p158 += 1
            break unless @chars[_p158] == 101
            _p158 += 1
            break unless @chars[_p158] == 109
            _p158 += 1
            break unless @chars[_p158] == 111
            _p158 += 1

            _t = "@Memo"; self._pos = _p158
          end while false

          break if _t == BaseParser.__ERROR__

          begin  # peek
            _l160 = _pos
            begin  # and
              _p159 = _pos; _t=nil
              begin  # and (inner)
                if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                break if _t == BaseParser.__ERROR__

                _t=self.rulename();
                n = _t

                break if _t == BaseParser.__ERROR__

              end while false  # and (inner)
              self._pos=_p159 if (_t==BaseParser.__ERROR__)
            end  # and

            self._pos = _l160 if (_t != BaseParser.__ERROR__)
          end  # peek

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _push(n); _t=self.rulePart();
          x = _t

          break if _t == BaseParser.__ERROR__

          as163 = ArrayList.new
          while true  # star
            begin  # and
              _p162 = _pos; _t=nil
              begin  # and (inner)
                if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                break if _t == BaseParser.__ERROR__

                _t = BaseParser.__ERROR__
                _p161 = _pos
                begin
                  break if _p161 + 1 > @chars.length
                  break unless @chars[_p161] == 59
                  _p161 += 1

                  _t = ";"; self._pos = _p161
                end while false

                break if _t == BaseParser.__ERROR__

                if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                break if _t == BaseParser.__ERROR__

                _push(n); _t=self.rulePart();
                break if _t == BaseParser.__ERROR__

              end while false  # and (inner)
              self._pos=_p162 if (_t==BaseParser.__ERROR__)
            end  # and

            break if (_t == BaseParser.__ERROR__)
            as163.add(_t)
          end
          _t = as163


          xs = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p164 = _pos
          begin
            break if _p164 + 1 > @chars.length
            break unless @chars[_p164] == 59
            _p164 += 1

            _t = ";"; self._pos = _p164
          end while false

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["MemoRule", n, concat(["Or", x], xs)];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p165 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p172 = _pos; _t=nil
        begin  # and (inner)
          begin  # peek
            _l167 = _pos
            begin  # and
              _p166 = _pos; _t=nil
              begin  # and (inner)
                if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                break if _t == BaseParser.__ERROR__

                _t=self.rulename();
                n = _t

                break if _t == BaseParser.__ERROR__

              end while false  # and (inner)
              self._pos=_p166 if (_t==BaseParser.__ERROR__)
            end  # and

            self._pos = _l167 if (_t != BaseParser.__ERROR__)
          end  # peek

          break if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _push(n); _t=self.rulePart();
          x = _t

          break if _t == BaseParser.__ERROR__

          as170 = ArrayList.new
          while true  # star
            begin  # and
              _p169 = _pos; _t=nil
              begin  # and (inner)
                if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                break if _t == BaseParser.__ERROR__

                _t = BaseParser.__ERROR__
                _p168 = _pos
                begin
                  break if _p168 + 1 > @chars.length
                  break unless @chars[_p168] == 59
                  _p168 += 1

                  _t = ";"; self._pos = _p168
                end while false

                break if _t == BaseParser.__ERROR__

                if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                break if _t == BaseParser.__ERROR__

                _push(n); _t=self.rulePart();
                break if _t == BaseParser.__ERROR__

              end while false  # and (inner)
              self._pos=_p169 if (_t==BaseParser.__ERROR__)
            end  # and

            break if (_t == BaseParser.__ERROR__)
            as170.add(_t)
          end
          _t = as170


          xs = _t

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t = BaseParser.__ERROR__
          _p171 = _pos
          begin
            break if _p171 + 1 > @chars.length
            break unless @chars[_p171] == 59
            _p171 += 1

            _t = ";"; self._pos = _p171
          end while false

          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

          _t=["Rule", n, concat(["Or", x], xs)];
          raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p172 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.rule", _start, _t))
    BaseParser.__ERROR__.last = "rule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def rulePart:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('rulePart')
    _t = _sretrieve("MMetaParser.rulePart")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    rn = n = l = s = c = Object(nil)

    begin  # and
      _p177 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        rn = _t

        break if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _t=self.name();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t = ( n.equals(rn) ) ? nil : BaseParser.__ERROR__

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p176 = _pos; _t=nil
            begin  # and (inner)
              begin  # and
                _p175 = _pos; _t=nil
                begin  # and (inner)
                  if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                  break if _t == BaseParser.__ERROR__

                  _push("scope"); _t=self.k();
                  break if _t == BaseParser.__ERROR__

                  _t = BaseParser.__ERROR__
                  _p173 = _pos
                  begin
                    break if _p173 + 1 > @chars.length
                    break unless @chars[_p173] == 40
                    _p173 += 1

                    _t = "("; self._pos = _p173
                  end while false

                  break if _t == BaseParser.__ERROR__

                  _push(["varname", ","].toArray); _t=self.listOf();
                  l = _t

                  break if _t == BaseParser.__ERROR__

                  if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                  break if _t == BaseParser.__ERROR__

                  _t = BaseParser.__ERROR__
                  _p174 = _pos
                  begin
                    break if _p174 + 1 > @chars.length
                    break unless @chars[_p174] == 41
                    _p174 += 1

                    _t = ")"; self._pos = _p174
                  end while false

                  break if _t == BaseParser.__ERROR__

                end while false  # and (inner)
                self._pos=_p175 if (_t==BaseParser.__ERROR__)
              end  # and

              s = _t

              break if _t == BaseParser.__ERROR__

              _t=self.ruleStuff();
              c = _t

              break if _t == BaseParser.__ERROR__

              _t=["Scope", l, c];
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p176 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          _t=self.ruleStuff();
          break unless _t == BaseParser.__ERROR__
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p177 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.rulePart", _start, _t))
    BaseParser.__ERROR__.last = "rulePart" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def ruleStuff:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('ruleStuff')
    _t = _sretrieve("MMetaParser.ruleStuff")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    b1 = b2 = Object(nil)

    begin  # and
      _p181 = _pos; _t=nil
      begin  # and (inner)
        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _t=self.expr4();
        b1 = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p179 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _t = BaseParser.__ERROR__
              _p178 = _pos
              begin
                break if _p178 + 1 > @chars.length
                break unless @chars[_p178] == 58
                _p178 += 1

                _t = ":"; self._pos = _p178
              end while false

              break if _t == BaseParser.__ERROR__

              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

              _t=self.expr();
              b2 = _t

              raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

              _t=["And", b1, b2];
              raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p179 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p180 = _pos; _t=nil
            begin  # and (inner)
              _t=self.empty();
              break if _t == BaseParser.__ERROR__

              _t=b1;
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p180 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
        end while false

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p181 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.ruleStuff", _start, _t))
    BaseParser.__ERROR__.last = "ruleStuff" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def qualifiers:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('qualifiers')
    _t = _sretrieve("MMetaParser.qualifiers")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    qs = Object(nil)

    begin  # and
      _p188 = _pos; _t=nil
      begin  # and (inner)
        as187 = ArrayList.new
        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p182 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _push("public"); _t=self.k();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p182 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p183 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _push("private"); _t=self.k();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p183 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p184 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _push("final"); _t=self.k();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p184 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p185 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _push("static"); _t=self.k();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p185 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p186 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _push("abstract"); _t=self.k();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p186 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
        end while false

        if (_t!=BaseParser.__ERROR__)  # plus
          as187.add(_t)
          while true  # star
            _t = BaseParser.__ERROR__
            begin  # or
              begin  # and
                _p182 = _pos; _t=nil
                begin  # and (inner)
                  if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                  break if _t == BaseParser.__ERROR__

                  _push("public"); _t=self.k();
                  break if _t == BaseParser.__ERROR__

                end while false  # and (inner)
                self._pos=_p182 if (_t==BaseParser.__ERROR__)
              end  # and

              break unless _t == BaseParser.__ERROR__
              begin  # and
                _p183 = _pos; _t=nil
                begin  # and (inner)
                  if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                  break if _t == BaseParser.__ERROR__

                  _push("private"); _t=self.k();
                  break if _t == BaseParser.__ERROR__

                end while false  # and (inner)
                self._pos=_p183 if (_t==BaseParser.__ERROR__)
              end  # and

              break unless _t == BaseParser.__ERROR__
              begin  # and
                _p184 = _pos; _t=nil
                begin  # and (inner)
                  if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                  break if _t == BaseParser.__ERROR__

                  _push("final"); _t=self.k();
                  break if _t == BaseParser.__ERROR__

                end while false  # and (inner)
                self._pos=_p184 if (_t==BaseParser.__ERROR__)
              end  # and

              break unless _t == BaseParser.__ERROR__
              begin  # and
                _p185 = _pos; _t=nil
                begin  # and (inner)
                  if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                  break if _t == BaseParser.__ERROR__

                  _push("static"); _t=self.k();
                  break if _t == BaseParser.__ERROR__

                end while false  # and (inner)
                self._pos=_p185 if (_t==BaseParser.__ERROR__)
              end  # and

              break unless _t == BaseParser.__ERROR__
              begin  # and
                _p186 = _pos; _t=nil
                begin  # and (inner)
                  if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                  break if _t == BaseParser.__ERROR__

                  _push("abstract"); _t=self.k();
                  break if _t == BaseParser.__ERROR__

                end while false  # and (inner)
                self._pos=_p186 if (_t==BaseParser.__ERROR__)
              end  # and

              break unless _t == BaseParser.__ERROR__
            end while false

            break if (_t == BaseParser.__ERROR__)
            as187.add(_t)
          end
          _t = as187

        end

        qs = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  join(qs, " ")
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p188 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.qualifiers", _start, _t))
    BaseParser.__ERROR__.last = "qualifiers" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def method:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('method')
    _t = _sretrieve("MMetaParser.method")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    s = n = as = bs = Object(nil)

    begin  # and
      _p200 = _pos; _t=nil
      begin  # and (inner)
        _t = BaseParser.__ERROR__
        _p189 = _pos
        begin
          break if _p189 + 3 > @chars.length
          break unless @chars[_p189] == 100
          _p189 += 1
          break unless @chars[_p189] == 101
          _p189 += 1
          break unless @chars[_p189] == 102
          _p189 += 1

          _t = "def"; self._pos = _p189
        end while false

        break if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          _t = BaseParser.__ERROR__
          _p190 = _pos
          begin
            break if _p190 + 5 > @chars.length
            break unless @chars[_p190] == 115
            _p190 += 1
            break unless @chars[_p190] == 101
            _p190 += 1
            break unless @chars[_p190] == 108
            _p190 += 1
            break unless @chars[_p190] == 102
            _p190 += 1
            break unless @chars[_p190] == 46
            _p190 += 1

            _t = "self."; self._pos = _p190
          end while false

          break unless _t == BaseParser.__ERROR__
          _t="";
          break unless _t == BaseParser.__ERROR__
        end while false

        s = _t

        break if _t == BaseParser.__ERROR__

        _t=self.name();
        n = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p196 = _pos; _t=nil
            begin  # and (inner)
              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _t = BaseParser.__ERROR__
              _p191 = _pos
              begin
                break if _p191 + 1 > @chars.length
                break unless @chars[_p191] == 40
                _p191 += 1

                _t = "("; self._pos = _p191
              end while false

              break if _t == BaseParser.__ERROR__

              as194 = ArrayList.new
              while true  # star
                begin  # and
                  _p193 = _pos; _t=nil
                  begin  # and (inner)
                    _t = BaseParser.__ERROR__
                    _p192 = _pos
                    begin
                      break if _p192 + 1 > @chars.length
                      break unless @chars[_p192] == 41
                      _p192 += 1

                      _t = ")"; self._pos = _p192
                    end while false

                    _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

                    break if _t == BaseParser.__ERROR__

                    _t=self._any();
                    break if _t == BaseParser.__ERROR__

                  end while false  # and (inner)
                  self._pos=_p193 if (_t==BaseParser.__ERROR__)
                end  # and

                break if (_t == BaseParser.__ERROR__)
                as194.add(_t)
              end
              _t = as194


              as = _t

              break if _t == BaseParser.__ERROR__

              _t = BaseParser.__ERROR__
              _p195 = _pos
              begin
                break if _p195 + 1 > @chars.length
                break unless @chars[_p195] == 41
                _p195 += 1

                _t = ")"; self._pos = _p195
              end while false

              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p196 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          _t="";
          break unless _t == BaseParser.__ERROR__
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p197 = _pos
        begin
          break if _p197 + 1 > @chars.length
          break unless @chars[_p197] == 123
          _p197 += 1

          _t = "{"; self._pos = _p197
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        as198 = ArrayList.new
        while true  # star
          _t=self.cbraces();
          break if (_t == BaseParser.__ERROR__)
          as198.add(_t)
        end
        _t = as198


        bs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p199 = _pos
        begin
          break if _p199 + 1 > @chars.length
          break unless @chars[_p199] == 125
          _p199 += 1

          _t = "}"; self._pos = _p199
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=["Method", "#{s}#{n}", "#{join(as)}", "#{join(bs)}"];
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p200 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.method", _start, _t))
    BaseParser.__ERROR__.last = "method" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def jimport:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('jimport')
    _t = _sretrieve("MMetaParser.jimport")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    stm = xs = Object(nil)

    begin  # and
      _p204 = _pos; _t=nil
      begin  # and (inner)
        _push("import"); _t=self.k();
        stm = _t

        break if _t == BaseParser.__ERROR__

        as202 = ArrayList.new
        while true  # star
          begin  # and
            _p201 = _pos; _t=nil
            begin  # and (inner)
              _push(";\n"); _t=self.oneOf();
              _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

              break if _t == BaseParser.__ERROR__

              _t=self._any();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p201 if (_t==BaseParser.__ERROR__)
          end  # and

          break if (_t == BaseParser.__ERROR__)
          as202.add(_t)
        end
        _t = as202


        xs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p203 = _pos
        begin
          break if _p203 + 1 > @chars.length
          break unless @chars[_p203] == 59
          _p203 += 1

          _t = ";"; self._pos = _p203
        end while false

        _t=(_string.nil? ? "" : nil) if _t == BaseParser.__ERROR__

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=["Import", "#{stm}#{join(xs)}"];
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p204 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.jimport", _start, _t))
    BaseParser.__ERROR__.last = "jimport" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def jpackage:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('jpackage')
    _t = _sretrieve("MMetaParser.jpackage")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    stm = xs = Object(nil)

    begin  # and
      _p209 = _pos; _t=nil
      begin  # and (inner)
        _push("package"); _t=self.k();
        stm = _t

        break if _t == BaseParser.__ERROR__

        as207 = ArrayList.new
        while true  # star
          begin  # and
            _p206 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p205 = _pos
              begin
                break if _p205 + 1 > @chars.length
                break unless @chars[_p205] == 59
                _p205 += 1

                _t = ";"; self._pos = _p205
              end while false

              _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

              break if _t == BaseParser.__ERROR__

              _t=self._any();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p206 if (_t==BaseParser.__ERROR__)
          end  # and

          break if (_t == BaseParser.__ERROR__)
          as207.add(_t)
        end
        _t = as207


        xs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p208 = _pos
        begin
          break if _p208 + 1 > @chars.length
          break unless @chars[_p208] == 59
          _p208 += 1

          _t = ";"; self._pos = _p208
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=["Package", "#{stm}#{join(xs)}"];
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p209 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.jpackage", _start, _t))
    BaseParser.__ERROR__.last = "jpackage" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def classdef:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('classdef')
    _t = _sretrieve("MMetaParser.classdef")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    q = xs = bs = Object(nil)

    begin  # and
      _p216 = _pos; _t=nil
      begin  # and (inner)
        _t=self.qualifiers();
        q = _t

        break if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _push("class"); _t=self.k();
        break if _t == BaseParser.__ERROR__

        as212 = ArrayList.new
        while true  # star
          begin  # and
            _p211 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              _p210 = _pos
              begin
                break if _p210 + 1 > @chars.length
                break unless @chars[_p210] == 123
                _p210 += 1

                _t = "{"; self._pos = _p210
              end while false

              _t = (_t == BaseParser.__ERROR__ ? Object(Boolean.valueOf(true)) : BaseParser.__ERROR__)

              break if _t == BaseParser.__ERROR__

              _t=self._any();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p211 if (_t==BaseParser.__ERROR__)
          end  # and

          break if (_t == BaseParser.__ERROR__)
          as212.add(_t)
        end
        _t = as212


        xs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p213 = _pos
        begin
          break if _p213 + 1 > @chars.length
          break unless @chars[_p213] == 123
          _p213 += 1

          _t = "{"; self._pos = _p213
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        as214 = ArrayList.new
        while true  # star
          _t=self.cbraces();
          break if (_t == BaseParser.__ERROR__)
          as214.add(_t)
        end
        _t = as214


        bs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p215 = _pos
        begin
          break if _p215 + 1 > @chars.length
          break unless @chars[_p215] == 125
          _p215 += 1

          _t = "}"; self._pos = _p215
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=["Class", q, " class #{join(xs)}", "#{join(bs)}"];
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p216 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.classdef", _start, _t))
    BaseParser.__ERROR__.last = "classdef" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def ruleMethod:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('ruleMethod')
    _t = _sretrieve("MMetaParser.ruleMethod")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p217 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.method();
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p217 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p218 = _pos; _t=nil
        begin  # and (inner)
          if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
          break if _t == BaseParser.__ERROR__

          _t=self.rule();
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p218 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaParser.ruleMethod", _start, _t))
    BaseParser.__ERROR__.last = "ruleMethod" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def parser:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('parser')
    _t = _sretrieve("MMetaParser.parser")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    p = n = sn = rs = Object(nil)

    begin  # and
      _p226 = _pos; _t=nil
      begin  # and (inner)
        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          _push("public"); _t=self.k();
          break unless _t == BaseParser.__ERROR__
          _t=self.empty();
          break unless _t == BaseParser.__ERROR__
        end while false

        p = _t

        break if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        break if _t == BaseParser.__ERROR__

        _push("parser"); _t=self.k();
        break if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.name();
        n = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p221 = _pos; _t=nil
            begin  # and (inner)
              _t = BaseParser.__ERROR__
              begin  # or
                _push("extends"); _t=self.k();
                break unless _t == BaseParser.__ERROR__
                begin  # and
                  _p220 = _pos; _t=nil
                  begin  # and (inner)
                    if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
                    break if _t == BaseParser.__ERROR__

                    _t = BaseParser.__ERROR__
                    _p219 = _pos
                    begin
                      break if _p219 + 1 > @chars.length
                      break unless @chars[_p219] == 60
                      _p219 += 1

                      _t = "<"; self._pos = _p219
                    end while false

                    break if _t == BaseParser.__ERROR__

                  end while false  # and (inner)
                  self._pos=_p220 if (_t==BaseParser.__ERROR__)
                end  # and

                break unless _t == BaseParser.__ERROR__
              end while false

              break if _t == BaseParser.__ERROR__

              if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
              break if _t == BaseParser.__ERROR__

              _t=self.name();
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p221 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p222 = _pos; _t=nil
            begin  # and (inner)
              _t=self.empty();
              break if _t == BaseParser.__ERROR__

              _t="BaseParser";
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p222 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
        end while false

        sn = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p223 = _pos
        begin
          break if _p223 + 1 > @chars.length
          break unless @chars[_p223] == 123
          _p223 += 1

          _t = "{"; self._pos = _p223
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        as224 = ArrayList.new
        while true  # star
          _t=self.ruleMethod();
          break if (_t == BaseParser.__ERROR__)
          as224.add(_t)
        end
        _t = as224


        rs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        _p225 = _pos
        begin
          break if _p225 + 1 > @chars.length
          break unless @chars[_p225] == 125
          _p225 += 1

          _t = "}"; self._pos = _p225
        end while false

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=concat(["Parser", p, n, sn], rs);
        p = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = begin

                             if (Boolean.getBoolean("jmeta.optimize.debug"))
                               System.out.println("Before:\n" + BaseParser.print_r(p));
                             end
                             MMetaOptimizer.new().parse(p, "optimizeGrammar");
                          
        end

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p226 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.parser", _start, _t))
    BaseParser.__ERROR__.last = "parser" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def line:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('line')
    _t = _sretrieve("MMetaParser.line")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    p = l = Object(nil)

    begin  # and
      _p227 = _pos; _t=nil
      begin  # and (inner)
        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        p = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          _t=self.parser();
          break unless _t == BaseParser.__ERROR__
          _t=self.jpackage();
          break unless _t == BaseParser.__ERROR__
          _t=self.jimport();
          break unless _t == BaseParser.__ERROR__
          _t=self.classdef();
          break unless _t == BaseParser.__ERROR__
        end while false

        l = _t

        break if _t == BaseParser.__ERROR__

        _t=["Line", "#{join(p)}", l];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p227 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.line", _start, _t))
    BaseParser.__ERROR__.last = "line" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def file:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('file')
    _t = _sretrieve("MMetaParser.file")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    ls = Object(nil)

    begin  # and
      _p229 = _pos; _t=nil
      begin  # and (inner)
        as228 = ArrayList.new
        while true  # star
          _t=self.line();
          break if (_t == BaseParser.__ERROR__)
          as228.add(_t)
        end
        _t = as228


        ls = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        if _start == _pos;_t=ws();_real_start=_pos;nil;else;_t=ws();end;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=concat(["File"], ls);
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p229 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaParser.file", _start, _t))
    BaseParser.__ERROR__.last = "file" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def start:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('start')
    _t = _sretrieve("MMetaParser.start")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _t=self.file();
    _t = _exit(_memoize("MMetaParser.start", _start, _t))
    BaseParser.__ERROR__.last = "start" if (_t==BaseParser.__ERROR__)
    return _t
  end


  def _jump(r:String)
    return fromTo() if (r == "fromTo")
    return sp() if (r == "sp")
    return ws() if (r == "ws")
    return listOf() if (r == "listOf")
    return nameFirst() if (r == "nameFirst")
    return nameRest() if (r == "nameRest")
    return name() if (r == "name")
    return rulename() if (r == "rulename")
    return varname() if (r == "varname")
    return hex() if (r == "hex")
    return echar() if (r == "echar")
    return tsString() if (r == "tsString")
    return dollar() if (r == "dollar")
    return dollarstring() if (r == "dollarstring")
    return string() if (r == "string")
    return number() if (r == "number")
    return symbol() if (r == "symbol")
    return k() if (r == "k")
    return error() if (r == "error")
    return any() if (r == "any")
    return wsdot() if (r == "wsdot")
    return args() if (r == "args")
    return application() if (r == "application")
    return fname() if (r == "fname")
    return parens() if (r == "parens")
    return rewrite_expr() if (r == "rewrite_expr")
    return simplehost() if (r == "simplehost")
    return simplehost1() if (r == "simplehost1")
    return cbraces() if (r == "cbraces")
    return semAction() if (r == "semAction")
    return semPred() if (r == "semPred")
    return synPred() if (r == "synPred")
    return synPredTail() if (r == "synPredTail")
    return token() if (r == "token")
    return tokens() if (r == "tokens")
    return expr() if (r == "expr")
    return expr4() if (r == "expr4")
    return optIter() if (r == "optIter")
    return expr3() if (r == "expr3")
    return expr2() if (r == "expr2")
    return expr1() if (r == "expr1")
    return rule() if (r == "rule")
    return rulePart() if (r == "rulePart")
    return ruleStuff() if (r == "ruleStuff")
    return qualifiers() if (r == "qualifiers")
    return method() if (r == "method")
    return jimport() if (r == "jimport")
    return jpackage() if (r == "jpackage")
    return classdef() if (r == "classdef")
    return ruleMethod() if (r == "ruleMethod")
    return parser() if (r == "parser")
    return line() if (r == "line")
    return file() if (r == "file")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "fromTo")
    return true if (r == "sp")
    return true if (r == "ws")
    return true if (r == "listOf")
    return true if (r == "nameFirst")
    return true if (r == "nameRest")
    return true if (r == "name")
    return true if (r == "rulename")
    return true if (r == "varname")
    return true if (r == "hex")
    return true if (r == "echar")
    return true if (r == "tsString")
    return true if (r == "dollar")
    return true if (r == "dollarstring")
    return true if (r == "string")
    return true if (r == "number")
    return true if (r == "symbol")
    return true if (r == "k")
    return true if (r == "error")
    return true if (r == "any")
    return true if (r == "wsdot")
    return true if (r == "args")
    return true if (r == "application")
    return true if (r == "fname")
    return true if (r == "parens")
    return true if (r == "rewrite_expr")
    return true if (r == "simplehost")
    return true if (r == "simplehost1")
    return true if (r == "cbraces")
    return true if (r == "semAction")
    return true if (r == "semPred")
    return true if (r == "synPred")
    return true if (r == "synPredTail")
    return true if (r == "token")
    return true if (r == "tokens")
    return true if (r == "expr")
    return true if (r == "expr4")
    return true if (r == "optIter")
    return true if (r == "expr3")
    return true if (r == "expr2")
    return true if (r == "expr1")
    return true if (r == "rule")
    return true if (r == "rulePart")
    return true if (r == "ruleStuff")
    return true if (r == "qualifiers")
    return true if (r == "method")
    return true if (r == "jimport")
    return true if (r == "jpackage")
    return true if (r == "classdef")
    return true if (r == "ruleMethod")
    return true if (r == "parser")
    return true if (r == "line")
    return true if (r == "file")
    return true if (r == "start")
    super(r)
  end
end


class MMetaPass < BaseParser
  def _init

    @chars = _chars
    super()

  end

  def init()

        @changed = false
      
  end


  def changed()

        @changed
      
  end


  def changed_set(value:boolean)

        @changed = value
      
  end


  def setChanged:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('setChanged')
    _t = _sretrieve("MMetaPass.setChanged")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    _t = begin
      @changed = true; nil;
    end

    _t = _exit(_memoize("MMetaPass.setChanged", _start, _t))
    BaseParser.__ERROR__.last = "setChanged" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def destruct:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('destruct')
    _t = _sretrieve("MMetaPass.destruct")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    r = x = Object(nil)

    begin  # and
      _p230 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        r = _t

        break if _t == BaseParser.__ERROR__

        _t = ( hasRule(r) ) ? nil : BaseParser.__ERROR__

        break if _t == BaseParser.__ERROR__

        _push(r); _t=self.apply();
        x = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=x;
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p230 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.destruct", _start, _t))
    BaseParser.__ERROR__.last = "destruct" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def trans:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('trans')
    _t = _sretrieve("MMetaPass.trans")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p231 = _pos; _t=nil
        begin  # and (inner)
          _t = _listBegin()
          if (_t != BaseParser.__ERROR__)
            _t=self.destruct();
            x = _t

            _listEnd()
          end

          break if _t == BaseParser.__ERROR__

          _t=x;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p231 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      _t=self._any();
      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaPass.trans", _start, _t))
    BaseParser.__ERROR__.last = "trans" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Or:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Or')
    _t = _sretrieve("MMetaPass.Or")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p233 = _pos; _t=nil
      begin  # and (inner)
        as232 = ArrayList.new
        while true  # star
          _t=self.trans();
          break if (_t == BaseParser.__ERROR__)
          as232.add(_t)
        end
        _t = as232


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t=concat(["Or"], xs);
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p233 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.Or", _start, _t))
    BaseParser.__ERROR__.last = "Or" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def And:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('And')
    _t = _sretrieve("MMetaPass.And")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p235 = _pos; _t=nil
      begin  # and (inner)
        as234 = ArrayList.new
        while true  # star
          _t=self.trans();
          break if (_t == BaseParser.__ERROR__)
          as234.add(_t)
        end
        _t = as234


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t=concat(["And"], xs);
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p235 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.And", _start, _t))
    BaseParser.__ERROR__.last = "And" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Not:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Not')
    _t = _sretrieve("MMetaPass.Not")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    begin  # and
      _p236 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=["Not", x];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p236 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.Not", _start, _t))
    BaseParser.__ERROR__.last = "Not" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Many:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many')
    _t = _sretrieve("MMetaPass.Many")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    begin  # and
      _p237 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=["Many", x];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p237 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.Many", _start, _t))
    BaseParser.__ERROR__.last = "Many" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Many1:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Many1')
    _t = _sretrieve("MMetaPass.Many1")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    begin  # and
      _p238 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=["Many1", x];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p238 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.Many1", _start, _t))
    BaseParser.__ERROR__.last = "Many1" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Peek:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Peek')
    _t = _sretrieve("MMetaPass.Peek")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    begin  # and
      _p239 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=["Peek", x];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p239 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.Peek", _start, _t))
    BaseParser.__ERROR__.last = "Peek" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def List:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('List')
    _t = _sretrieve("MMetaPass.List")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = Object(nil)

    begin  # and
      _p240 = _pos; _t=nil
      begin  # and (inner)
        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=["List", x];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p240 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.List", _start, _t))
    BaseParser.__ERROR__.last = "List" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Set:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Set')
    _t = _sretrieve("MMetaPass.Set")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    n = x = Object(nil)

    begin  # and
      _p241 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=["Set", n, x];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p241 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.Set", _start, _t))
    BaseParser.__ERROR__.last = "Set" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Rule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Rule')
    _t = _sretrieve("MMetaPass.Rule")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    n = x = Object(nil)

    begin  # and
      _p242 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        n = _t

        break if _t == BaseParser.__ERROR__

        _t=self.trans();
        x = _t

        break if _t == BaseParser.__ERROR__

        _t=["Rule", n, x];
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p242 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.Rule", _start, _t))
    BaseParser.__ERROR__.last = "Rule" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def SynPred:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('SynPred')
    _t = _sretrieve("MMetaPass.SynPred")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    xs = Object(nil)

    begin  # and
      _p244 = _pos; _t=nil
      begin  # and (inner)
        as243 = ArrayList.new
        while true  # star
          _t=self.trans();
          break if (_t == BaseParser.__ERROR__)
          as243.add(_t)
        end
        _t = as243


        xs = _t

        break if _t == BaseParser.__ERROR__

        _t=concat(["SynPred"], xs);
        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p244 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaPass.SynPred", _start, _t))
    BaseParser.__ERROR__.last = "SynPred" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def start:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('start')
    _t = _sretrieve("MMetaPass.start")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    r = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p245 = _pos; _t=nil
        begin  # and (inner)
          _t=self.destruct();
          r = _t

          break if _t == BaseParser.__ERROR__

          _t=self.end();
          break if _t == BaseParser.__ERROR__

          _t=r;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p245 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p246 = _pos; _t=nil
        begin  # and (inner)
          _t=self._any();
          r = _t

          break if _t == BaseParser.__ERROR__

          _t=self.end();
          break if _t == BaseParser.__ERROR__

          _t=r;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p246 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p248 = _pos; _t=nil
        begin  # and (inner)
          as247 = ArrayList.new
          while true  # star
            _t=self._any();
            break if (_t == BaseParser.__ERROR__)
            as247.add(_t)
          end
          _t = as247


          r = _t

          break if _t == BaseParser.__ERROR__

          _t=self.end();
          break if _t == BaseParser.__ERROR__

          _t=r;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p248 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaPass.start", _start, _t))
    BaseParser.__ERROR__.last = "start" if (_t==BaseParser.__ERROR__)
    return _t
  end


  def _jump(r:String)
    return setChanged() if (r == "setChanged")
    return destruct() if (r == "destruct")
    return trans() if (r == "trans")
    return Or() if (r == "Or")
    return And() if (r == "And")
    return Not() if (r == "Not")
    return Many() if (r == "Many")
    return Many1() if (r == "Many1")
    return Peek() if (r == "Peek")
    return List() if (r == "List")
    return Set() if (r == "Set")
    return Rule() if (r == "Rule")
    return SynPred() if (r == "SynPred")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "setChanged")
    return true if (r == "destruct")
    return true if (r == "trans")
    return true if (r == "Or")
    return true if (r == "And")
    return true if (r == "Not")
    return true if (r == "Many")
    return true if (r == "Many1")
    return true if (r == "Peek")
    return true if (r == "List")
    return true if (r == "Set")
    return true if (r == "Rule")
    return true if (r == "SynPred")
    return true if (r == "start")
    super(r)
  end
end


class MMetaAndOrOpt < MMetaPass
  def _init

    @chars = _chars
    super()

  end

  def And:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('And')
    _t = _sretrieve("MMetaAndOrOpt.And")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = xs = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p249 = _pos; _t=nil
        begin  # and (inner)
          _t=self.trans();
          x = _t

          break if _t == BaseParser.__ERROR__

          _t=self.end();
          break if _t == BaseParser.__ERROR__

          _t=self.setChanged();
          break if _t == BaseParser.__ERROR__

          _t=x;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p249 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p250 = _pos; _t=nil
        begin  # and (inner)
          _push("And"); _t=self.transInside();
          xs = _t

          break if _t == BaseParser.__ERROR__

          _t=concat(["And"], xs);
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p250 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaAndOrOpt.And", _start, _t))
    BaseParser.__ERROR__.last = "And" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def Or:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('Or')
    _t = _sretrieve("MMetaAndOrOpt.Or")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    x = xs = Object(nil)

    _t = BaseParser.__ERROR__
    begin  # or
      begin  # and
        _p251 = _pos; _t=nil
        begin  # and (inner)
          _t=self.trans();
          x = _t

          break if _t == BaseParser.__ERROR__

          _t=self.end();
          break if _t == BaseParser.__ERROR__

          _t=self.setChanged();
          break if _t == BaseParser.__ERROR__

          _t=x;
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p251 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
      begin  # and
        _p252 = _pos; _t=nil
        begin  # and (inner)
          _push("Or"); _t=self.transInside();
          xs = _t

          break if _t == BaseParser.__ERROR__

          _t=concat(["Or"], xs);
          break if _t == BaseParser.__ERROR__

        end while false  # and (inner)
        self._pos=_p252 if (_t==BaseParser.__ERROR__)
      end  # and

      break unless _t == BaseParser.__ERROR__
    end while false

    _t = _exit(_memoize("MMetaAndOrOpt.Or", _start, _t))
    BaseParser.__ERROR__.last = "Or" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def transInside:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('transInside')
    _t = _sretrieve("MMetaAndOrOpt.transInside")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    s = xs = ys = x = Object(nil)

    begin  # and
      _p256 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        s = _t

        break if _t == BaseParser.__ERROR__

        _t = BaseParser.__ERROR__
        begin  # or
          begin  # and
            _p254 = _pos; _t=nil
            begin  # and (inner)
              _t = _listBegin()
              if (_t != BaseParser.__ERROR__)
                begin  # and
                  _p253 = _pos; _t=nil
                  begin  # and (inner)
                    _push(s); _t=self.sym();
                    break if _t == BaseParser.__ERROR__

                    _push(s); _t=self.transInside();
                    xs = _t

                    break if _t == BaseParser.__ERROR__

                  end while false  # and (inner)
                  self._pos=_p253 if (_t==BaseParser.__ERROR__)
                end  # and

                _listEnd()
              end

              break if _t == BaseParser.__ERROR__

              _push(s); _t=self.transInside();
              ys = _t

              break if _t == BaseParser.__ERROR__

              _t=self.setChanged();
              break if _t == BaseParser.__ERROR__

              _t=concat(xs, ys);
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p254 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          begin  # and
            _p255 = _pos; _t=nil
            begin  # and (inner)
              _t=self.trans();
              x = _t

              break if _t == BaseParser.__ERROR__

              _push(s); _t=self.transInside();
              xs = _t

              break if _t == BaseParser.__ERROR__

              _t=concat([x], xs);
              break if _t == BaseParser.__ERROR__

            end while false  # and (inner)
            self._pos=_p255 if (_t==BaseParser.__ERROR__)
          end  # and

          break unless _t == BaseParser.__ERROR__
          _t=ArrayList.new;
          break unless _t == BaseParser.__ERROR__
        end while false

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p256 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaAndOrOpt.transInside", _start, _t))
    BaseParser.__ERROR__.last = "transInside" if (_t==BaseParser.__ERROR__)
    return _t
  end


  def _jump(r:String)
    return And() if (r == "And")
    return Or() if (r == "Or")
    return transInside() if (r == "transInside")
    super(r)
  end

  def _has(r:String)
    return true if (r == "And")
    return true if (r == "Or")
    return true if (r == "transInside")
    super(r)
  end
end


class MMetaOptimizer < BaseParser
  def _init

    @chars = _chars
    super()

  end

  def optimizeGrammar:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('optimizeGrammar')
    _t = _sretrieve("MMetaOptimizer.optimizeGrammar")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    p = n = sn = rs = x = Object(nil)

    begin  # and
      _p258 = _pos; _t=nil
      begin  # and (inner)
        _t=_sym("Parser");
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self._any();
        p = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self._any();
        n = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self._any();
        sn = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        as257 = ArrayList.new
        while true  # star
          _t=self.optimizeRule();
          break if (_t == BaseParser.__ERROR__)
          as257.add(_t)
        end
        _t = as257


        rs = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=self.end();
        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t=concat(["Parser", p, n, sn], rs);
        x = _t

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

        _t = begin

                                 if (Boolean.getBoolean("jmeta.optimize.debug"))
                                   System.out.println("Opt:\n" + BaseParser.print_r(x))
                                 end
                                 x
                               
        end

        raise SyntaxError.new("", _pos, _string, _list) if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p258 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaOptimizer.optimizeGrammar", _start, _t))
    BaseParser.__ERROR__.last = "optimizeGrammar" if (_t==BaseParser.__ERROR__)
    return _t
  end

  def optimizeRule:Object
    _t = Object(nil); _start = _pos; _real_start = -1
    _enter('optimizeRule')
    _t = _sretrieve("MMetaOptimizer.optimizeRule")
    return _exit(_t) if (_t != BaseParser.__NOT_MEMOIZED__)
    r = Object(nil)

    begin  # and
      _p259 = _pos; _t=nil
      begin  # and (inner)
        _t=self._any();
        r = _t

        break if _t == BaseParser.__ERROR__

        _t = begin

                  MMetaAndOrOpt opt = MMetaAndOrOpt.new()
                  begin
                      opt.changed = false
                      r = opt.parse(r)
                  end while (opt.changed)
                  r
              
        end

        break if _t == BaseParser.__ERROR__

      end while false  # and (inner)
      self._pos=_p259 if (_t==BaseParser.__ERROR__)
    end  # and

    _t = _exit(_memoize("MMetaOptimizer.optimizeRule", _start, _t))
    BaseParser.__ERROR__.last = "optimizeRule" if (_t==BaseParser.__ERROR__)
    return _t
  end


  def _jump(r:String)
    return optimizeGrammar() if (r == "optimizeGrammar")
    return optimizeRule() if (r == "optimizeRule")
    super(r)
  end

  def _has(r:String)
    return true if (r == "optimizeGrammar")
    return true if (r == "optimizeRule")
    super(r)
  end
end
