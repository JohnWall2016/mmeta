# generated by mmeta on Thu May 12 10:20:20 PDT 2011
# do not modify, instead edit original .mmeta file
import java.util.ArrayList
import java.util.Date
import java.util.List
import java.util.EnumSet
import mmeta.*
import java.util.*

class MMetaParser < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  def oneOf(chars:String)
    
          return _char(chars)
        
  end
  

  
  def fromTo(x:String, y:String)
    throws RuleFailure
    begin
      _start = _pos
      begin
        _p2 = _pos
        begin
          self.str(x)
          begin
            as1 = ArrayList.new
            begin
              while true do
                _li = Object(
                  begin
                    _p0 = _pos
                    begin
                      begin  # not
                        self.str(y)
                        nil
                      rescue RuleFailure
                        nil  # expected
                      else
                        raise @error
                      end
                      self._any()
                    rescue RuleFailure => ex
                      self._pos = _p0
                      raise ex
                    end
                  end
                )
                as1.add(_li)
              end
            rescue RuleFailure; end
            as1
          end
          self.str(y)
        rescue RuleFailure => ex
          self._pos = _p2
          raise ex
        end
      end
    rescue RuleFailure => ex
      ex.last = 'fromTo'
      raise ex
    end
  end
  

  
  def sp
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.sp")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            super()
          rescue RuleFailure
            begin
              self.fromTo("//", "\n")
            rescue RuleFailure
              begin
                self.fromTo("/*", "*/")
              rescue RuleFailure
                self.fromTo("#", "\n")
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.sp", _start, ex)
      else
        _t = _memoize("MMetaParser.sp", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'sp'
      raise ex
    end
  end
  

  
  def ws
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.ws")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            as3 = ArrayList.new
            begin
              while true do
                _li = Object(
                  begin
                    self.sp()
                  rescue RuleFailure
                    self.nl()
                  end
                )
                as3.add(_li)
              end
            rescue RuleFailure; end
            as3
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ws", _start, ex)
      else
        _t = _memoize("MMetaParser.ws", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ws'
      raise ex
    end
  end
  

  
  def listOf(e:String, s:String)
    throws RuleFailure
    begin
      _start = _pos; f = nil; rs = nil
      begin
        begin
          _p6 = _pos
          begin
            if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
            f = (
              self.apply(e)
            )
            rs = (
              begin
                as5 = ArrayList.new
                begin
                  while true do
                    _li = Object(
                      begin
                        _p4 = _pos
                        begin
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          self.str(s)
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          self.apply(e)
                        rescue RuleFailure => ex
                          self._pos = _p4
                          raise ex
                        end
                      end
                    )
                    as5.add(_li)
                  end
                rescue RuleFailure; end
                as5
              end
            )
            concat([f], rs)
          rescue RuleFailure => ex
            self._pos = _p6
            raise ex
          end
        end
      rescue RuleFailure
        begin
          _p7 = _pos
          begin
            self.empty()
            ArrayList.new
          rescue RuleFailure => ex
            self._pos = _p7
            raise ex
          end
        end
      end
    rescue RuleFailure => ex
      ex.last = 'listOf'
      raise ex
    end
  end
  

  
  def nameFirst
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.nameFirst")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            if _string.startsWith("_", _pos)
              self._pos += 1
              "_"
            else
              raise @error
            end
          rescue RuleFailure
            self.letter()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.nameFirst", _start, ex)
      else
        _t = _memoize("MMetaParser.nameFirst", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'nameFirst'
      raise ex
    end
  end
  

  
  def nameRest
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.nameRest")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            self.nameFirst()
          rescue RuleFailure
            self.digit()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.nameRest", _start, ex)
      else
        _t = _memoize("MMetaParser.nameRest", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'nameRest'
      raise ex
    end
  end
  

  
  def name
    throws RuleFailure
    begin
      _start = _pos; f = nil; rs = nil
      _t = _sretrieve("MMetaParser.name")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p10 = _pos
            begin
              f = (
                self.nameFirst()
              )
              rs = (
                begin
                  as9 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.nameRest()
                      )
                      as9.add(_li)
                    end
                  rescue RuleFailure; end
                  as9
                end
              )
              begin
                 join(concat([f], rs)) 
              end
            rescue RuleFailure => ex
              self._pos = _p10
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.name", _start, ex)
      else
        _t = _memoize("MMetaParser.name", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'name'
      raise ex
    end
  end
  

  
  def rulename
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.rulename")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p11 = _pos
            begin
              begin  # not
                self.k("def")
                nil
              rescue RuleFailure
                nil  # expected
              else
                raise @error
              end
              begin  # not
                self.k("macro")
                nil
              rescue RuleFailure
                nil  # expected
              else
                raise @error
              end
              self.name()
            rescue RuleFailure => ex
              self._pos = _p11
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rulename", _start, ex)
      else
        _t = _memoize("MMetaParser.rulename", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rulename'
      raise ex
    end
  end
  

  
  def varname
    throws RuleFailure
    begin
      _start = _pos; p = nil; n = nil
      _t = _sretrieve("MMetaParser.varname")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p13 = _pos
            begin
              p = (
                begin
                  if _string.startsWith("@", _pos)
                    self._pos += 1
                    "@"
                  else
                    raise @error
                  end
                rescue RuleFailure
                  ""
                end
              )
              n = (
                self.name()
              )
              "#{p}#{n}"
            rescue RuleFailure => ex
              self._pos = _p13
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.varname", _start, ex)
      else
        _t = _memoize("MMetaParser.varname", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'varname'
      raise ex
    end
  end
  

  
  def hex
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.hex")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          self.oneOf("0123456789abcdefABCDEF")
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.hex", _start, ex)
      else
        _t = _memoize("MMetaParser.hex", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'hex'
      raise ex
    end
  end
  

  
  def echar
    throws RuleFailure
    begin
      _start = _pos; c = nil
      _t = _sretrieve("MMetaParser.echar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p16 = _pos
              begin
                if _string.startsWith("\\", _pos)
                  self._pos += 1
                  "\\"
                else
                  raise @error
                end
                begin
                  begin
                    _p15 = _pos
                    begin
                      c = (
                        self._any()
                      )
                      begin
                         "\\#{c}"; 
                      end
                    rescue RuleFailure => ex
                      self._pos = _p15
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p16
                raise ex
              end
            end
          rescue RuleFailure
            self._any()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.echar", _start, ex)
      else
        _t = _memoize("MMetaParser.echar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'echar'
      raise ex
    end
  end
  

  
  def tsString
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.tsString")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p22 = _pos
            begin
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              xs = (
                begin
                  as20 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p19 = _pos
                          begin
                            begin  # not
                              if _string.startsWith("\"", _pos)
                                self._pos += 1
                                "\""
                              else
                                raise @error
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            self.echar()
                          rescue RuleFailure => ex
                            self._pos = _p19
                            raise ex
                          end
                        end
                      )
                      as20.add(_li)
                    end
                  rescue RuleFailure; end
                  as20
                end
              )
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              begin
                 join(xs) 
              end
            rescue RuleFailure => ex
              self._pos = _p22
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.tsString", _start, ex)
      else
        _t = _memoize("MMetaParser.tsString", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'tsString'
      raise ex
    end
  end
  

  
  def dollar
    throws RuleFailure
    begin
      _start = _pos; xs = nil; n = nil
      _t = _sretrieve("MMetaParser.dollar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p26 = _pos
              begin
                if _string.startsWith("${", _pos)
                  self._pos += 2
                  "${"
                else
                  raise @error
                end
                xs = (
                  begin
                    as24 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.cbraces()
                        )
                        as24.add(_li)
                      end
                    rescue RuleFailure; end
                    as24
                  end
                )
                if _string.startsWith("}", _pos)
                  self._pos += 1
                  "}"
                else
                  raise @error
                end
                "\"+#{join(xs)}+\""
              rescue RuleFailure => ex
                self._pos = _p26
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p28 = _pos
              begin
                if _string.startsWith("$", _pos)
                  self._pos += 1
                  "$"
                else
                  raise @error
                end
                n = (
                  self.name()
                )
                "\"+#{n}+\""
              rescue RuleFailure => ex
                self._pos = _p28
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.dollar", _start, ex)
      else
        _t = _memoize("MMetaParser.dollar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'dollar'
      raise ex
    end
  end
  

  
  def dollarstring
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.dollarstring")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p34 = _pos
            begin
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              xs = (
                begin
                  as32 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p31 = _pos
                          begin
                            begin  # not
                              if _string.startsWith("\"", _pos)
                                self._pos += 1
                                "\""
                              else
                                raise @error
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            begin
                              self.dollar()
                            rescue RuleFailure
                              self.echar()
                            end
                          rescue RuleFailure => ex
                            self._pos = _p31
                            raise ex
                          end
                        end
                      )
                      as32.add(_li)
                    end
                  rescue RuleFailure; end
                  as32
                end
              )
              if _string.startsWith("\"", _pos)
                self._pos += 1
                "\""
              else
                raise @error
              end
              begin
                 join(xs) 
              end
            rescue RuleFailure => ex
              self._pos = _p34
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.dollarstring", _start, ex)
      else
        _t = _memoize("MMetaParser.dollarstring", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'dollarstring'
      raise ex
    end
  end
  

  
  def string
    throws RuleFailure
    begin
      _start = _pos; s = nil
      _t = _sretrieve("MMetaParser.string")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p35 = _pos
            begin
              s = (
                self.tsString()
              )
              ["Str", s]
            rescue RuleFailure => ex
              self._pos = _p35
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.string", _start, ex)
      else
        _t = _memoize("MMetaParser.string", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'string'
      raise ex
    end
  end
  

  
  def number
    throws RuleFailure
    begin
      _start = _pos; sign = nil; ds = nil
      _t = _sretrieve("MMetaParser.number")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p39 = _pos
            begin
              sign = (
                begin
                  if _string.startsWith("-", _pos)
                    self._pos += 1
                    "-"
                  else
                    raise @error
                  end
                rescue RuleFailure
                  begin
                    if _string.startsWith("+", _pos)
                      self._pos += 1
                      "+"
                    else
                      raise @error
                    end
                  rescue RuleFailure
                    self.empty()
                  end
                end
              )
              ds = (
                begin
                  as38 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.digit()
                      )
                      as38.add(_li)
                    end
                  rescue RuleFailure; end
                  raise @error if as38.size == 0
                  as38
                end
              )
              ["HLit", "#{sign}#{join(ds)}"]
            rescue RuleFailure => ex
              self._pos = _p39
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.number", _start, ex)
      else
        _t = _memoize("MMetaParser.number", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'number'
      raise ex
    end
  end
  

  
  def symbol
    throws RuleFailure
    begin
      _start = _pos; s = nil; c = nil
      _t = _sretrieve("MMetaParser.symbol")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p48 = _pos
            begin
              begin
                if _string.startsWith("'", _pos)
                  self._pos += 1
                  "'"
                else
                  raise @error
                end
              rescue RuleFailure
                if _string.startsWith(":", _pos)
                  self._pos += 1
                  ":"
                else
                  raise @error
                end
              end
              begin
                s = (
                  self.name()
                )
              rescue RuleFailure
                begin
                  _p47 = _pos
                  begin
                    if _string.startsWith("'", _pos)
                      self._pos += 1
                      "'"
                    else
                      raise @error
                    end
                    c = (
                      begin
                        as45 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p44 = _pos
                                begin
                                  begin  # not
                                    if _string.startsWith("'", _pos)
                                      self._pos += 1
                                      "'"
                                    else
                                      raise @error
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p44
                                  raise ex
                                end
                              end
                            )
                            as45.add(_li)
                          end
                        rescue RuleFailure; end
                        raise @error if as45.size == 0
                        as45
                      end
                    )
                    if _string.startsWith("'", _pos)
                      self._pos += 1
                      "'"
                    else
                      raise @error
                    end
                    s = (
                      begin
                        join(c)
                      end
                    )
                  rescue RuleFailure => ex
                    self._pos = _p47
                    raise ex
                  end
                end
              end
              ["Sym", s]
            rescue RuleFailure => ex
              self._pos = _p48
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.symbol", _start, ex)
      else
        _t = _memoize("MMetaParser.symbol", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'symbol'
      raise ex
    end
  end
  

  
  def k(keyword:String)
    throws RuleFailure
    begin
      _start = _pos
      begin
        _p49 = _pos
        begin
          self.str(keyword)
          begin  # not
            begin
              self.nameFirst()
            rescue RuleFailure
              self.digit()
            end
            nil
          rescue RuleFailure
            nil  # expected
          else
            raise @error
          end
          keyword
        rescue RuleFailure => ex
          self._pos = _p49
          raise ex
        end
      end
    rescue RuleFailure => ex
      ex.last = 'k'
      raise ex
    end
  end
  

  
  def error
    throws RuleFailure
    begin
      _start = _pos; msg = nil; b = nil
      _t = _sretrieve("MMetaParser.error")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p51 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              if _string.startsWith("!", _pos)
                self._pos += 1
                "!"
              else
                raise @error
              end
              msg = (
                begin
                  self.dollarstring()
                rescue RuleFailure
                  self.empty()
                end
              )
              b = (
                self.expr4()
              )
              ["Error", msg, b]
            rescue RuleFailure => ex
              self._pos = _p51
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.error", _start, ex)
      else
        _t = _memoize("MMetaParser.error", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'error'
      raise ex
    end
  end
  

  
  def any
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.any")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p53 = _pos
            begin
              if _string.startsWith("_", _pos)
                self._pos += 1
                "_"
              else
                raise @error
              end
              ["App", "_any"]
            rescue RuleFailure => ex
              self._pos = _p53
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.any", _start, ex)
      else
        _t = _memoize("MMetaParser.any", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'any'
      raise ex
    end
  end
  

  
  def wsdot
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.wsdot")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p55 = _pos
            begin
              if _string.startsWith(".", _pos)
                self._pos += 1
                "."
              else
                raise @error
              end
              ["Dot"]
            rescue RuleFailure => ex
              self._pos = _p55
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.wsdot", _start, ex)
      else
        _t = _memoize("MMetaParser.wsdot", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'wsdot'
      raise ex
    end
  end
  

  
  def args
    throws RuleFailure
    begin
      _start = _pos; as = nil
      _t = _sretrieve("MMetaParser.args")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p59 = _pos
              begin
                if _string.startsWith("(", _pos)
                  self._pos += 1
                  "("
                else
                  raise @error
                end
                begin
                  begin
                    _p58 = _pos
                    begin
                      as = (
                        self.listOf("simplehost", ",")
                      )
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      if _string.startsWith(")", _pos)
                        self._pos += 1
                        ")"
                      else
                        raise @error
                      end
                      as
                    rescue RuleFailure => ex
                      self._pos = _p58
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p59
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p60 = _pos
              begin
                self.empty()
                ArrayList.new
              rescue RuleFailure => ex
                self._pos = _p60
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.args", _start, ex)
      else
        _t = _memoize("MMetaParser.args", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'args'
      raise ex
    end
  end
  

  
  def application
    throws RuleFailure
    begin
      _start = _pos; r = nil; as = nil
      _t = _sretrieve("MMetaParser.application")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p63 = _pos
              begin
                if _string.startsWith("super.", _pos)
                  self._pos += 6
                  "super."
                else
                  raise @error
                end
                begin
                  begin
                    _p62 = _pos
                    begin
                      r = (
                        self.name()
                      )
                      as = (
                        self.args()
                      )
                      concat(["App", "super", r], as)
                    rescue RuleFailure => ex
                      self._pos = _p62
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p63
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p64 = _pos
              begin
                r = (
                  self.name()
                )
                as = (
                  self.args()
                )
                concat(["App", r], as)
              rescue RuleFailure => ex
                self._pos = _p64
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.application", _start, ex)
      else
        _t = _memoize("MMetaParser.application", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'application'
      raise ex
    end
  end
  

  
  def fname
    throws RuleFailure
    begin
      _start = _pos; x = nil; t = nil; n = nil
      _t = _sretrieve("MMetaParser.fname")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p68 = _pos
            begin
              t = (
                begin
                  as67 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p66 = _pos
                          begin
                            x = (
                              self.name()
                            )
                            if _string.startsWith(".", _pos)
                              self._pos += 1
                              "."
                            else
                              raise @error
                            end
                            "#{x}."
                          rescue RuleFailure => ex
                            self._pos = _p66
                            raise ex
                          end
                        end
                      )
                      as67.add(_li)
                    end
                  rescue RuleFailure; end
                  as67
                end
              )
              n = (
                self.name()
              )
              "#{join(t)}#{n}"
            rescue RuleFailure => ex
              self._pos = _p68
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.fname", _start, ex)
      else
        _t = _memoize("MMetaParser.fname", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'fname'
      raise ex
    end
  end
  

  
  def parens
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaParser.parens")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p73 = _pos
            begin
              if _string.startsWith("(", _pos)
                self._pos += 1
                "("
              else
                raise @error
              end
              x = (
                begin
                  as71 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          self.parens()
                        rescue RuleFailure
                          begin
                            _p70 = _pos
                            begin
                              begin  # not
                                self.oneOf("()")
                                nil
                              rescue RuleFailure
                                nil  # expected
                              else
                                raise @error
                              end
                              self._any()
                            rescue RuleFailure => ex
                              self._pos = _p70
                              raise ex
                            end
                          end
                        end
                      )
                      as71.add(_li)
                    end
                  rescue RuleFailure; end
                  as71
                end
              )
              if _string.startsWith(")", _pos)
                self._pos += 1
                ")"
              else
                raise @error
              end
              "(#{join(x)})"
            rescue RuleFailure => ex
              self._pos = _p73
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.parens", _start, ex)
      else
        _t = _memoize("MMetaParser.parens", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'parens'
      raise ex
    end
  end
  

  
  def rewrite_expr
    throws RuleFailure
    begin
      _start = _pos; n = nil; p = nil; c = nil; cl = nil; s = nil; xs = nil
      _t = _sretrieve("MMetaParser.rewrite_expr")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p74 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                n = (
                  self.name()
                )
                p = (
                  self.parens()
                )
                ["HLit", "#{n}#{p}"]
              rescue RuleFailure => ex
                self._pos = _p74
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p77 = _pos
                begin
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  if _string.startsWith("^(", _pos)
                    self._pos += 2
                    "^("
                  else
                    raise @error
                  end
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  n = (
                    self.name()
                  )
                  c = (
                    self.rewrite_expr()
                  )
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  self.oneOf("*+")
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  if _string.startsWith(")", _pos)
                    self._pos += 1
                    ")"
                  else
                    raise @error
                  end
                  ["Node", n, c]
                rescue RuleFailure => ex
                  self._pos = _p77
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                begin
                  _p81 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    if _string.startsWith("^(", _pos)
                      self._pos += 2
                      "^("
                    else
                      raise @error
                    end
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    n = (
                      self.name()
                    )
                    cl = (
                      begin
                        as79 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.rewrite_expr()
                            )
                            as79.add(_li)
                          end
                        rescue RuleFailure; end
                        as79
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    if _string.startsWith(")", _pos)
                      self._pos += 1
                      ")"
                    else
                      raise @error
                    end
                    ["Node", n, concat(["HList"], cl)]
                  rescue RuleFailure => ex
                    self._pos = _p81
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p83 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      if _string.startsWith("$", _pos)
                        self._pos += 1
                        "$"
                      else
                        raise @error
                      end
                      n = (
                        self.name()
                      )
                      ["TLit", n]
                    rescue RuleFailure => ex
                      self._pos = _p83
                      raise ex
                    end
                  end
                rescue RuleFailure
                  begin
                    begin
                      _p84 = _pos
                      begin
                        if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                        s = (
                          self.tsString()
                        )
                        ["HStr", s]
                      rescue RuleFailure => ex
                        self._pos = _p84
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    begin
                      begin
                        _p85 = _pos
                        begin
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          n = (
                            self.name()
                          )
                          ["HLit", n]
                        rescue RuleFailure => ex
                          self._pos = _p85
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      begin
                        _p88 = _pos
                        begin
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          if _string.startsWith("[", _pos)
                            self._pos += 1
                            "["
                          else
                            raise @error
                          end
                          xs = (
                            self.listOf("rewrite_expr", ",")
                          )
                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                          if _string.startsWith("]", _pos)
                            self._pos += 1
                            "]"
                          else
                            raise @error
                          end
                          concat(["HList"], xs)
                        rescue RuleFailure => ex
                          self._pos = _p88
                          raise ex
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rewrite_expr", _start, ex)
      else
        _t = _memoize("MMetaParser.rewrite_expr", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rewrite_expr'
      raise ex
    end
  end
  

  
  def simplehost
    throws RuleFailure
    begin
      _start = _pos; rs = nil; ls = nil; x = nil
      _t = _sretrieve("MMetaParser.simplehost")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p90 = _pos
              begin
                rs = (
                  self.simplehost1()
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                if _string.startsWith("+", _pos)
                  self._pos += 1
                  "+"
                else
                  raise @error
                end
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                ls = (
                  self.simplehost()
                )
                ["HConcat", rs, ls]
              rescue RuleFailure => ex
                self._pos = _p90
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p91 = _pos
              begin
                x = (
                  self.simplehost1()
                )
                x
              rescue RuleFailure => ex
                self._pos = _p91
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.simplehost", _start, ex)
      else
        _t = _memoize("MMetaParser.simplehost", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'simplehost'
      raise ex
    end
  end
  

  
  def simplehost1
    throws RuleFailure
    begin
      _start = _pos; xs = nil; num = nil; s = nil; n = nil
      _t = _sretrieve("MMetaParser.simplehost1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p94 = _pos
              begin
                if _string.startsWith("[", _pos)
                  self._pos += 1
                  "["
                else
                  raise @error
                end
                xs = (
                  self.listOf("simplehost", ",")
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                if _string.startsWith("]", _pos)
                  self._pos += 1
                  "]"
                else
                  raise @error
                end
                concat(["HList"], xs)
              rescue RuleFailure => ex
                self._pos = _p94
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p95 = _pos
                begin
                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                  num = (
                    self.number()
                  )
                  num
                rescue RuleFailure => ex
                  self._pos = _p95
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                begin
                  _p98 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    begin
                      if _string.startsWith("'", _pos)
                        self._pos += 1
                        "'"
                      else
                        raise @error
                      end
                    rescue RuleFailure
                      if _string.startsWith(":", _pos)
                        self._pos += 1
                        ":"
                      else
                        raise @error
                      end
                    end
                    s = (
                      self.name()
                    )
                    ["HStr", s]
                  rescue RuleFailure => ex
                    self._pos = _p98
                    raise ex
                  end
                end
              rescue RuleFailure
                begin
                  begin
                    _p99 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      s = (
                        self.tsString()
                      )
                      ["HStr", s]
                    rescue RuleFailure => ex
                      self._pos = _p99
                      raise ex
                    end
                  end
                rescue RuleFailure
                  begin
                    begin
                      _p101 = _pos
                      begin
                        if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                        if _string.startsWith("@", _pos)
                          self._pos += 1
                          "@"
                        else
                          raise @error
                        end
                        n = (
                          self.name()
                        )
                        ["HLit", "@#{n}"]
                      rescue RuleFailure => ex
                        self._pos = _p101
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    begin
                      _p102 = _pos
                      begin
                        if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                        n = (
                          self.name()
                        )
                        ["HLit", n]
                      rescue RuleFailure => ex
                        self._pos = _p102
                        raise ex
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.simplehost1", _start, ex)
      else
        _t = _memoize("MMetaParser.simplehost1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'simplehost1'
      raise ex
    end
  end
  

  
  def cbraces
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.cbraces")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p106 = _pos
              begin
                if _string.startsWith("{", _pos)
                  self._pos += 1
                  "{"
                else
                  raise @error
                end
                xs = (
                  begin
                    as104 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.cbraces()
                        )
                        as104.add(_li)
                      end
                    rescue RuleFailure; end
                    as104
                  end
                )
                if _string.startsWith("}", _pos)
                  self._pos += 1
                  "}"
                else
                  raise @error
                end
                begin
                   "{"+ join(xs) +"}" 
                end
              rescue RuleFailure => ex
                self._pos = _p106
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p108 = _pos
              begin
                begin  # not
                  if _string.startsWith("}", _pos)
                    self._pos += 1
                    "}"
                  else
                    raise @error
                  end
                  nil
                rescue RuleFailure
                  nil  # expected
                else
                  raise @error
                end
                self._any()
              rescue RuleFailure => ex
                self._pos = _p108
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.cbraces", _start, ex)
      else
        _t = _memoize("MMetaParser.cbraces", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'cbraces'
      raise ex
    end
  end
  

  
  def semAction
    throws RuleFailure
    begin
      _start = _pos; s = nil; xs = nil
      _t = _sretrieve("MMetaParser.semAction")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p111 = _pos
              begin
                if _string.startsWith("{", _pos)
                  self._pos += 1
                  "{"
                else
                  raise @error
                end
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                s = (
                  self.simplehost()
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                if _string.startsWith("}", _pos)
                  self._pos += 1
                  "}"
                else
                  raise @error
                end
                ["SAct", s]
              rescue RuleFailure => ex
                self._pos = _p111
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p116 = _pos
                begin
                  if _string.startsWith("{", _pos)
                    self._pos += 1
                    "{"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p115 = _pos
                      begin
                        xs = (
                          begin
                            as113 = ArrayList.new
                            begin
                              while true do
                                _li = Object(
                                  self.cbraces()
                                )
                                as113.add(_li)
                              end
                            rescue RuleFailure; end
                            as113
                          end
                        )
                        if _string.startsWith("}", _pos)
                          self._pos += 1
                          "}"
                        else
                          raise @error
                        end
                        ["Act", "#{join(xs)}"]
                      rescue RuleFailure => ex
                        self._pos = _p115
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p116
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                _p119 = _pos
                begin
                  if _string.startsWith("->", _pos)
                    self._pos += 2
                    "->"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p118 = _pos
                      begin
                        s = (
                          self.rewrite_expr()
                        )
                        ["SAct", s]
                      rescue RuleFailure => ex
                        self._pos = _p118
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p119
                  raise ex
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.semAction", _start, ex)
      else
        _t = _memoize("MMetaParser.semAction", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'semAction'
      raise ex
    end
  end
  

  
  def semPred
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.semPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p124 = _pos
            begin
              if _string.startsWith("?{", _pos)
                self._pos += 2
                "?{"
              else
                raise @error
              end
              begin
                begin
                  _p123 = _pos
                  begin
                    xs = (
                      begin
                        as121 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.cbraces()
                            )
                            as121.add(_li)
                          end
                        rescue RuleFailure; end
                        as121
                      end
                    )
                    if _string.startsWith("}", _pos)
                      self._pos += 1
                      "}"
                    else
                      raise @error
                    end
                    ["Pred", "#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p123
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p124
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.semPred", _start, ex)
      else
        _t = _memoize("MMetaParser.semPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'semPred'
      raise ex
    end
  end
  

  
  def synPred
    throws RuleFailure
    begin
      _start = _pos; p = nil; e = nil; t = nil
      _t = _sretrieve("MMetaParser.synPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p129 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              if _string.startsWith("(", _pos)
                self._pos += 1
                "("
              else
                raise @error
              end
              p = (
                self.expr()
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              if _string.startsWith(")", _pos)
                self._pos += 1
                ")"
              else
                raise @error
              end
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              if _string.startsWith("=>", _pos)
                self._pos += 2
                "=>"
              else
                raise @error
              end
              e = (
                self.expr4()
              )
              begin
                begin
                  _p128 = _pos
                  begin
                    t = (
                      self.synPredTail()
                    )
                    ["SynPred", ["Peek", p], e, t]
                  rescue RuleFailure => ex
                    self._pos = _p128
                    raise ex
                  end
                end
              rescue RuleFailure
                ["SynPred", ["Peek", p], e]
              end
            rescue RuleFailure => ex
              self._pos = _p129
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.synPred", _start, ex)
      else
        _t = _memoize("MMetaParser.synPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'synPred'
      raise ex
    end
  end
  

  
  def synPredTail
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.synPredTail")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p131 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              if _string.startsWith("|", _pos)
                self._pos += 1
                "|"
              else
                raise @error
              end
              begin
                self.synPred()
              rescue RuleFailure
                self.expr4()
              end
            rescue RuleFailure => ex
              self._pos = _p131
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.synPredTail", _start, ex)
      else
        _t = _memoize("MMetaParser.synPredTail", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'synPredTail'
      raise ex
    end
  end
  

  
  def token
    throws RuleFailure
    begin
      _start = _pos; n = nil
      _t = _sretrieve("MMetaParser.token")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p133 = _pos
            begin
              if _string.startsWith("$", _pos)
                self._pos += 1
                "$"
              else
                raise @error
              end
              n = (
                self.name()
              )
              n
            rescue RuleFailure => ex
              self._pos = _p133
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.token", _start, ex)
      else
        _t = _memoize("MMetaParser.token", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'token'
      raise ex
    end
  end
  

  
  def tokens
    throws RuleFailure
    begin
      _start = _pos; a = nil; b = nil
      _t = _sretrieve("MMetaParser.tokens")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p136 = _pos
            begin
              a = (
                self.token()
              )
              begin
                begin
                  _p135 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    if _string.startsWith("..", _pos)
                      self._pos += 2
                      ".."
                    else
                      raise @error
                    end
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    b = (
                      self.token()
                    )
                    ["TokenRange", a, b]
                  rescue RuleFailure => ex
                    self._pos = _p135
                    raise ex
                  end
                end
              rescue RuleFailure
                ["Token", a]
              end
            rescue RuleFailure => ex
              self._pos = _p136
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.tokens", _start, ex)
      else
        _t = _memoize("MMetaParser.tokens", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'tokens'
      raise ex
    end
  end
  

  
  def expr
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.expr")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p137 = _pos
            begin
              xs = (
                self.listOf("expr4", "|")
              )
              concat(["Or"], xs)
            rescue RuleFailure => ex
              self._pos = _p137
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr", _start, ex)
      else
        _t = _memoize("MMetaParser.expr", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr'
      raise ex
    end
  end
  

  
  def expr4
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaParser.expr4")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p139 = _pos
            begin
              xs = (
                begin
                  as138 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          self.error()
                        rescue RuleFailure
                          self.expr3()
                        end
                      )
                      as138.add(_li)
                    end
                  rescue RuleFailure; end
                  as138
                end
              )
              concat(["And"], xs)
            rescue RuleFailure => ex
              self._pos = _p139
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr4", _start, ex)
      else
        _t = _memoize("MMetaParser.expr4", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr4'
      raise ex
    end
  end
  

  
  def optIter(x:Object)
    throws RuleFailure
    begin
      _start = _pos
      begin
        begin
          _p141 = _pos
          begin
            if _string.startsWith("*", _pos)
              self._pos += 1
              "*"
            else
              raise @error
            end
            ["Many", x]
          rescue RuleFailure => ex
            self._pos = _p141
            raise ex
          end
        end
      rescue RuleFailure
        begin
          begin
            _p143 = _pos
            begin
              if _string.startsWith("+", _pos)
                self._pos += 1
                "+"
              else
                raise @error
              end
              ["Many1", x]
            rescue RuleFailure => ex
              self._pos = _p143
              raise ex
            end
          end
        rescue RuleFailure
          begin
            begin
              _p145 = _pos
              begin
                if _string.startsWith("?", _pos)
                  self._pos += 1
                  "?"
                else
                  raise @error
                end
                ["Opt", x]
              rescue RuleFailure => ex
                self._pos = _p145
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p146 = _pos
              begin
                self.empty()
                x
              rescue RuleFailure => ex
                self._pos = _p146
                raise ex
              end
            end
          end
        end
      end
    rescue RuleFailure => ex
      ex.last = 'optIter'
      raise ex
    end
  end
  

  
  def expr3
    throws RuleFailure
    begin
      _start = _pos; n = nil; e = nil; x = nil
      _t = _sretrieve("MMetaParser.expr3")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p149 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                n = (
                  self.name()
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                if _string.startsWith("=", _pos)
                  self._pos += 1
                  "="
                else
                  raise @error
                end
                begin
                  begin
                    _p148 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      e = (
                        self.expr2()
                      )
                      x = (
                        self.optIter(e)
                      )
                      ["Set", n, x]
                    rescue RuleFailure => ex
                      self._pos = _p148
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p149
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p150 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                e = (
                  self.expr2()
                )
                x = (
                  self.optIter(e)
                )
                x
              rescue RuleFailure => ex
                self._pos = _p150
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr3", _start, ex)
      else
        _t = _memoize("MMetaParser.expr3", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr3'
      raise ex
    end
  end
  

  
  def expr2
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaParser.expr2")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p153 = _pos
              begin
                if _string.startsWith("~", _pos)
                  self._pos += 1
                  "~"
                else
                  raise @error
                end
                begin
                  begin
                    _p152 = _pos
                    begin
                      x = (
                        self.expr2()
                      )
                      ["Not", x]
                    rescue RuleFailure => ex
                      self._pos = _p152
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p153
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p156 = _pos
                begin
                  if _string.startsWith("&", _pos)
                    self._pos += 1
                    "&"
                  else
                    raise @error
                  end
                  begin
                    begin
                      _p155 = _pos
                      begin
                        x = (
                          self.expr1()
                        )
                        ["Peek", x]
                      rescue RuleFailure => ex
                        self._pos = _p155
                        raise ex
                      end
                    end
                  rescue RuleFailure
                    raise SyntaxError.new("", @error.last, _pos, _string, _list)
                  end
                rescue RuleFailure => ex
                  self._pos = _p156
                  raise ex
                end
              end
            rescue RuleFailure
              self.expr1()
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr2", _start, ex)
      else
        _t = _memoize("MMetaParser.expr2", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr2'
      raise ex
    end
  end
  

  
  def expr1
    throws RuleFailure
    begin
      _start = _pos; k = nil; x = nil
      _t = _sretrieve("MMetaParser.expr1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            self.wsdot()
          rescue RuleFailure
            begin
              self.any()
            rescue RuleFailure
              begin
                self.semPred()
              rescue RuleFailure
                begin
                  self.semAction()
                rescue RuleFailure
                  begin
                    self.application()
                  rescue RuleFailure
                    begin
                      self.tokens()
                    rescue RuleFailure
                      begin
                        begin
                          _p157 = _pos
                          begin
                            k = (
                              begin
                                self.k("null")
                              rescue RuleFailure
                                begin
                                  self.k("true")
                                rescue RuleFailure
                                  self.k("false")
                                end
                              end
                            )
                            ["HLit", k]
                          rescue RuleFailure => ex
                            self._pos = _p157
                            raise ex
                          end
                        end
                      rescue RuleFailure
                        begin
                          self.string()
                        rescue RuleFailure
                          begin
                            self.symbol()
                          rescue RuleFailure
                            begin
                              self.number()
                            rescue RuleFailure
                              begin
                                begin
                                  _p161 = _pos
                                  begin
                                    if _string.startsWith("[", _pos)
                                      self._pos += 1
                                      "["
                                    else
                                      raise @error
                                    end
                                    begin
                                      begin
                                        _p160 = _pos
                                        begin
                                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                          x = (
                                            self.expr()
                                          )
                                          if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                          if _string.startsWith("]", _pos)
                                            self._pos += 1
                                            "]"
                                          else
                                            raise @error
                                          end
                                          ["List", x]
                                        rescue RuleFailure => ex
                                          self._pos = _p160
                                          raise ex
                                        end
                                      end
                                    rescue RuleFailure
                                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                                    end
                                  rescue RuleFailure => ex
                                    self._pos = _p161
                                    raise ex
                                  end
                                end
                              rescue RuleFailure
                                begin
                                  self.synPred()
                                rescue RuleFailure
                                  begin
                                    _p165 = _pos
                                    begin
                                      if _string.startsWith("(", _pos)
                                        self._pos += 1
                                        "("
                                      else
                                        raise @error
                                      end
                                      begin
                                        begin
                                          _p164 = _pos
                                          begin
                                            if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                            x = (
                                              self.expr()
                                            )
                                            if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                            if _string.startsWith(")", _pos)
                                              self._pos += 1
                                              ")"
                                            else
                                              raise @error
                                            end
                                            x
                                          rescue RuleFailure => ex
                                            self._pos = _p164
                                            raise ex
                                          end
                                        end
                                      rescue RuleFailure
                                        raise SyntaxError.new("", @error.last, _pos, _string, _list)
                                      end
                                    rescue RuleFailure => ex
                                      self._pos = _p165
                                      raise ex
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.expr1", _start, ex)
      else
        _t = _memoize("MMetaParser.expr1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'expr1'
      raise ex
    end
  end
  

  
  def annotation
    throws RuleFailure
    begin
      _start = _pos; t = nil; l = nil
      _t = _sretrieve("MMetaParser.annotation")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p170 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                if _string.startsWith("$Memo", _pos)
                  self._pos += 5
                  "$Memo"
                else
                  raise @error
                end
                begin  # optional
                  begin
                    _p169 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      if _string.startsWith("[", _pos)
                        self._pos += 1
                        "["
                      else
                        raise @error
                      end
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      t = (
                        self.name()
                      )
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      if _string.startsWith("]", _pos)
                        self._pos += 1
                        "]"
                      else
                        raise @error
                      end
                    rescue RuleFailure => ex
                      self._pos = _p169
                      raise ex
                    end
                  end
                rescue RuleFailure
                  nil
                end
                ["Memo", t]
              rescue RuleFailure => ex
                self._pos = _p170
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p175 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                if _string.startsWith("$Scope", _pos)
                  self._pos += 6
                  "$Scope"
                else
                  raise @error
                end
                begin
                  begin
                    _p174 = _pos
                    begin
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      if _string.startsWith("[", _pos)
                        self._pos += 1
                        "["
                      else
                        raise @error
                      end
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      l = (
                        self.listOf("varname", ",")
                      )
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                      if _string.startsWith("]", _pos)
                        self._pos += 1
                        "]"
                      else
                        raise @error
                      end
                      ["Scope", l]
                    rescue RuleFailure => ex
                      self._pos = _p174
                      raise ex
                    end
                  end
                rescue RuleFailure
                  raise SyntaxError.new("", @error.last, _pos, _string, _list)
                end
              rescue RuleFailure => ex
                self._pos = _p175
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.annotation", _start, ex)
      else
        _t = _memoize("MMetaParser.annotation", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'annotation'
      raise ex
    end
  end
  

  
  def ruleArgs
    throws RuleFailure
    begin
      _start = _pos; s = nil
      _t = _sretrieve("MMetaParser.ruleArgs")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p181 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              if _string.startsWith("(", _pos)
                self._pos += 1
                "("
              else
                raise @error
              end
              s = (
                begin
                  as179 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          _p178 = _pos
                          begin
                            begin  # not
                              if _string.startsWith(")", _pos)
                                self._pos += 1
                                ")"
                              else
                                raise @error
                              end
                              nil
                            rescue RuleFailure
                              nil  # expected
                            else
                              raise @error
                            end
                            self._any()
                          rescue RuleFailure => ex
                            self._pos = _p178
                            raise ex
                          end
                        end
                      )
                      as179.add(_li)
                    end
                  rescue RuleFailure; end
                  as179
                end
              )
              if _string.startsWith(")", _pos)
                self._pos += 1
                ")"
              else
                raise @error
              end
              "(#{join(s)})"
            rescue RuleFailure => ex
              self._pos = _p181
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ruleArgs", _start, ex)
      else
        _t = _memoize("MMetaParser.ruleArgs", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ruleArgs'
      raise ex
    end
  end
  

  
  def rule
    throws RuleFailure
    begin
      _start = _pos; a = nil; n = nil; args = nil; x = nil
      _t = _sretrieve("MMetaParser.rule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p186 = _pos
            begin
              a = (
                begin
                  as182 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.annotation()
                      )
                      as182.add(_li)
                    end
                  rescue RuleFailure; end
                  as182
                end
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              n = (
                self.rulename()
              )
              begin
                begin
                  _p185 = _pos
                  begin
                    args = (
                      begin  # optional
                        self.ruleArgs()
                      rescue RuleFailure
                        nil
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    if _string.startsWith(":", _pos)
                      self._pos += 1
                      ":"
                    else
                      raise @error
                    end
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    x = (
                      self.expr()
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    if _string.startsWith(";", _pos)
                      self._pos += 1
                      ";"
                    else
                      raise @error
                    end
                    ["Rule", n, args, x, a]
                  rescue RuleFailure => ex
                    self._pos = _p185
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p186
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.rule", _start, ex)
      else
        _t = _memoize("MMetaParser.rule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'rule'
      raise ex
    end
  end
  

  
  def qualifiers
    throws RuleFailure
    begin
      _start = _pos; qs = nil
      _t = _sretrieve("MMetaParser.qualifiers")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p193 = _pos
            begin
              qs = (
                begin
                  as192 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        begin
                          begin
                            _p187 = _pos
                            begin
                              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                              self.k("public")
                            rescue RuleFailure => ex
                              self._pos = _p187
                              raise ex
                            end
                          end
                        rescue RuleFailure
                          begin
                            begin
                              _p188 = _pos
                              begin
                                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                self.k("private")
                              rescue RuleFailure => ex
                                self._pos = _p188
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            begin
                              begin
                                _p189 = _pos
                                begin
                                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                  self.k("final")
                                rescue RuleFailure => ex
                                  self._pos = _p189
                                  raise ex
                                end
                              end
                            rescue RuleFailure
                              begin
                                begin
                                  _p190 = _pos
                                  begin
                                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                    self.k("static")
                                  rescue RuleFailure => ex
                                    self._pos = _p190
                                    raise ex
                                  end
                                end
                              rescue RuleFailure
                                begin
                                  _p191 = _pos
                                  begin
                                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                    self.k("abstract")
                                  rescue RuleFailure => ex
                                    self._pos = _p191
                                    raise ex
                                  end
                                end
                              end
                            end
                          end
                        end
                      )
                      as192.add(_li)
                    end
                  rescue RuleFailure; end
                  raise @error if as192.size == 0
                  as192
                end
              )
              begin
                
                        join(qs, " ")
                    
              end
            rescue RuleFailure => ex
              self._pos = _p193
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.qualifiers", _start, ex)
      else
        _t = _memoize("MMetaParser.qualifiers", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'qualifiers'
      raise ex
    end
  end
  

  
  def method
    throws RuleFailure
    begin
      _start = _pos; m = nil; s = nil; n = nil; as = nil; bs = nil
      _t = _sretrieve("MMetaParser.method")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p208 = _pos
            begin
              m = (
                begin  # optional
                  begin
                    _p194 = _pos
                    begin
                      self.k("macro")
                      if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    rescue RuleFailure => ex
                      self._pos = _p194
                      raise ex
                    end
                  end
                rescue RuleFailure
                  nil
                end
              )
              self.k("def")
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              s = (
                begin
                  if _string.startsWith("self.", _pos)
                    self._pos += 5
                    "self."
                  else
                    raise @error
                  end
                rescue RuleFailure
                  ""
                end
              )
              begin
                begin
                  _p207 = _pos
                  begin
                    n = (
                      self.name()
                    )
                    begin
                      begin
                        _p206 = _pos
                        begin
                          begin
                            begin
                              _p201 = _pos
                              begin
                                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                if _string.startsWith("(", _pos)
                                  self._pos += 1
                                  "("
                                else
                                  raise @error
                                end
                                as = (
                                  begin
                                    as199 = ArrayList.new
                                    begin
                                      while true do
                                        _li = Object(
                                          begin
                                            _p198 = _pos
                                            begin
                                              begin  # not
                                                if _string.startsWith(")", _pos)
                                                  self._pos += 1
                                                  ")"
                                                else
                                                  raise @error
                                                end
                                                nil
                                              rescue RuleFailure
                                                nil  # expected
                                              else
                                                raise @error
                                              end
                                              self._any()
                                            rescue RuleFailure => ex
                                              self._pos = _p198
                                              raise ex
                                            end
                                          end
                                        )
                                        as199.add(_li)
                                      end
                                    rescue RuleFailure; end
                                    as199
                                  end
                                )
                                if _string.startsWith(")", _pos)
                                  self._pos += 1
                                  ")"
                                else
                                  raise @error
                                end
                              rescue RuleFailure => ex
                                self._pos = _p201
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            ""
                          end
                          begin
                            begin
                              _p205 = _pos
                              begin
                                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                if _string.startsWith("{", _pos)
                                  self._pos += 1
                                  "{"
                                else
                                  raise @error
                                end
                                bs = (
                                  begin
                                    as203 = ArrayList.new
                                    begin
                                      while true do
                                        _li = Object(
                                          self.cbraces()
                                        )
                                        as203.add(_li)
                                      end
                                    rescue RuleFailure; end
                                    as203
                                  end
                                )
                                if _string.startsWith("}", _pos)
                                  self._pos += 1
                                  "}"
                                else
                                  raise @error
                                end
                                ["Method", "#{s}#{n}", "#{join(as)}", "#{join(bs)}", m]
                              rescue RuleFailure => ex
                                self._pos = _p205
                                raise ex
                              end
                            end
                          rescue RuleFailure
                            raise SyntaxError.new("", @error.last, _pos, _string, _list)
                          end
                        rescue RuleFailure => ex
                          self._pos = _p206
                          raise ex
                        end
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p207
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p208
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.method", _start, ex)
      else
        _t = _memoize("MMetaParser.method", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'method'
      raise ex
    end
  end
  

  
  def jimport
    throws RuleFailure
    begin
      _start = _pos; stm = nil; xs = nil
      _t = _sretrieve("MMetaParser.jimport")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p213 = _pos
            begin
              stm = (
                self.k("import")
              )
              begin
                begin
                  _p212 = _pos
                  begin
                    xs = (
                      begin
                        as210 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p209 = _pos
                                begin
                                  begin  # not
                                    self.oneOf(";\n")
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p209
                                  raise ex
                                end
                              end
                            )
                            as210.add(_li)
                          end
                        rescue RuleFailure; end
                        as210
                      end
                    )
                    begin  # optional
                      if _string.startsWith(";", _pos)
                        self._pos += 1
                        ";"
                      else
                        raise @error
                      end
                    rescue RuleFailure
                      nil
                    end
                    ["Import", "#{stm}#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p212
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p213
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.jimport", _start, ex)
      else
        _t = _memoize("MMetaParser.jimport", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'jimport'
      raise ex
    end
  end
  

  
  def jpackage
    throws RuleFailure
    begin
      _start = _pos; stm = nil; xs = nil
      _t = _sretrieve("MMetaParser.jpackage")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p218 = _pos
            begin
              stm = (
                self.k("package")
              )
              begin
                begin
                  _p217 = _pos
                  begin
                    xs = (
                      begin
                        as215 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p214 = _pos
                                begin
                                  begin  # not
                                    self.oneOf(";\n")
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p214
                                  raise ex
                                end
                              end
                            )
                            as215.add(_li)
                          end
                        rescue RuleFailure; end
                        as215
                      end
                    )
                    begin  # optional
                      if _string.startsWith(";", _pos)
                        self._pos += 1
                        ";"
                      else
                        raise @error
                      end
                    rescue RuleFailure
                      nil
                    end
                    ["Package", "#{stm}#{join(xs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p217
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p218
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.jpackage", _start, ex)
      else
        _t = _memoize("MMetaParser.jpackage", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'jpackage'
      raise ex
    end
  end
  

  
  def classdef
    throws RuleFailure
    begin
      _start = _pos; q = nil; xs = nil; bs = nil
      _t = _sretrieve("MMetaParser.classdef")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p226 = _pos
            begin
              q = (
                self.qualifiers()
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              self.k("class")
              begin
                begin
                  _p225 = _pos
                  begin
                    xs = (
                      begin
                        as221 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              begin
                                _p220 = _pos
                                begin
                                  begin  # not
                                    if _string.startsWith("{", _pos)
                                      self._pos += 1
                                      "{"
                                    else
                                      raise @error
                                    end
                                    nil
                                  rescue RuleFailure
                                    nil  # expected
                                  else
                                    raise @error
                                  end
                                  self._any()
                                rescue RuleFailure => ex
                                  self._pos = _p220
                                  raise ex
                                end
                              end
                            )
                            as221.add(_li)
                          end
                        rescue RuleFailure; end
                        as221
                      end
                    )
                    if _string.startsWith("{", _pos)
                      self._pos += 1
                      "{"
                    else
                      raise @error
                    end
                    bs = (
                      begin
                        as223 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.cbraces()
                            )
                            as223.add(_li)
                          end
                        rescue RuleFailure; end
                        as223
                      end
                    )
                    if _string.startsWith("}", _pos)
                      self._pos += 1
                      "}"
                    else
                      raise @error
                    end
                    ["Class", q, " class #{join(xs)}", "#{join(bs)}"]
                  rescue RuleFailure => ex
                    self._pos = _p225
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p226
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.classdef", _start, ex)
      else
        _t = _memoize("MMetaParser.classdef", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'classdef'
      raise ex
    end
  end
  

  
  def ruleMethod
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.ruleMethod")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p227 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                self.method()
              rescue RuleFailure => ex
                self._pos = _p227
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p228 = _pos
              begin
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                self.rule()
              rescue RuleFailure => ex
                self._pos = _p228
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.ruleMethod", _start, ex)
      else
        _t = _memoize("MMetaParser.ruleMethod", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'ruleMethod'
      raise ex
    end
  end
  

  
  def parser
    throws RuleFailure
    begin
      _start = _pos; m = nil; n = nil; sn = nil; rs = nil; p = nil
      _t = _sretrieve("MMetaParser.parser")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p237 = _pos
            begin
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              m = (
                begin
                  self.k("public")
                rescue RuleFailure
                  self.empty()
                end
              )
              if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              self.k("parser")
              begin
                begin
                  _p236 = _pos
                  begin
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    n = (
                      self.name()
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    sn = (
                      begin
                        begin
                          _p231 = _pos
                          begin
                            begin
                              self.k("extends")
                            rescue RuleFailure
                              begin
                                _p230 = _pos
                                begin
                                  if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                                  if _string.startsWith("<", _pos)
                                    self._pos += 1
                                    "<"
                                  else
                                    raise @error
                                  end
                                rescue RuleFailure => ex
                                  self._pos = _p230
                                  raise ex
                                end
                              end
                            end
                            if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                            self.name()
                          rescue RuleFailure => ex
                            self._pos = _p231
                            raise ex
                          end
                        end
                      rescue RuleFailure
                        begin
                          _p232 = _pos
                          begin
                            self.empty()
                            "BaseParser"
                          rescue RuleFailure => ex
                            self._pos = _p232
                            raise ex
                          end
                        end
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    if _string.startsWith("{", _pos)
                      self._pos += 1
                      "{"
                    else
                      raise @error
                    end
                    rs = (
                      begin
                        as234 = ArrayList.new
                        begin
                          while true do
                            _li = Object(
                              self.ruleMethod()
                            )
                            as234.add(_li)
                          end
                        rescue RuleFailure; end
                        as234
                      end
                    )
                    if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                    if _string.startsWith("}", _pos)
                      self._pos += 1
                      "}"
                    else
                      raise @error
                    end
                    p = (
                      concat(["Parser", m, n, sn], rs)
                    )
                    begin
                      begin
                        
                                           if (Boolean.getBoolean("mmeta.optimize.debug"))
                                             System.out.println("Before:\n" + BaseParser.print_r(p));
                                           end
                                           MMetaOptimizer.new().parse(p, "optimizeGrammar");
                                        
                      end
                    rescue RuleFailure
                      raise SyntaxError.new("", @error.last, _pos, _string, _list)
                    end
                  rescue RuleFailure => ex
                    self._pos = _p236
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p237
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.parser", _start, ex)
      else
        _t = _memoize("MMetaParser.parser", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'parser'
      raise ex
    end
  end
  

  
  def line
    throws RuleFailure
    begin
      _start = _pos; p = nil; l = nil
      _t = _sretrieve("MMetaParser.line")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p238 = _pos
            begin
              p = (
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
              )
              l = (
                begin
                  self.parser()
                rescue RuleFailure
                  begin
                    self.jpackage()
                  rescue RuleFailure
                    begin
                      self.jimport()
                    rescue RuleFailure
                      self.classdef()
                    end
                  end
                end
              )
              ["Line", "#{join(p)}", l]
            rescue RuleFailure => ex
              self._pos = _p238
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.line", _start, ex)
      else
        _t = _memoize("MMetaParser.line", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'line'
      raise ex
    end
  end
  

  
  def file
    throws RuleFailure
    begin
      _start = _pos; ls = nil
      _t = _sretrieve("MMetaParser.file")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p240 = _pos
              begin
                ls = (
                  begin
                    as239 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.line()
                        )
                        as239.add(_li)
                      end
                    rescue RuleFailure; end
                    as239
                  end
                )
                if _start == _pos;ws();_real_start=_pos;nil;else;ws();nil;end
                self.end()
                concat(["File"], ls)
              rescue RuleFailure => ex
                self._pos = _p240
                raise ex
              end
            end
          rescue RuleFailure
            raise SyntaxError.new("", @error.last, _pos, _string, _list)
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.file", _start, ex)
      else
        _t = _memoize("MMetaParser.file", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'file'
      raise ex
    end
  end
  

  
  def start
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaParser.start")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          self.file()
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaParser.start", _start, ex)
      else
        _t = _memoize("MMetaParser.start", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'start'
      raise ex
    end
  end
  


  def _jump(r:String)
    return sp() if (r == "sp")
    return ws() if (r == "ws")
    return nameFirst() if (r == "nameFirst")
    return nameRest() if (r == "nameRest")
    return name() if (r == "name")
    return rulename() if (r == "rulename")
    return varname() if (r == "varname")
    return hex() if (r == "hex")
    return echar() if (r == "echar")
    return tsString() if (r == "tsString")
    return dollar() if (r == "dollar")
    return dollarstring() if (r == "dollarstring")
    return string() if (r == "string")
    return number() if (r == "number")
    return symbol() if (r == "symbol")
    return error() if (r == "error")
    return any() if (r == "any")
    return wsdot() if (r == "wsdot")
    return args() if (r == "args")
    return application() if (r == "application")
    return fname() if (r == "fname")
    return parens() if (r == "parens")
    return rewrite_expr() if (r == "rewrite_expr")
    return simplehost() if (r == "simplehost")
    return simplehost1() if (r == "simplehost1")
    return cbraces() if (r == "cbraces")
    return semAction() if (r == "semAction")
    return semPred() if (r == "semPred")
    return synPred() if (r == "synPred")
    return synPredTail() if (r == "synPredTail")
    return token() if (r == "token")
    return tokens() if (r == "tokens")
    return expr() if (r == "expr")
    return expr4() if (r == "expr4")
    return expr3() if (r == "expr3")
    return expr2() if (r == "expr2")
    return expr1() if (r == "expr1")
    return annotation() if (r == "annotation")
    return ruleArgs() if (r == "ruleArgs")
    return rule() if (r == "rule")
    return qualifiers() if (r == "qualifiers")
    return method() if (r == "method")
    return jimport() if (r == "jimport")
    return jpackage() if (r == "jpackage")
    return classdef() if (r == "classdef")
    return ruleMethod() if (r == "ruleMethod")
    return parser() if (r == "parser")
    return line() if (r == "line")
    return file() if (r == "file")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "sp")
    return true if (r == "ws")
    return true if (r == "nameFirst")
    return true if (r == "nameRest")
    return true if (r == "name")
    return true if (r == "rulename")
    return true if (r == "varname")
    return true if (r == "hex")
    return true if (r == "echar")
    return true if (r == "tsString")
    return true if (r == "dollar")
    return true if (r == "dollarstring")
    return true if (r == "string")
    return true if (r == "number")
    return true if (r == "symbol")
    return true if (r == "error")
    return true if (r == "any")
    return true if (r == "wsdot")
    return true if (r == "args")
    return true if (r == "application")
    return true if (r == "fname")
    return true if (r == "parens")
    return true if (r == "rewrite_expr")
    return true if (r == "simplehost")
    return true if (r == "simplehost1")
    return true if (r == "cbraces")
    return true if (r == "semAction")
    return true if (r == "semPred")
    return true if (r == "synPred")
    return true if (r == "synPredTail")
    return true if (r == "token")
    return true if (r == "tokens")
    return true if (r == "expr")
    return true if (r == "expr4")
    return true if (r == "expr3")
    return true if (r == "expr2")
    return true if (r == "expr1")
    return true if (r == "annotation")
    return true if (r == "ruleArgs")
    return true if (r == "rule")
    return true if (r == "qualifiers")
    return true if (r == "method")
    return true if (r == "jimport")
    return true if (r == "jpackage")
    return true if (r == "classdef")
    return true if (r == "ruleMethod")
    return true if (r == "parser")
    return true if (r == "line")
    return true if (r == "file")
    return true if (r == "start")
    super(r)
  end
end

class MMetaPass < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  def init()
    
        @changed = false
      
  end
  

  def changed()
    
        @changed
      
  end
  

  def changed_set(value:boolean)
    
        @changed = value
      
  end
  

  
  def setChanged
    throws RuleFailure
    begin
      _start = _pos
      _t = _sretrieve("MMetaPass.setChanged")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            @changed = true; nil;
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.setChanged", _start, ex)
      else
        _t = _memoize("MMetaPass.setChanged", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'setChanged'
      raise ex
    end
  end
  

  
  def destruct
    throws RuleFailure
    begin
      _start = _pos; r = nil; x = nil
      _t = _sretrieve("MMetaPass.destruct")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p242 = _pos
            begin
              r = (
                self._any()
              )
              raise @error unless ( hasRule(r) )
              begin
                begin
                  _p241 = _pos
                  begin
                    x = (
                      self.apply(r)
                    )
                    self.end()
                    x
                  rescue RuleFailure => ex
                    self._pos = _p241
                    raise ex
                  end
                end
              rescue RuleFailure
                raise SyntaxError.new("", @error.last, _pos, _string, _list)
              end
            rescue RuleFailure => ex
              self._pos = _p242
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.destruct", _start, ex)
      else
        _t = _memoize("MMetaPass.destruct", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'destruct'
      raise ex
    end
  end
  

  
  def trans
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.trans")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p243 = _pos
              begin
                begin
                  _t = _listBegin()
                  begin
                    x = (
                      self.destruct()
                    )
                  ensure
                    _listEnd()
                  end
                end
                x
              rescue RuleFailure => ex
                self._pos = _p243
                raise ex
              end
            end
          rescue RuleFailure
            self._any()
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.trans", _start, ex)
      else
        _t = _memoize("MMetaPass.trans", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'trans'
      raise ex
    end
  end
  

  
  def Or
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaPass.Or")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p245 = _pos
            begin
              xs = (
                begin
                  as244 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as244.add(_li)
                    end
                  rescue RuleFailure; end
                  as244
                end
              )
              concat(["Or"], xs)
            rescue RuleFailure => ex
              self._pos = _p245
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Or", _start, ex)
      else
        _t = _memoize("MMetaPass.Or", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Or'
      raise ex
    end
  end
  

  
  def And
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaPass.And")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p247 = _pos
            begin
              xs = (
                begin
                  as246 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as246.add(_li)
                    end
                  rescue RuleFailure; end
                  as246
                end
              )
              concat(["And"], xs)
            rescue RuleFailure => ex
              self._pos = _p247
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.And", _start, ex)
      else
        _t = _memoize("MMetaPass.And", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'And'
      raise ex
    end
  end
  

  
  def Not
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Not")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p248 = _pos
            begin
              x = (
                self.trans()
              )
              ["Not", x]
            rescue RuleFailure => ex
              self._pos = _p248
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Not", _start, ex)
      else
        _t = _memoize("MMetaPass.Not", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Not'
      raise ex
    end
  end
  

  
  def Many
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Many")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p249 = _pos
            begin
              x = (
                self.trans()
              )
              ["Many", x]
            rescue RuleFailure => ex
              self._pos = _p249
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Many", _start, ex)
      else
        _t = _memoize("MMetaPass.Many", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Many'
      raise ex
    end
  end
  

  
  def Many1
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Many1")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p250 = _pos
            begin
              x = (
                self.trans()
              )
              ["Many1", x]
            rescue RuleFailure => ex
              self._pos = _p250
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Many1", _start, ex)
      else
        _t = _memoize("MMetaPass.Many1", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Many1'
      raise ex
    end
  end
  

  
  def Peek
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.Peek")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p251 = _pos
            begin
              x = (
                self.trans()
              )
              ["Peek", x]
            rescue RuleFailure => ex
              self._pos = _p251
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Peek", _start, ex)
      else
        _t = _memoize("MMetaPass.Peek", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Peek'
      raise ex
    end
  end
  

  
  def List
    throws RuleFailure
    begin
      _start = _pos; x = nil
      _t = _sretrieve("MMetaPass.List")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p252 = _pos
            begin
              x = (
                self.trans()
              )
              ["List", x]
            rescue RuleFailure => ex
              self._pos = _p252
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.List", _start, ex)
      else
        _t = _memoize("MMetaPass.List", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'List'
      raise ex
    end
  end
  

  
  def Set
    throws RuleFailure
    begin
      _start = _pos; n = nil; x = nil
      _t = _sretrieve("MMetaPass.Set")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p253 = _pos
            begin
              n = (
                self._any()
              )
              x = (
                self.trans()
              )
              ["Set", n, x]
            rescue RuleFailure => ex
              self._pos = _p253
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Set", _start, ex)
      else
        _t = _memoize("MMetaPass.Set", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Set'
      raise ex
    end
  end
  

  
  def Rule
    throws RuleFailure
    begin
      _start = _pos; n = nil; args = nil; x = nil; anno = nil
      _t = _sretrieve("MMetaPass.Rule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p254 = _pos
            begin
              n = (
                self._any()
              )
              args = (
                self._any()
              )
              x = (
                self.trans()
              )
              anno = (
                self._any()
              )
              ["Rule", n, args, x, anno]
            rescue RuleFailure => ex
              self._pos = _p254
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Rule", _start, ex)
      else
        _t = _memoize("MMetaPass.Rule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Rule'
      raise ex
    end
  end
  

  
  def SynPred
    throws RuleFailure
    begin
      _start = _pos; xs = nil
      _t = _sretrieve("MMetaPass.SynPred")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p256 = _pos
            begin
              xs = (
                begin
                  as255 = ArrayList.new
                  begin
                    while true do
                      _li = Object(
                        self.trans()
                      )
                      as255.add(_li)
                    end
                  rescue RuleFailure; end
                  as255
                end
              )
              concat(["SynPred"], xs)
            rescue RuleFailure => ex
              self._pos = _p256
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.SynPred", _start, ex)
      else
        _t = _memoize("MMetaPass.SynPred", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'SynPred'
      raise ex
    end
  end
  

  
  def Error
    throws RuleFailure
    begin
      _start = _pos; m = nil; x = nil
      _t = _sretrieve("MMetaPass.Error")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p257 = _pos
            begin
              m = (
                self._any()
              )
              x = (
                self.trans()
              )
              ["Error", m, x]
            rescue RuleFailure => ex
              self._pos = _p257
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.Error", _start, ex)
      else
        _t = _memoize("MMetaPass.Error", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Error'
      raise ex
    end
  end
  

  
  def start
    throws RuleFailure
    begin
      _start = _pos; r = nil
      _t = _sretrieve("MMetaPass.start")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p258 = _pos
              begin
                r = (
                  self.destruct()
                )
                self.end()
                r
              rescue RuleFailure => ex
                self._pos = _p258
                raise ex
              end
            end
          rescue RuleFailure
            begin
              begin
                _p259 = _pos
                begin
                  r = (
                    self._any()
                  )
                  self.end()
                  r
                rescue RuleFailure => ex
                  self._pos = _p259
                  raise ex
                end
              end
            rescue RuleFailure
              begin
                _p261 = _pos
                begin
                  r = (
                    begin
                      as260 = ArrayList.new
                      begin
                        while true do
                          _li = Object(
                            self._any()
                          )
                          as260.add(_li)
                        end
                      rescue RuleFailure; end
                      as260
                    end
                  )
                  self.end()
                  r
                rescue RuleFailure => ex
                  self._pos = _p261
                  raise ex
                end
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaPass.start", _start, ex)
      else
        _t = _memoize("MMetaPass.start", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'start'
      raise ex
    end
  end
  


  def _jump(r:String)
    return setChanged() if (r == "setChanged")
    return destruct() if (r == "destruct")
    return trans() if (r == "trans")
    return Or() if (r == "Or")
    return And() if (r == "And")
    return Not() if (r == "Not")
    return Many() if (r == "Many")
    return Many1() if (r == "Many1")
    return Peek() if (r == "Peek")
    return List() if (r == "List")
    return Set() if (r == "Set")
    return Rule() if (r == "Rule")
    return SynPred() if (r == "SynPred")
    return Error() if (r == "Error")
    return start() if (r == "start")
    super(r)
  end

  def _has(r:String)
    return true if (r == "setChanged")
    return true if (r == "destruct")
    return true if (r == "trans")
    return true if (r == "Or")
    return true if (r == "And")
    return true if (r == "Not")
    return true if (r == "Many")
    return true if (r == "Many1")
    return true if (r == "Peek")
    return true if (r == "List")
    return true if (r == "Set")
    return true if (r == "Rule")
    return true if (r == "SynPred")
    return true if (r == "Error")
    return true if (r == "start")
    super(r)
  end
end

class MMetaAndOrOpt < MMetaPass
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  
  def And
    throws RuleFailure
    begin
      _start = _pos; x = nil; xs = nil
      _t = _sretrieve("MMetaAndOrOpt.And")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p262 = _pos
              begin
                x = (
                  self.trans()
                )
                self.end()
                self.setChanged()
                x
              rescue RuleFailure => ex
                self._pos = _p262
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p263 = _pos
              begin
                xs = (
                  self.transInside("And")
                )
                self.end()
                concat(["And"], xs)
              rescue RuleFailure => ex
                self._pos = _p263
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaAndOrOpt.And", _start, ex)
      else
        _t = _memoize("MMetaAndOrOpt.And", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'And'
      raise ex
    end
  end
  

  
  def Or
    throws RuleFailure
    begin
      _start = _pos; x = nil; xs = nil
      _t = _sretrieve("MMetaAndOrOpt.Or")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p264 = _pos
              begin
                x = (
                  self.trans()
                )
                self.end()
                self.setChanged()
                x
              rescue RuleFailure => ex
                self._pos = _p264
                raise ex
              end
            end
          rescue RuleFailure
            begin
              _p265 = _pos
              begin
                xs = (
                  self.transInside("Or")
                )
                self.end()
                concat(["Or"], xs)
              rescue RuleFailure => ex
                self._pos = _p265
                raise ex
              end
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaAndOrOpt.Or", _start, ex)
      else
        _t = _memoize("MMetaAndOrOpt.Or", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'Or'
      raise ex
    end
  end
  

  
  def transInside(s:String)
    throws RuleFailure
    begin
      _start = _pos; xs = nil; ys = nil; x = nil
      begin
        begin
          _p267 = _pos
          begin
            begin
              _t = _listBegin()
              begin
                begin
                  _p266 = _pos
                  begin
                    self.sym(s)
                    xs = (
                      self.transInside(s)
                    )
                  rescue RuleFailure => ex
                    self._pos = _p266
                    raise ex
                  end
                end
              ensure
                _listEnd()
              end
            end
            ys = (
              self.transInside(s)
            )
            self.setChanged()
            concat(xs, ys)
          rescue RuleFailure => ex
            self._pos = _p267
            raise ex
          end
        end
      rescue RuleFailure
        begin
          begin
            _p268 = _pos
            begin
              x = (
                self.trans()
              )
              xs = (
                self.transInside(s)
              )
              concat([x], xs)
            rescue RuleFailure => ex
              self._pos = _p268
              raise ex
            end
          end
        rescue RuleFailure
          ArrayList.new
        end
      end
    rescue RuleFailure => ex
      ex.last = 'transInside'
      raise ex
    end
  end
  


  def _jump(r:String)
    return And() if (r == "And")
    return Or() if (r == "Or")
    super(r)
  end

  def _has(r:String)
    return true if (r == "And")
    return true if (r == "Or")
    super(r)
  end
end

class MMetaOptimizer < BaseParser
  def _init
    @error = RuleFailure.new
    @chars = _chars
    super()
  end

  def _error(expected:String)
    throws RuleFailure
    @error.last = expected unless ''.equals(expected)
    raise @error
  end


  
  def optimizeGrammar
    throws RuleFailure
    begin
      _start = _pos; p = nil; n = nil; sn = nil; rs = nil; x = nil
      _t = _sretrieve("MMetaOptimizer.optimizeGrammar")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            begin
              _p270 = _pos
              begin
                _sym("Parser")
                p = (
                  self._any()
                )
                n = (
                  self._any()
                )
                sn = (
                  self._any()
                )
                rs = (
                  begin
                    as269 = ArrayList.new
                    begin
                      while true do
                        _li = Object(
                          self.optimizeRule()
                        )
                        as269.add(_li)
                      end
                    rescue RuleFailure; end
                    as269
                  end
                )
                self.end()
                x = (
                  concat(["Parser", p, n, sn], rs)
                )
                begin
                  
                                         if (Boolean.getBoolean("mmeta.optimize.debug"))
                                           System.out.println("Opt:\n" + BaseParser.print_r(x))
                                         end
                                         x
                                       
                end
              rescue RuleFailure => ex
                self._pos = _p270
                raise ex
              end
            end
          rescue RuleFailure
            raise SyntaxError.new("", @error.last, _pos, _string, _list)
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaOptimizer.optimizeGrammar", _start, ex)
      else
        _t = _memoize("MMetaOptimizer.optimizeGrammar", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'optimizeGrammar'
      raise ex
    end
  end
  

  
  def optimizeRule
    throws RuleFailure
    begin
      _start = _pos; r = nil
      _t = _sretrieve("MMetaOptimizer.optimizeRule")
      return _t unless _t == BaseParser.NOT_MEMOIZED
      begin
        _t2 = (
          begin
            _p271 = _pos
            begin
              r = (
                self._any()
              )
              begin
                
                        MMetaAndOrOpt opt = MMetaAndOrOpt.new()
                        begin
                            opt.changed = false
                            r = opt.parse(r)
                        end while (opt.changed)
                        r
                    
              end
            rescue RuleFailure => ex
              self._pos = _p271
              raise ex
            end
          end
        )
        _t = Object(_t2)
      rescue RuleFailure => ex
        _t = _memoize("MMetaOptimizer.optimizeRule", _start, ex)
      else
        _t = _memoize("MMetaOptimizer.optimizeRule", _start, _t)
      end
    rescue RuleFailure => ex
      ex.last = 'optimizeRule'
      raise ex
    end
  end
  


  def _jump(r:String)
    return optimizeGrammar() if (r == "optimizeGrammar")
    return optimizeRule() if (r == "optimizeRule")
    super(r)
  end

  def _has(r:String)
    return true if (r == "optimizeGrammar")
    return true if (r == "optimizeRule")
    super(r)
  end
end
